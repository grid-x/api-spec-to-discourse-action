openapi: 3.0.0
info:
  title: Solution API
  description: >-
    The user-centered Solution API makes it possible to build customised energy
    applications.
  version: 2.0.0
  license:
    name: All rights reserved.
    url: 'https://www.gridx.ai/'
  x-api-id: ba9d6a25-ae1a-4ac8-af7a-70b76db17021
  x-audience: company-internal
servers:
  - url: 'https://api.gridx.de'
tags:
  - name: Scan Configuration
    x-displayName: Scan Configuration
  - name: Account
    x-displayName: Account
  - name: Market Prices
    x-displayName: Market Prices
  - name: Token
    x-displayName: Token
  - name: System
    x-displayName: System
  - name: Policy
    x-displayName: Policy
  - name: Document
    x-displayName: Document
  - name: Group
    x-displayName: Group
  - name: User
    x-displayName: User
  - name: Notification
    x-displayName: Notification
  - name: Plan
    x-displayName: Plan
  - name: RFIDTag
    x-displayName: RFIDTag
  - name: Platform
    x-displayName: Platform
  - name: Energy Tariff
    x-displayName: Energy Tariff
  - name: Asset
    x-displayName: Asset
  - name: Clusters
    x-displayName: Clusters
  - name: Customer
    x-displayName: Customer
  - name: Import Power Limit
    x-displayName: Import Power Limit
  - name: Appliance
    x-displayName: Appliance
  - name: EV Charging Schedule
    x-displayName: EV Charging Schedule
  - name: EV Configuration
    x-displayName: EV Configuration
  - name: EV Profile
    x-displayName: EV Profile
  - name: Battery Control Command
    x-displayName: Battery Control Command
  - name: Capacity Tariff
    x-displayName: Capacity Tariff
  - name: Gateway
    x-displayName: Gateway
  - name: Scan
    x-displayName: Scan
  - name: Job
    x-displayName: Job
  - name: TariffV2
    x-displayName: TariffV2
  - name: TimeOfUse
    x-displayName: TimeOfUse
  - name: GridSignals
    x-displayName: GridSignals
  - name: Power Limit Schedule
    x-displayName: Power Limit Schedule
  - name: EMS
    x-displayName: EMS
  - name: Cluster
    x-displayName: Cluster
  - name: Product Functionality
    x-displayName: Product Functionality
  - name: Product Option
    x-displayName: Product Option
  - name: Devices
    x-displayName: Devices
  - name: Power Sequence
    x-displayName: Power Sequence
  - name: Star
    x-displayName: Star
paths:
  '/accounts/{accountID}/scanconfiguration':
    get:
      summary: Retrieve Scan Configuration
      tags:
        - Scan Configuration
      security:
        - BearerAuth:
            - ScanConfigurationRead
      parameters:
        - &ref_1
          name: accountID
          description: |
            Unique identifier used to access an account.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 17874c1b-d073-4b06-bf01-a1497fbe1142
      responses:
        '200': &ref_221
          description: Scan configuration returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_2
                title: ScanConfiguration
                description: ScanConfiguration determines the behavior of a scan.
                type: object
                properties:
                  accountID:
                    type: string
                    format: uuid
                    example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                    description: The account ID the configuration belongs to.
                    readOnly: true
                  configuration:
                    description: The names of the scanners in this configuration.
                    type: array
                    items:
                      type: string
                  createdAt:
                    type: string
                    format: date-time
                    readOnly: true
                    description: Date when the configuration was created.
                  updatedAt:
                    type: string
                    format: date-time
                    readOnly: true
                    description: Date when the configuration was updated the last time.
        '404': &ref_224
          description: Scan configuration not found.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_6
                readOnly: true
                allOf:
                  - &ref_0
                    title: General Exception
                    description: >-
                      Represents a general error structure returned by our REST
                      API.
                    type: object
                    properties:
                      message:
                        type: string
                        description: Message represents the message reported to the user.
                      details:
                        type: array
                        description: >
                          Details represents detail information for the user to
                          fix this

                          problem
                        items:
                          type: string
                    required:
                      - message
                  - title: ClientError - Not Found
                    description: Not Found indicates that the entity was not found.
                    example:
                      message: Not Found
        '422': &ref_3
          description: Validation failed.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_272
                readOnly: true
                allOf:
                  - *ref_0
                  - title: ClientError - Validation
                    description: >
                      Validation indicates that the request body contains fields
                      which

                      does not pass the validation.
                    type: object
                    required:
                      - message
                      - details
                    example:
                      message: Validation failed
                      details:
                        - email is not valid
        '500': &ref_4
          description: There has been an internal error on our side. We're looking into it.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_273
                readOnly: true
                allOf:
                  - *ref_0
                  - title: ServerSideError - Internal Server Error
                    description: Internal Server Error
                    example:
                      message: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/scanconfiguration",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/accounts/%7BaccountID%7D/scanconfiguration",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a Scan Configuration
      tags:
        - Scan Configuration
      security:
        - BearerAuth:
            - ScanConfigurationWrite
      parameters:
        - *ref_1
      requestBody: &ref_190
        description: Creates a scan configuration.
        required: true
        content:
          application/json:
            schema: &ref_5
              title: ScanConfiguration
              description: ScanConfiguration determines the behavior of a scan.
              type: object
              properties:
                configuration:
                  description: The names of the scanners in this configuration.
                  type: array
                  items:
                    type: string
      responses:
        '201': &ref_222
          description: Scan configuration created.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_2
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"configuration\":[\"string\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"configuration\":[\"string\"]}", ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration\"\n\n\tpayload := strings.NewReader(\"{\\\"configuration\\\":[\\\"string\\\"]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"configuration\":[\"string\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"configuration\":[\"string\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"configuration\":[\"string\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "configuration": [
                "string"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"configuration\":[\"string\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/scanconfiguration",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({configuration: ['string']}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {configuration: ['string']},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "configuration": [
                "string"
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"configuration": @[ @"string" ] };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"configuration\":[\"string\"]}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"configuration\":[\"string\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"configuration":["string"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"configuration":["string"]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"configuration\":[\"string\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/accounts/%7BaccountID%7D/scanconfiguration",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"


            payload = {"configuration": ["string"]}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"configuration\":[\"string\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"configuration":["string"]}'
        - lang: Shell + Httpie
          source: |-
            echo '{"configuration":["string"]}' |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"configuration":["string"]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["configuration": ["string"]] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update a Scan Configuration
      tags:
        - Scan Configuration
      security:
        - BearerAuth:
            - ScanConfigurationWrite
      parameters:
        - *ref_1
      requestBody: &ref_191
        description: Updates a scan configuration.
        required: true
        content:
          application/json:
            schema: *ref_5
      responses:
        '200': &ref_223
          description: Scan configuration updated.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_2
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"configuration\":[\"string\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"configuration\":[\"string\"]}", ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration\"\n\n\tpayload := strings.NewReader(\"{\\\"configuration\\\":[\\\"string\\\"]}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"configuration\":[\"string\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"configuration\":[\"string\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"configuration\":[\"string\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "configuration": [
                "string"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"configuration\":[\"string\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/scanconfiguration",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({configuration: ['string']}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {configuration: ['string']},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "configuration": [
                "string"
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"configuration": @[ @"string" ] };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"configuration\":[\"string\"]}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"configuration\":[\"string\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"configuration":["string"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"configuration":["string"]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"configuration\":[\"string\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/accounts/%7BaccountID%7D/scanconfiguration",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"


            payload = {"configuration": ["string"]}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"configuration\":[\"string\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"configuration":["string"]}'
        - lang: Shell + Httpie
          source: |-
            echo '{"configuration":["string"]}' |  \
              http PATCH https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"configuration":["string"]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["configuration": ["string"]] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete a Scan Configuration
      tags:
        - Scan Configuration
      security:
        - BearerAuth:
            - ScanConfigurationWrite
      parameters:
        - *ref_1
      responses:
        '204':
          description: Scan configuration deleted successfully.
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/scanconfiguration",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/scanconfiguration", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/scanconfiguration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /account:
    get:
      summary: Retrieve the authenticated Account
      description: Get the account that is currently logged in.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountRead
      responses:
        '200': &ref_19
          description: Account returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_10
                title: Account
                description: >
                  An account describes an organizational unit to manage access
                  to systems for one or multiple users.
                type: object
                readOnly: true
                allOf:
                  - &ref_7
                    title: Account
                    description: >
                      An account describes an organizational unit to manage
                      access to systems for one or multiple users.


                      This is the base type for the more concrete usages and not
                      used directly within operations.
                    type: object
                    properties:
                      name:
                        type: string
                        example: John Doe
                        description: >-
                          Name of the account, can be chosen freely but should
                          be kept terse and descriptive.
                        minLength: 1
                        maxLength: 256
                      email:
                        type: string
                        format: email
                        example: john@doe.com
                        description: >-
                          The email field of the account can optionally be
                          chosen e.g. for contact purposes (in order to reach
                          the responsible person for the account).
                        maxLength: 256
                      solution: &ref_274
                        type: string
                        description: >
                          Represents the supported solutions within the account:

                          - HOME if the account contains household-like
                          systems. 

                          - CHARGE if the account is used solely for charging
                          station fleet management.

                          - GENERAL if unsure what the account should contain or
                          if it's a mix of multiple solutions.

                          - SMART_DISTRICT if the account is used solely for
                          smart district management.

                          If not set, the parent account's solution will be
                          assumed.
                        enum:
                          - HOME
                          - CHARGE
                          - GENERAL
                          - SMART_DISTRICT
                          - MICROGRID
                          - HOME_VIRTUAL_METERING
                          - COMMERCIAL
                          - CUSTOM_P2P
                  - properties:
                      id:
                        type: string
                        format: uuid
                        example: 49a4f165-8233-426b-a1a4-e569665a25dd
                        description: Uniquely identifies the account.
                      parentID:
                        type: string
                        format: uuid
                        example: 19a4f165-8233-426b-a1a4-e569665a25dd
                        description: >-
                          Parent of the account for a tree-like account
                          structure. Only the root account does not have a
                          parent ID.
                      createdAt:
                        type: string
                        format: date-time
                        description: Specifies when the account was created.
                      updatedAt:
                        type: string
                        format: date-time
                        description: Specifies when the account was updated.
                      systemsCount:
                        type: integer
                        description: >-
                          SystemCount is the number of systems assigned to this
                          account
                        example: 1
                      kind: &ref_8
                        type: string
                        enum:
                          - b2b
                          - end-user
                        description: >-
                          If b2b, the account is a regular account. If end-user,
                          the account is a customer account which contains just
                          one user.
                      mainAddress: &ref_9
                        title: Address
                        description: Represents a physical address of a customer.
                        allOf:
                          - &ref_24
                            type: object
                            properties:
                              city:
                                description: The city of the location.
                                type: string
                                example: Aachen
                              country:
                                description: The country of the location.
                                type: string
                                example: Germany
                              addressLine1:
                                description: >
                                  First line of the location's address,
                                  typically containing the 

                                  main information such as the street name and
                                  house number.
                                type: string
                                example: Oppenhoffallee 143
                              addressLine2:
                                description: >
                                  Second line of the location's address,
                                  typically containing additional 

                                  information such as apartment numbers, suite
                                  numbers, or other details 

                                  that can help in identifying the exact
                                  location of the address.
                                type: string
                              addressLine3:
                                description: >
                                  Third line of the location's address,
                                  typically containing any other 

                                  details that can help in identifying the exact
                                  location of the address.
                                type: string
                              addressLine4:
                                description: >
                                  Fourth line of the location's address,
                                  typically containing any other 

                                  details that can help in identifying the exact
                                  location of the address.
                                type: string
                              timeZone:
                                description: The TZ Identifier of the location's timezone.
                                type: string
                                example: Europe/Berlin
                                readOnly: true
                          - type: object
                            properties:
                              postalcode:
                                description: The postal code of the location.
                                type: string
                                example: '52062'
                              region:
                                description: The region of the address.
                                type: string
                              telephone:
                                description: The telephone number of the customer.
                                type: string
                      customization:
                        description: Customization can be used to store arbitrary data.
                    required:
                      - id
                      - createdAt
                      - updatedAt
        '403': &ref_11
          description: Forbidden.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_275
                readOnly: true
                allOf:
                  - *ref_0
                  - title: UnauthorizedError - Forbidden Error
                    description: Forbidden Error
                    example:
                      message: Bad credentials
        '404': &ref_12
          description: Account not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/account");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/account");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/account")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/account");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/account',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/account");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL URLWithString:@"https://api.gridx.de/account"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/account" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/account');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/account');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/account", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/account \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/account \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update the authenticated Account
      description: Update the user data of the authenticated account.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountWrite
      requestBody: &ref_20
        description: Updates an account.
        required: true
        content:
          application/json:
            schema: &ref_277
              allOf:
                - &ref_276
                  allOf:
                    - *ref_7
                    - properties:
                        kind: *ref_8
                        customization:
                          description: Customization can be used to store arbitrary data.
                        mainAddress: *ref_9
                - additionalProperties: false
      responses:
        '200': &ref_21
          description: Account updated.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_10
        '403': *ref_11
        '404': *ref_12
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/account");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/account");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"solution\\\":\\\"HOME\\\",\\\"kind\\\":\\\"b2b\\\",\\\"customization\\\":null,\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/account")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "kind": "b2b",
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/account");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'John Doe',
              email: 'john@doe.com',
              solution: 'HOME',
              kind: 'b2b',
              customization: null,
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/account',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'John Doe',
                email: 'john@doe.com',
                solution: 'HOME',
                kind: 'b2b',
                customization: null,
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("PATCH", "https://api.gridx.de/account");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "kind": "b2b",
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"solution": @"HOME",
                                          @"kind": @"b2b",
                                          @"customization": ,
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL URLWithString:@"https://api.gridx.de/account"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/account" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            $request->setRequestUrl('https://api.gridx.de/account');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/account", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account"


            payload = {
                "name": "John Doe",
                "email": "john@doe.com",
                "solution": "HOME",
                "kind": "b2b",
                "customization": None,
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/account")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/account \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
            |  \
              http PATCH https://api.gridx.de/account \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}' \
              --output-document \
              - https://api.gridx.de/account
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "kind": "b2b",
              "customization": ,
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/account/market-prices/{platform}':
    get:
      summary: Retrieve energy market prices for the authenticated account
      deprecated: true
      description: >
        List energy market prices for the given interval. Prices are fetched
        from an external energy market

        platform.

        For the given interval, the hourly prices of the second to last day and
        for the last day are returned in a 60M resolution.

        For all the other days in the interval, the average daily price is
        returned.

        For example, in order to get hourly prices for the current day and the
        day before, set the **end** of the interval to the current day.


        **Deprecated** - Use `/systems/{systemID}/tariff/prices` instead.
      tags:
        - Market Prices
      security:
        - BearerAuth:
            - MarketPricesRead
      parameters:
        - in: path
          name: platform
          required: true
          schema:
            type: string
          example: entso-e
          description: >
            Specifies an external platform to receive the energy market prices
            from (currently only one supported).

            - "entso-e": Fetch prices from ENTSO-E Transparency Platform.
        - in: query
          name: domain
          required: false
          schema:
            type: string
          description: >
            Specifies an Area-Code which is currently in use of the European
            markets.


            If set, the default bidding zone set in the account is ignored.

            More details about the bidding zones, can be found
            [here](https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_areas).
          example: 10Y1001A1001A82H
        - in: query
          name: interval
          description: Requested time interval for fetching prices in UTC.
          required: true
          example: '2020-09-21T00:00:00Z/2022-09-23T00:00:00Z'
          schema:
            type: string
            format: datetime
        - in: query
          name: timezone
          description: >-
            Timezone in which all related times should be loaded before being
            returned.
          required: true
          schema:
            type: string
          example: Europe/Berlin
      responses:
        '200': &ref_247
          description: Energy market prices returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_271
                title: Energy Market Data
                type: object
                properties:
                  priceUnit:
                    type: string
                    description: Currency unit which the prices are (ct/kWh).
                    example: EUR/MWh
                  averagePriceDay:
                    type: number
                    format: double
                    description: Average price of the second to last day in EUR/MWh.
                    example: 33.6
                  periodStart:
                    type: string
                    description: >-
                      Starting date at which the prices are fetched in RFC3339
                      format.
                    example: '2020-09-24T00:00:00Z'
                  periodEnd:
                    type: string
                    description: >-
                      Ending date at which the prices are fetched in RFC3339
                      format.
                    example: '2022-09-27T00:00:00Z'
                  totalPrices:
                    description: >
                      Contains an array of arrays in the format [time, price].


                      The fetched prices are in the following order:

                      * Average prices for each day between [PeriodStart,
                      SecondToLastDay].

                      * Prices for the second to last day from the given
                      interval with resolution 1h.

                      * Price for the last day of the given interval with
                      resolution 1h.
                    type: array
                    items:
                      type: array
                      items:
                        oneOf:
                          - type: string
                          - type: number
                    example:
                      - - '2022-09-25T22:00:00Z'
                        - 2.5
                      - - '2022-09-25T23:00:00Z'
                        - 1
                      - - '2022-09-26T00:00:00Z'
                        - 2
                      - - '2022-09-26T01:00:00Z'
                        - 3
                      - - '2022-09-26T02:00:00Z'
                        - 4
                      - - '2022-09-26T23:00:00Z'
                        - 1
                      - - '2022-09-27T00:00:00Z'
                        - 2
                      - - '2022-09-27T01:00:00Z'
                        - 3
                      - - '2022-09-27T02:00:00Z'
                        - 4
        '400': &ref_15
          description: Malformed request.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_278
                readOnly: true
                allOf:
                  - *ref_0
                  - title: ClientError - Bad Request
                    description: >
                      Bad Request indicates that the request body is not a valid
                      JSON or

                      it contains a invalid json type.
                    example:
                      message: Problems parsing JSON
        '403': *ref_11
        '404': *ref_12
        '500': *ref_4
        '502': &ref_147
          description: There has been an error from an upstream server.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_279
                readOnly: true
                allOf:
                  - *ref_0
                  - title: BadGatewayError
                    description: >-
                      Indicates that there has been an error from an upstream
                      server.
                    example:
                      message: Bad Gateway
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/account/market-prices/%7Bplatform%7D',
              qs: {
                domain: 'SOME_STRING_VALUE',
                interval: 'SOME_STRING_VALUE',
                timezone: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/account/market-prices/%7Bplatform%7D");


            req.query({
              "domain": "SOME_STRING_VALUE",
              "interval": "SOME_STRING_VALUE",
              "timezone": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/market-prices/%7Bplatform%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'domain' => 'SOME_STRING_VALUE',
              'interval' => 'SOME_STRING_VALUE',
              'timezone' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/market-prices/%7Bplatform%7D');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'domain' => 'SOME_STRING_VALUE',
              'interval' => 'SOME_STRING_VALUE',
              'timezone' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account/market-prices/%7Bplatform%7D"


            querystring =
            {"domain":"SOME_STRING_VALUE","interval":"SOME_STRING_VALUE","timezone":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/market-prices/%7Bplatform%7D?domain=SOME_STRING_VALUE&interval=SOME_STRING_VALUE&timezone=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /account/tokens:
    get:
      summary: Get API tokens
      description: >-
        Retrieve all the organizational API tokens for the currently
        authenticated account.
      tags:
        - Token
      security:
        - BearerAuth:
            - GetAPITokens
      parameters:
        - &ref_18
          name: page
          description: >
            Requested page, to be used in combination with the `per_page`
            parameter.
          in: query
          schema:
            type: integer
            format: int32
            default: 1
            minimum: 1
          example: 5
        - &ref_17
          name: per_page
          description: |
            Requested number of items per page.
          in: query
          schema:
            type: integer
            format: int32
            default: 20
            minimum: 20
            maximum: 100
          example: 50
        - &ref_67
          name: sort
          description: Sort results based on a key.
          in: query
          schema:
            type: string
          example: created_at
      responses:
        '200':
          description: All the organizational API tokens of the current account.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_14
                  title: OrganizationalAPIToken
                  allOf:
                    - &ref_182
                      allOf:
                        - &ref_13
                          title: APIToken
                          description: >
                            API Tokens can be used as an alternative to Bearer
                            Authentication for making requests.

                            They are instead used as an in-header API Key.
                          type: object
                          properties:
                            description:
                              type: string
                              example: My api token
                            expiresAt:
                              type: string
                              format: date-time
                              description: >
                                Time at which the token expires in UTC using the
                                RFC3339 format.


                                **WARNING** - if `expiresAt` is not set, the
                                token will never expire. We strongly recommend

                                that you set an expiration date to help keep
                                your account and information secure.
                              example: '2021-11-10T23:00:00Z'
                        - properties:
                            id:
                              type: string
                              format: uuid
                              example: fc8ee525-669f-45de-9bca-bf5a51829de3
                              readOnly: true
                            createdAt:
                              type: string
                              description: >-
                                Time at which the token was created in UTC using
                                the RFC3339 format.
                              example: '2021-10-10T23:20:50Z'
                              format: date-time
                              readOnly: true
                          required:
                            - id
                            - createdAt
                    - properties:
                        user: &ref_29
                          type: object
                          allOf:
                            - &ref_34
                              title: User
                              description: >
                                Represents a user of the Xenon platform.


                                This is the base type for the more concrete
                                usages and not used directly within operations.
                              type: object
                              required:
                                - id
                                - email
                                - createdAt
                                - updatedAt
                              properties:
                                id:
                                  description: Unique identifier of the user.
                                  type: string
                                  format: uuid
                                  example: 43a4f165-8233-426b-a1a4-e569665a25dd
                                  readOnly: true
                                accountID:
                                  description: >-
                                    Unique identifier of the account that the
                                    user belongs to.
                                  type: string
                                  format: uuid
                                  example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                                  readOnly: true
                                newPassword:
                                  description: Used to set a new password for the user.
                                  type: string
                                  writeOnly: true
                                loginsCount:
                                  description: Number of user logins.
                                  type: integer
                                  readOnly: true
                                mfaEnabled:
                                  description: >-
                                    Indicates whether MFA (Multi-Factor
                                    Authentication) is enabled.
                                  type: boolean
                                  readOnly: true
                                mfaReset:
                                  description: >-
                                    Can be set to true if MFA (Multi-Factor
                                    Authentication) needs to to be reset. This
                                    will remove the MFA.
                                  type: boolean
                                  writeOnly: true
                                createdAt:
                                  description: >-
                                    Time at which the user was created in UTC
                                    using the RFC3339 format.
                                  type: string
                                  format: date-time
                                  example: '2009-11-10T23:20:50Z'
                                  readOnly: true
                                updatedAt:
                                  description: >-
                                    Time at which the user was last updated in
                                    UTC using the RFC3339 format.
                                  type: string
                                  format: date-time
                                  example: '2009-11-10T23:20:50Z'
                                  readOnly: true
                                fullName:
                                  description: >-
                                    Full name of the user typically consisting
                                    of first name and last name.
                                  type: string
                                  example: John Doe
                                email:
                                  description: >-
                                    The email address of the user that is used
                                    for login.
                                  type: string
                                  format: email
                                  example: john@doe.com
                                groups:
                                  description: >-
                                    Policy groups attached to this user which
                                    determine the effective permissions through
                                    policies.
                                  type: array
                                  items: &ref_32
                                    title: Policy Group
                                    type: object
                                    allOf:
                                      - &ref_33
                                        title: Policy Group
                                        description: >
                                          A policy group describes the permissions
                                          of a group.


                                          This is the base type for the more
                                          concrete usages and not used directly
                                          within operations.
                                        type: object
                                        properties:
                                          name:
                                            type: string
                                            description: Name of the policy group.
                                            example: group name
                                          description:
                                            type: string
                                            description: >-
                                              Description of the group, omitted if
                                              empty
                                            example: Group provides read-access to accounts
                                      - properties:
                                          id:
                                            type: string
                                            format: uuid
                                            description: Unique identifier of the policy group.
                                            example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                                            readOnly: true
                                          accountID:
                                            type: string
                                            format: uuid
                                            description: >-
                                              Unique identifier of the creator
                                              account.
                                            example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                                            readOnly: true
                                          createdAt:
                                            description: >-
                                              Time at which the policy group was
                                              created in UTC (RFC 3339 format).
                                            type: string
                                            format: date-time
                                            example: '2019-11-06T15:33:00Z'
                                            readOnly: true
                                          updatedAt:
                                            description: >-
                                              Time at which the policy group was last
                                              updated in UTC (RFC 3339 format).
                                            type: string
                                            format: date-time
                                            example: '2019-11-08T23:20:50Z'
                                            readOnly: true
                                          userCount:
                                            type: integer
                                            description: Amount of users that are in this group.
                                            example: 10
                                            readOnly: true
                                        required:
                                          - id
                                          - name
                                          - accountID
                                          - createdAt
                                          - updatedAt
                                mainAddress: *ref_9
                                language: &ref_280
                                  title: Language
                                  description: The language information of the user.
                                  type: object
                                  required:
                                    - tag
                                    - name
                                    - nameNative
                                  properties:
                                    tag:
                                      type: string
                                      description: >
                                        Tag is the IETF language tag's primary
                                        identifier for this language.


                                        See
                                        [here](https://tools.ietf.org/rfc/bcp/bcp47.txt)
                                        and the example below for more
                                        information.
                                      example: de_DE
                                    name:
                                      type: string
                                      description: The name of the language in English.
                                      example: German
                                      readOnly: true
                                    nameNative:
                                      type: string
                                      description: >-
                                        The name of the language in the language
                                        itself.
                                      example: Deutsch
                                      readOnly: true
                            - required:
                                - auth
                        userID:
                          type: string
                          format: uuid
                          description: >-
                            Reference to the user to which the API token
                            belongs. Can be used to set the token's "scope" by
                            assigning groups to the user.
                          example: 123ee525-669f-45de-9bca-bf5a51829de3
                      required:
                        - user
                        - userID
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found.
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/account/tokens',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                sort: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/account/tokens");

            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "sort": "SOME_STRING_VALUE"
            });

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/account/tokens');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/account/tokens');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account/tokens"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","sort":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create an organizational API token
      tags:
        - Token
      security:
        - BearerAuth:
            - APITokenWrite
      requestBody:
        required: true
        content:
          application/json:
            schema: &ref_283
              allOf:
                - &ref_282
                  title: OrganizationalAPITokenCreation
                  allOf:
                    - &ref_281
                      allOf:
                        - *ref_13
                    - type: object
                      properties:
                        email:
                          type: string
                          description: >-
                            Used to specify the email address associated with
                            the user responsible for the organizational token
                            upon its creation (account email is used by
                            default).
                          example: john@doe.com
                        groups:
                          type: array
                          description: >-
                            Used to specify the permissions assigned to the
                            organizational token.
                          items:
                            type: string
                            description: Unique identifier of the policy group.
                            example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                - additionalProperties: false
      responses:
        '201':
          description: Organizational API token created.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_16
                title: OrganizationalAPITokenWithSecret
                allOf:
                  - *ref_14
                  - properties:
                      token:
                        type: string
                        description: >
                          This token can be used for authenticating further
                          requests as an alternative to Bearer Authentication.


                          Example: Set the header field `Authorization` to
                          `Token gxo_SUDJmIoABC1337JiAuKBZuauC0ff331HNPR0`. 

                          To set the permissions of it, you can assign a group
                          to the newly created associated organizational user,
                          see `userID`.


                          **ATTENTION**: Please keep the token secret and treat
                          it like a password! The token is only available
                          immediately after creation and can not be retrieved
                          again afterwards.
                        example: gxo_SUDJmIoABC1337JiAuKBZuauC0ff331HNPR0
                    required:
                      - token
        '400': *ref_15
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tokens");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/account/tokens");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tokens\"\n\n\tpayload := strings.NewReader(\"{\\\"description\\\":\\\"My api token\\\",\\\"expiresAt\\\":\\\"2021-11-10T23:00:00Z\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"groups\\\":[\\\"97874c1b-d073-4b06-bf01-a1497fbe1146\\\"]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tokens")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/account/tokens")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z",
              "email": "john@doe.com",
              "groups": [
                "97874c1b-d073-4b06-bf01-a1497fbe1146"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/account/tokens");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tokens",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              description: 'My api token',
              expiresAt: '2021-11-10T23:00:00Z',
              email: 'john@doe.com',
              groups: ['97874c1b-d073-4b06-bf01-a1497fbe1146']
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/account/tokens',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                description: 'My api token',
                expiresAt: '2021-11-10T23:00:00Z',
                email: 'john@doe.com',
                groups: ['97874c1b-d073-4b06-bf01-a1497fbe1146']
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/account/tokens");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z",
              "email": "john@doe.com",
              "groups": [
                "97874c1b-d073-4b06-bf01-a1497fbe1146"
              ]
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"description": @"My api token",
                                          @"expiresAt": @"2021-11-10T23:00:00Z",
                                          @"email": @"john@doe.com",
                                          @"groups": @[ @"97874c1b-d073-4b06-bf01-a1497fbe1146" ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tokens"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/account/tokens" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tokens",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tokens');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z","email":"john@doe.com","groups":["97874c1b-d073-4b06-bf01-a1497fbe1146"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z","email":"john@doe.com","groups":["97874c1b-d073-4b06-bf01-a1497fbe1146"]}');


            $request->setRequestUrl('https://api.gridx.de/account/tokens');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/account/tokens", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account/tokens"


            payload = {
                "description": "My api token",
                "expiresAt": "2021-11-10T23:00:00Z",
                "email": "john@doe.com",
                "groups": ["97874c1b-d073-4b06-bf01-a1497fbe1146"]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/account/tokens")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"email\":\"john@doe.com\",\"groups\":[\"97874c1b-d073-4b06-bf01-a1497fbe1146\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/account/tokens \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z","email":"john@doe.com","groups":["97874c1b-d073-4b06-bf01-a1497fbe1146"]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z","email":"john@doe.com","groups":["97874c1b-d073-4b06-bf01-a1497fbe1146"]}'
            |  \
              http POST https://api.gridx.de/account/tokens \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z","email":"john@doe.com","groups":["97874c1b-d073-4b06-bf01-a1497fbe1146"]}' \
              --output-document \
              - https://api.gridx.de/account/tokens
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z",
              "email": "john@doe.com",
              "groups": ["97874c1b-d073-4b06-bf01-a1497fbe1146"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tokens")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/account/tokens/{tokenID}':
    get:
      summary: Get an organizational API token
      description: >-
        Retrieve the given organizational API token for the currently
        authenticated account.
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token.
          required: true
          schema:
            type: string
            format: uuid
          example: 218e8795-2442-42d7-901b-1588373e527f
      tags:
        - Token
      security:
        - BearerAuth:
            - GetAPIToken
      responses:
        '200':
          description: API token
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_14
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tokens/%7BtokenID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tokens/%7BtokenID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tokens/%7BtokenID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/account/tokens/%7BtokenID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tokens/%7BtokenID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/account/tokens/%7BtokenID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tokens/%7BtokenID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tokens/%7BtokenID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/account/tokens/%7BtokenID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account/tokens/%7BtokenID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account/tokens/%7BtokenID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/account/tokens/%7BtokenID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/account/tokens/%7BtokenID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account/tokens/%7BtokenID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tokens/%7BtokenID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Partially update an organizational API token
      description: >-
        Partially update the organizational API token of the currently
        authenticated account.
      tags:
        - Token
      security:
        - BearerAuth:
            - UpdateAPIToken
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token to be updated.
          required: true
          schema:
            type: string
            format: uuid
          example: 218e8795-2442-42d7-901b-1588373e527f
      requestBody:
        description: The new API token
        required: true
        content:
          application/json:
            schema: &ref_284
              allOf:
                - *ref_14
                - additionalProperties: false
      responses:
        '200':
          description: >-
            The full representation of the token after the partial update on
            success.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_14
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tokens/%7BtokenID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tokens/%7BtokenID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"description\\\":\\\"My api token\\\",\\\"expiresAt\\\":\\\"2021-11-10T23:00:00Z\\\",\\\"user\\\":{\\\"newPassword\\\":\\\"string\\\",\\\"mfaReset\\\":true,\\\"fullName\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"groups\\\":[{\\\"name\\\":\\\"group name\\\",\\\"description\\\":\\\"Group provides read-access to accounts\\\"}],\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"},\\\"language\\\":{\\\"tag\\\":\\\"de_DE\\\"}},\\\"userID\\\":\\\"123ee525-669f-45de-9bca-bf5a51829de3\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tokens/%7BtokenID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/account/tokens/%7BtokenID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z",
              "user": {
                "newPassword": "string",
                "mfaReset": true,
                "fullName": "John Doe",
                "email": "john@doe.com",
                "groups": [
                  {
                    "name": "group name",
                    "description": "Group provides read-access to accounts"
                  }
                ],
                "mainAddress": {
                  "city": "Aachen",
                  "country": "Germany",
                  "addressLine1": "Oppenhoffallee 143",
                  "addressLine2": "string",
                  "addressLine3": "string",
                  "addressLine4": "string",
                  "postalcode": "52062",
                  "region": "string",
                  "telephone": "string"
                },
                "language": {
                  "tag": "de_DE"
                }
              },
              "userID": "123ee525-669f-45de-9bca-bf5a51829de3"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tokens/%7BtokenID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              description: 'My api token',
              expiresAt: '2021-11-10T23:00:00Z',
              user: {
                newPassword: 'string',
                mfaReset: true,
                fullName: 'John Doe',
                email: 'john@doe.com',
                groups: [{name: 'group name', description: 'Group provides read-access to accounts'}],
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                },
                language: {tag: 'de_DE'}
              },
              userID: '123ee525-669f-45de-9bca-bf5a51829de3'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/account/tokens/%7BtokenID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                description: 'My api token',
                expiresAt: '2021-11-10T23:00:00Z',
                user: {
                  newPassword: 'string',
                  mfaReset: true,
                  fullName: 'John Doe',
                  email: 'john@doe.com',
                  groups: [{name: 'group name', description: 'Group provides read-access to accounts'}],
                  mainAddress: {
                    city: 'Aachen',
                    country: 'Germany',
                    addressLine1: 'Oppenhoffallee 143',
                    addressLine2: 'string',
                    addressLine3: 'string',
                    addressLine4: 'string',
                    postalcode: '52062',
                    region: 'string',
                    telephone: 'string'
                  },
                  language: {tag: 'de_DE'}
                },
                userID: '123ee525-669f-45de-9bca-bf5a51829de3'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z",
              "user": {
                "newPassword": "string",
                "mfaReset": true,
                "fullName": "John Doe",
                "email": "john@doe.com",
                "groups": [
                  {
                    "name": "group name",
                    "description": "Group provides read-access to accounts"
                  }
                ],
                "mainAddress": {
                  "city": "Aachen",
                  "country": "Germany",
                  "addressLine1": "Oppenhoffallee 143",
                  "addressLine2": "string",
                  "addressLine3": "string",
                  "addressLine4": "string",
                  "postalcode": "52062",
                  "region": "string",
                  "telephone": "string"
                },
                "language": {
                  "tag": "de_DE"
                }
              },
              "userID": "123ee525-669f-45de-9bca-bf5a51829de3"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"description": @"My api token",
                                          @"expiresAt": @"2021-11-10T23:00:00Z",
                                          @"user": @{ @"newPassword": @"string", @"mfaReset": @YES, @"fullName": @"John Doe", @"email": @"john@doe.com", @"groups": @[ @{ @"name": @"group name", @"description": @"Group provides read-access to accounts" } ], @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" }, @"language": @{ @"tag": @"de_DE" } },
                                          @"userID": @"123ee525-669f-45de-9bca-bf5a51829de3" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tokens/%7BtokenID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tokens/%7BtokenID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z","user":{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}},"userID":"123ee525-669f-45de-9bca-bf5a51829de3"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z","user":{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}},"userID":"123ee525-669f-45de-9bca-bf5a51829de3"}');


            $request->setRequestUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/account/tokens/%7BtokenID%7D", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account/tokens/%7BtokenID%7D"


            payload = {
                "description": "My api token",
                "expiresAt": "2021-11-10T23:00:00Z",
                "user": {
                    "newPassword": "string",
                    "mfaReset": True,
                    "fullName": "John Doe",
                    "email": "john@doe.com",
                    "groups": [
                        {
                            "name": "group name",
                            "description": "Group provides read-access to accounts"
                        }
                    ],
                    "mainAddress": {
                        "city": "Aachen",
                        "country": "Germany",
                        "addressLine1": "Oppenhoffallee 143",
                        "addressLine2": "string",
                        "addressLine3": "string",
                        "addressLine4": "string",
                        "postalcode": "52062",
                        "region": "string",
                        "telephone": "string"
                    },
                    "language": {"tag": "de_DE"}
                },
                "userID": "123ee525-669f-45de-9bca-bf5a51829de3"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/account/tokens/%7BtokenID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\",\"user\":{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}},\"userID\":\"123ee525-669f-45de-9bca-bf5a51829de3\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/account/tokens/%7BtokenID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z","user":{"newPassword":"string","mfaReset":true,"fullName":"John Doe","email":"john@doe.com","groups":[{"name":"group name","description":"Group provides read-access to accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}},"userID":"123ee525-669f-45de-9bca-bf5a51829de3"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z","user":{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}},"userID":"123ee525-669f-45de-9bca-bf5a51829de3"}'
            |  \
              http PATCH https://api.gridx.de/account/tokens/%7BtokenID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z","user":{"newPassword":"string","mfaReset":true,"fullName":"John Doe","email":"john@doe.com","groups":[{"name":"group name","description":"Group provides read-access to accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}},"userID":"123ee525-669f-45de-9bca-bf5a51829de3"}' \
              --output-document \
              - https://api.gridx.de/account/tokens/%7BtokenID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z",
              "user": [
                "newPassword": "string",
                "mfaReset": true,
                "fullName": "John Doe",
                "email": "john@doe.com",
                "groups": [
                  [
                    "name": "group name",
                    "description": "Group provides read-access to accounts"
                  ]
                ],
                "mainAddress": [
                  "city": "Aachen",
                  "country": "Germany",
                  "addressLine1": "Oppenhoffallee 143",
                  "addressLine2": "string",
                  "addressLine3": "string",
                  "addressLine4": "string",
                  "postalcode": "52062",
                  "region": "string",
                  "telephone": "string"
                ],
                "language": ["tag": "de_DE"]
              ],
              "userID": "123ee525-669f-45de-9bca-bf5a51829de3"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tokens/%7BtokenID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete organizational API token
      description: >-
        Remove a given organizational API token from the currently authenticated
        account.
      tags:
        - Token
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token.
          required: true
          schema:
            type: string
            format: uuid
          example: 218e8795-2442-42d7-901b-1588373e527f
      security:
        - BearerAuth:
            - DeleteAPIToken
      responses:
        '204':
          description: API token deleted successfully
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tokens/%7BtokenID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tokens/%7BtokenID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tokens/%7BtokenID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/account/tokens/%7BtokenID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tokens/%7BtokenID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/account/tokens/%7BtokenID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tokens/%7BtokenID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tokens/%7BtokenID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tokens/%7BtokenID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE", "/account/tokens/%7BtokenID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account/tokens/%7BtokenID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account/tokens/%7BtokenID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/account/tokens/%7BtokenID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/account/tokens/%7BtokenID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account/tokens/%7BtokenID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tokens/%7BtokenID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/account/tokens/{tokenID}/rotate':
    post:
      summary: Rotate an existing organizational API token
      description: >
        Rotates a non-expired organizational API token for the given token ID.

        The current expiry date is extended by the value specified in the
        `lifetime` parameter (if specified).

        The token's permissions remain unchanged.
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token.
          required: true
          schema:
            type: string
            format: uuid
          example: 218e8795-2442-42d7-901b-1588373e527f
        - name: lifetime
          description: Life time to add to the current expiry date.
          required: false
          in: query
          example: 1D
          schema:
            type: string
            enum:
              - 1D
              - 1W
              - 1M
              - 1Y
      tags:
        - Token
      security:
        - BearerAuth:
            - RotateAPIToken
      responses:
        '201':
          description: New API token
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_16
        '403': *ref_11
        '404':
          description: API token not found
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE");

            var request = new RestRequest(Method.POST);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE")
              .post(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate',
              qs: {lifetime: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate");


            req.query({
              "lifetime": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate');

            $request->setMethod(HTTP_METH_POST);


            $request->setQueryData([
              'lifetime' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate');

            $request->setRequestMethod('POST');

            $request->setQuery(new http\QueryString([
              'lifetime' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("POST",
            "/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate"


            querystring = {"lifetime":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("POST", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url 'https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http POST
            'https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tokens/%7BtokenID%7D/rotate?lifetime=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /accounts:
    get:
      summary: List all Accounts
      description: List accounts that are accessible to the authenticated user.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountsRead
      parameters:
        - &ref_22
          name: kind
          description: Account kind.
          in: query
          example: b2b
          schema:
            type: string
            enum:
              - b2b
              - end-user
        - *ref_17
        - *ref_18
      responses:
        '200': &ref_23
          description: Accounts returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_10
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts',
              qs: {
                kind: 'SOME_STRING_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                page: 'SOME_INTEGER_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/accounts");

            req.query({
              "kind": "SOME_STRING_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "page": "SOME_INTEGER_VALUE"
            });

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/accounts');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'kind' => 'SOME_STRING_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/accounts');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'kind' => 'SOME_STRING_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts"


            querystring =
            {"kind":"SOME_STRING_VALUE","per_page":"SOME_INTEGER_VALUE","page":"SOME_INTEGER_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create an Account
      description: >-
        Create a new account for the authenticated user. The child account will
        inherit the authenticated accounts information.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountsWrite
      requestBody: &ref_200
        description: Creates an account.
        required: true
        content:
          application/json:
            schema: &ref_287
              allOf:
                - &ref_286
                  allOf:
                    - *ref_7
                    - properties:
                        parentID:
                          type: string
                          format: uuid
                          example: 19a4f165-8233-426b-a1a4-e569665a25dd
                          description: >-
                            Parent of the account for a tree-like account
                            structure. If not set, defaults to the authenticated
                            account.
                        kind: &ref_285
                          type: string
                          enum:
                            - b2b
                            - end-user
                          default: b2b
                          description: >-
                            If b2b, the account is a regular account. If
                            end-user, the account is a customer account which
                            contains just one user.
                        groups:
                          type: array
                          description: >-
                            the IDs of the policy groups that the account should
                            be assigned to.
                          example:
                            - 532365fc-5a0e-4323-bc66-4ce9f1308480
                          items:
                            type: string
                            format: uuid
                        customization:
                          description: Customization can be used to store arbitrary data.
                        mainAddress: *ref_9
                - additionalProperties: false
      responses:
        '201': &ref_225
          description: Account created.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_10
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/accounts");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/accounts");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"solution\\\":\\\"HOME\\\",\\\"parentID\\\":\\\"19a4f165-8233-426b-a1a4-e569665a25dd\\\",\\\"kind\\\":\\\"b2b\\\",\\\"groups\\\":[\\\"532365fc-5a0e-4323-bc66-4ce9f1308480\\\"],\\\"customization\\\":null,\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
              "kind": "b2b",
              "groups": [
                "532365fc-5a0e-4323-bc66-4ce9f1308480"
              ],
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/accounts");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'John Doe',
              email: 'john@doe.com',
              solution: 'HOME',
              parentID: '19a4f165-8233-426b-a1a4-e569665a25dd',
              kind: 'b2b',
              groups: ['532365fc-5a0e-4323-bc66-4ce9f1308480'],
              customization: null,
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'John Doe',
                email: 'john@doe.com',
                solution: 'HOME',
                parentID: '19a4f165-8233-426b-a1a4-e569665a25dd',
                kind: 'b2b',
                groups: ['532365fc-5a0e-4323-bc66-4ce9f1308480'],
                customization: null,
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/accounts");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
              "kind": "b2b",
              "groups": [
                "532365fc-5a0e-4323-bc66-4ce9f1308480"
              ],
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"solution": @"HOME",
                                          @"parentID": @"19a4f165-8233-426b-a1a4-e569665a25dd",
                                          @"kind": @"b2b",
                                          @"groups": @[ @"532365fc-5a0e-4323-bc66-4ce9f1308480" ],
                                          @"customization": ,
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/accounts" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","kind":"b2b","groups":["532365fc-5a0e-4323-bc66-4ce9f1308480"],"customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","kind":"b2b","groups":["532365fc-5a0e-4323-bc66-4ce9f1308480"],"customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            $request->setRequestUrl('https://api.gridx.de/accounts');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/accounts", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts"


            payload = {
                "name": "John Doe",
                "email": "john@doe.com",
                "solution": "HOME",
                "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
                "kind": "b2b",
                "groups": ["532365fc-5a0e-4323-bc66-4ce9f1308480"],
                "customization": None,
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/accounts")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"kind\":\"b2b\",\"groups\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"],\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","kind":"b2b","groups":["532365fc-5a0e-4323-bc66-4ce9f1308480"],"customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","kind":"b2b","groups":["532365fc-5a0e-4323-bc66-4ce9f1308480"],"customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
            |  \
              http POST https://api.gridx.de/accounts \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","kind":"b2b","groups":["532365fc-5a0e-4323-bc66-4ce9f1308480"],"customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}' \
              --output-document \
              - https://api.gridx.de/accounts
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
              "kind": "b2b",
              "groups": ["532365fc-5a0e-4323-bc66-4ce9f1308480"],
              "customization": ,
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}':
    get:
      summary: Retrieve an Account
      description: Get an Account by its ID. Make sure you have the necessary permissions.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountsRead
      parameters:
        - *ref_1
      responses:
        '200': *ref_19
        '403': *ref_11
        '404': *ref_12
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/accounts/%7BaccountID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/accounts/%7BaccountID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/accounts/%7BaccountID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/accounts/%7BaccountID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update an Account
      description: >-
        Update an Account's information. Make sure you have the necessary
        permissions.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountsWrite
      parameters:
        - *ref_1
      requestBody: *ref_20
      responses:
        '200': *ref_21
        '403': *ref_11
        '404': *ref_12
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"solution\\\":\\\"HOME\\\",\\\"kind\\\":\\\"b2b\\\",\\\"customization\\\":null,\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/accounts/%7BaccountID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "kind": "b2b",
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/accounts/%7BaccountID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'John Doe',
              email: 'john@doe.com',
              solution: 'HOME',
              kind: 'b2b',
              customization: null,
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'John Doe',
                email: 'john@doe.com',
                solution: 'HOME',
                kind: 'b2b',
                customization: null,
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "kind": "b2b",
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"solution": @"HOME",
                                          @"kind": @"b2b",
                                          @"customization": ,
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/accounts/%7BaccountID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D"


            payload = {
                "name": "John Doe",
                "email": "john@doe.com",
                "solution": "HOME",
                "kind": "b2b",
                "customization": None,
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"kind\":\"b2b\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/accounts/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
            |  \
              http PATCH https://api.gridx.de/accounts/%7BaccountID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","kind":"b2b","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "kind": "b2b",
              "customization": ,
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete an Account
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountsWrite
      parameters:
        - *ref_1
      responses:
        '204':
          description: Account deleted successfully.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE", "https://api.gridx.de/accounts/%7BaccountID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("DELETE", "/accounts/%7BaccountID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/accounts/%7BaccountID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/accounts/%7BaccountID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/parent':
    patch:
      summary: Move account to different parent.
      description: >
        Moves a b2b account (and all its resources) into a target b2b account
        that is accessible to the authenticated user.  

        A b2b account is an account with `kind="b2b"`
      tags:
        - Account
      security:
        - BearerAuth:
            - MoveAccountsWrite
      parameters:
        - *ref_1
      requestBody: &ref_201
        description: Move an account into the target account with the provided targetID.
        required: true
        content:
          application/json:
            schema: &ref_289
              allOf:
                - &ref_288
                  title: Move Account
                  type: object
                  required:
                    - targetID
                  properties:
                    targetID:
                      description: >-
                        AccountID of the target account that the account should
                        be moved into.
                      type: string
                      format: uuid
                      example: 49a4f165-8233-426b-a1a4-e569665a25dd
                - additionalProperties: false
      responses:
        '200': &ref_237
          description: Moved account.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_10
        '400': *ref_3
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/parent");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/parent");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/parent\"\n\n\tpayload := strings.NewReader(\"{\\\"targetID\\\":\\\"49a4f165-8233-426b-a1a4-e569665a25dd\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/parent")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/accounts/%7BaccountID%7D/parent")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/parent",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "targetID": "49a4f165-8233-426b-a1a4-e569665a25dd"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/parent");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/parent",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/parent",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({targetID:
            '49a4f165-8233-426b-a1a4-e569665a25dd'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/parent',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {targetID: '49a4f165-8233-426b-a1a4-e569665a25dd'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/parent");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "targetID": "49a4f165-8233-426b-a1a4-e569665a25dd"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"targetID":
            @"49a4f165-8233-426b-a1a4-e569665a25dd" };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/parent"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/parent" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/parent",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/parent');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"targetID":"49a4f165-8233-426b-a1a4-e569665a25dd"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"targetID":"49a4f165-8233-426b-a1a4-e569665a25dd"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/parent');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/accounts/%7BaccountID%7D/parent", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/parent"


            payload = {"targetID": "49a4f165-8233-426b-a1a4-e569665a25dd"}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/parent")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"targetID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/parent \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"targetID":"49a4f165-8233-426b-a1a4-e569665a25dd"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"targetID":"49a4f165-8233-426b-a1a4-e569665a25dd"}' |  \
              http PATCH https://api.gridx.de/accounts/%7BaccountID%7D/parent \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"targetID":"49a4f165-8233-426b-a1a4-e569665a25dd"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/parent
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["targetID":
            "49a4f165-8233-426b-a1a4-e569665a25dd"] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/parent")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/accounts':
    get:
      summary: List all nested Accounts
      description: >-
        List all child accounts of the given account that are accessible to the
        authenticated user.
      tags:
        - Account
      security:
        - BearerAuth:
            - NestedAccountsRead
      parameters:
        - *ref_1
        - *ref_22
        - *ref_17
        - *ref_18
      responses:
        '200': *ref_23
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/accounts',
              qs: {
                kind: 'SOME_STRING_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                page: 'SOME_INTEGER_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/accounts");


            req.query({
              "kind": "SOME_STRING_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "page": "SOME_INTEGER_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/accounts');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'kind' => 'SOME_STRING_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/accounts');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'kind' => 'SOME_STRING_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/accounts"


            querystring =
            {"kind":"SOME_STRING_VALUE","per_page":"SOME_INTEGER_VALUE","page":"SOME_INTEGER_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/accounts?kind=SOME_STRING_VALUE&per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/systems':
    get:
      summary: List Account's Systems
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - *ref_1
        - *ref_17
        - *ref_18
        - &ref_78
          name: embed
          description: Describes which embedded fields of the system should be populated.
          in: query
          schema:
            type: string
            enum:
              - user
      responses:
        '200': &ref_230
          description: Systems returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_79
                  allOf:
                    - &ref_72
                      title: System
                      description: >
                        A System represents the logical view of one gateway and
                        its appliances.


                        For example, a household can be represented as a system
                        with a gateway such as a 

                        gridBox, and its connected appliances.
                      allOf:
                        - &ref_80
                          title: System
                          description: >
                            A System represents the logical view of one gateway
                            and its appliances.
                              
                            For example, a household can be represented as a
                            system with a gateway such as a 

                            gridBox, and its connected appliances.
                          type: object
                          allOf:
                            - &ref_82
                              title: System
                              description: >
                                A System represents the logical view of one
                                gateway and its appliances.


                                For example, a household can be represented as a
                                system with a gateway such as a 

                                gridBox, and its connected appliances.
                              properties:
                                name:
                                  type: string
                                  maxLength: 200
                                  description: Name of the System.
                                  example: gridX Headquarter
                                  nullable: true
                                solution: &ref_290
                                  type: string
                                  description: >
                                    Represents the solution that the system
                                    uses:

                                    - HOME if the system is for a household. 

                                    - CHARGE if the system is for charging
                                    station fleet management.
                                  enum:
                                    - HOME
                                    - CHARGE
                                    - GENERAL
                                    - SMART_DISTRICT
                                    - MICROGRID
                                    - HOME_VIRTUAL_METERING
                                    - COMMERCIAL
                                    - CUSTOM_P2P
                                labels:
                                  title: Labels
                                  description: >
                                    Labels help you organize your systems.


                                    Pass one or more labels to replace the set
                                    of labels. Send an empty array ([]) to clear
                                    all

                                    labels from your system.


                                    **Deprecated** - Labels will no longer be
                                    supported starting from 01.03.2024
                                  deprecated: true
                                  type: array
                                  items:
                                    type: string
                                  example:
                                    - beta
                                    - sma
                                priorities:
                                  description: >-
                                    Allows prioritisation of EMS functionalities
                                    by appliance type.
                                  type: array
                                  items:
                                    type: string
                                  example:
                                    - EV
                                    - BATTERY
                                appliancePriorities:
                                  type: array
                                  description: >
                                    Allows prioritisation of EMS functionalities
                                    by appliance UUIDs.

                                    This option takes precendence over
                                    `priorities` field as it is more explicit.
                                  items:
                                    type: string
                                    format: uuid
                                tariffID:
                                  type: string
                                  deprecated: true
                                  description: >
                                    TariffID is used to reference a (deprecated)
                                    time of use tariff for a system.


                                    **Deprecated** - Use TariffV2 instead.
                                plan:
                                  description: >-
                                    Charge plan of the system. Must be one of
                                    the accounts assigned charge plans.
                                  type: string
                                operatingSince:
                                  type: string
                                  format: date-time
                                  description: >-
                                    Date since when the system is active in
                                    RFC3339 format.
                                  example: '2017-12-23T10:15:40Z'
                                curtailmentStrategy: &ref_291
                                  type: string
                                  description: >
                                    The curtailment strategy describes how
                                    appliances shall be curtailed.
                                      * SERIES: Appliances get in order as much as possible; order: first order by least number of energy importing phases and second order lexicographically by appliance ID.
                                      * EQUALLY: Every appliance gets equally (fair) curtailed.
                                      * PROPORTIONAL: Proportional according to the desired energy to charge (current SoC, desired SoC and max. energy) and the desired charging time set via the API.
                                  enum:
                                    - SERIES
                                    - EQUALLY
                                    - PROPORTIONAL
                                location: &ref_292
                                  title: Location
                                  description: >-
                                    Represents a GPS location with longitude and
                                    latitude.
                                  type: object
                                  allOf:
                                    - *ref_24
                                    - type: object
                                      properties:
                                        countryCode:
                                          type: string
                                          description: Country code in ISO 3166-1 alpha-2.
                                          example: DE
                                          enum:
                                            - AF
                                            - AX
                                            - AL
                                            - DZ
                                            - AS
                                            - AD
                                            - AO
                                            - AI
                                            - AQ
                                            - AG
                                            - AR
                                            - AM
                                            - AW
                                            - AU
                                            - AT
                                            - AZ
                                            - BS
                                            - BH
                                            - BD
                                            - BB
                                            - BY
                                            - BE
                                            - BZ
                                            - BJ
                                            - BM
                                            - BT
                                            - BO
                                            - BQ
                                            - BA
                                            - BW
                                            - BV
                                            - BR
                                            - IO
                                            - BN
                                            - BG
                                            - BF
                                            - BI
                                            - CV
                                            - KH
                                            - CM
                                            - CA
                                            - KY
                                            - CF
                                            - TD
                                            - CL
                                            - CN
                                            - CX
                                            - CC
                                            - CO
                                            - KM
                                            - CG
                                            - CD
                                            - CK
                                            - CR
                                            - CI
                                            - HR
                                            - CU
                                            - CW
                                            - CY
                                            - CZ
                                            - DK
                                            - DJ
                                            - DM
                                            - DO
                                            - EC
                                            - EG
                                            - SV
                                            - GQ
                                            - ER
                                            - EE
                                            - SZ
                                            - ET
                                            - FK
                                            - FO
                                            - FJ
                                            - FI
                                            - FR
                                            - GF
                                            - PF
                                            - TF
                                            - GA
                                            - GM
                                            - GE
                                            - DE
                                            - GH
                                            - GI
                                            - GR
                                            - GL
                                            - GD
                                            - GP
                                            - GU
                                            - GT
                                            - GG
                                            - GN
                                            - GW
                                            - GY
                                            - HT
                                            - HM
                                            - VA
                                            - HN
                                            - HK
                                            - HU
                                            - IS
                                            - IN
                                            - ID
                                            - IR
                                            - IQ
                                            - IE
                                            - IM
                                            - IL
                                            - IT
                                            - JM
                                            - JP
                                            - JE
                                            - JO
                                            - KZ
                                            - KE
                                            - KI
                                            - KP
                                            - KR
                                            - KW
                                            - KG
                                            - LA
                                            - LV
                                            - LB
                                            - LS
                                            - LR
                                            - LY
                                            - LI
                                            - LT
                                            - LU
                                            - MO
                                            - MG
                                            - MW
                                            - MY
                                            - MV
                                            - ML
                                            - MT
                                            - MH
                                            - MQ
                                            - MR
                                            - MU
                                            - YT
                                            - MX
                                            - FM
                                            - MD
                                            - MC
                                            - MN
                                            - ME
                                            - MS
                                            - MA
                                            - MZ
                                            - MM
                                            - NA
                                            - NR
                                            - NP
                                            - NL
                                            - NC
                                            - NZ
                                            - NI
                                            - NE
                                            - NG
                                            - NU
                                            - NF
                                            - MK
                                            - MP
                                            - 'NO'
                                            - OM
                                            - PK
                                            - PW
                                            - PS
                                            - PA
                                            - PG
                                            - PY
                                            - PE
                                            - PH
                                            - PN
                                            - PL
                                            - PT
                                            - PR
                                            - QA
                                            - RE
                                            - RO
                                            - RU
                                            - RW
                                            - BL
                                            - SH
                                            - KN
                                            - LC
                                            - MF
                                            - PM
                                            - VC
                                            - WS
                                            - SM
                                            - ST
                                            - SA
                                            - SN
                                            - RS
                                            - SC
                                            - SL
                                            - SG
                                            - SX
                                            - SK
                                            - SI
                                            - SB
                                            - SO
                                            - ZA
                                            - GS
                                            - SS
                                            - ES
                                            - LK
                                            - SD
                                            - SR
                                            - SJ
                                            - SE
                                            - CH
                                            - SY
                                            - TW
                                            - TJ
                                            - TZ
                                            - TH
                                            - TL
                                            - TG
                                            - TK
                                            - TO
                                            - TT
                                            - TN
                                            - TR
                                            - TM
                                            - TC
                                            - TV
                                            - UG
                                            - UA
                                            - AE
                                            - GB
                                            - US
                                            - UM
                                            - UY
                                            - UZ
                                            - VU
                                            - VE
                                            - VN
                                            - VG
                                            - VI
                                            - WF
                                            - EH
                                            - YE
                                            - ZM
                                            - ZW
                                        postalCode:
                                          description: The postal code of the location.
                                          type: string
                                          example: '52062'
                                        longitude:
                                          description: >-
                                            The geographic coordinate that specifies
                                            the east–west position of the location.
                                          type: number
                                          example: 6.09294299
                                          readOnly: true
                                        latitude:
                                          description: >-
                                            The geographic coordinate that specifies
                                            the north–south position of the
                                            location.
                                          type: number
                                          example: 50.77441934
                                          readOnly: true
                                metadata: &ref_300
                                  title: Metadata
                                  description: Represents system's metadata.
                                  type: object
                                  properties:
                                    wizard: &ref_293
                                      title: Wizard
                                      type: object
                                      description: >-
                                        Represents the metadata to keep track of
                                        the current wizard step.
                                      required:
                                        - step
                                      properties:
                                        step:
                                          type: string
                                          description: >-
                                            Represents the last completed wizard
                                            step.
                                    energy: &ref_296
                                      title: Energy Metadata
                                      type: object
                                      description: >-
                                        represents the metadata related to the
                                        energy use case.
                                      properties:
                                        installer:
                                          type: string
                                          nullable: true
                                          description: >-
                                            Installer is the person who has
                                            installed the systems.
                                        norminalPower:
                                          type: number
                                          nullable: true
                                          description: >-
                                            The system's maximal power production in
                                            Wp (for historical reasons the word
                                            "norminal" is used instead of the
                                            correct term "nominal power").
                                        curtailment:
                                          type: number
                                          nullable: true
                                          description: >-
                                            Curtailment is the percentage of
                                            system's norminal power at which the pv
                                            inverters should stop feeding into the
                                            grid. (0-1)
                                        heatingSystem:
                                          type: string
                                          nullable: true
                                          description: >-
                                            HeatingSystem represents the type of the
                                            heating system.
                                        agreedEMSTerms:
                                          type: boolean
                                          nullable: true
                                          deprecated: true
                                          description: >-
                                            AgreedEMSTerms indicates if the
                                            customers accepts the ems terms.
                                        ems: &ref_295
                                          title: MetadataEMS
                                          type: object
                                          description: >-
                                            MetadataEMS represents the energy
                                            management allowances.
                                          properties:
                                            agreedEMSTerms:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                AgreedEMSTerms indicates if the
                                                customers accepts the ems terms.
                                            enabledEMS:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledEMS indicates if gridBox should
                                                activate the ems.
                                            agreedDynamicPVControlTerms:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                AgreedDynamicPVControlTerms indicates if
                                                the customer accepts the dynamic pc
                                                control terms.
                                            enabledDynamicPVControl:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledDynamicPVControl indicates if the
                                                gridBox should activate the dynamic pv
                                                control.
                                            agreedForecastBasedEMSTerms:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                AgreedForecastBasedEMSTerms indicates if
                                                the customer accepts the forecast-based
                                                EMS.
                                            enabledForecastBasedEMS:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledForecastBasedEMS indicates if the
                                                gridBox should activate the
                                                forecast-based EMS.
                                            agreedPriorityConfigurationTerms:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                AgreedPriorityConfigurationTerms
                                                indicates if the customer accepts the
                                                priority configuration terms.
                                            enabledPriorityConfiguration:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledPriorityConfiguration indicates
                                                if the gridBox should activate the
                                                priority configuration.
                                            agreedPowerManagementTerms:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                AgreedPowerManagementTerms indicates if
                                                the customer accepts the power
                                                management terms.
                                            enabledPowerManagement:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledPowerManagement indicates if the
                                                gridBox should activate the power
                                                management.
                                            enabledStaticPowerManagement:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledStaticPowerManagement indicates
                                                if the gridBox should activate the
                                                static power management.
                                            enabledPowerImportPeakOptimization:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                EnabledPowerImportPeakOptimization
                                                indicates if the gridBox should activate
                                                the 15min avg. energy optimization
                                                algorithm.
                                            powerImportPeakPerOptimizationInterval:
                                              type: number
                                              nullable: true
                                              format: double
                                              description: >-
                                                Describes the amount of imported energy
                                                in a 15 minutes interval in mVA.
                                            enabledPVSurplusChargeMode:
                                              type: boolean
                                              nullable: true
                                              description: >
                                                Indicates whether the gridBox should
                                                activate the system-wide PV surplus EV
                                                charging mode or not.


                                                The individual EV configuration charging
                                                mode always takes precedence.
                                            powerPVSurplusThreshold:
                                              type: number
                                              nullable: true
                                              format: double
                                              deprecated: true
                                              description: >
                                                Specifies the PV surplus charging
                                                threshold in mVA. 


                                                WARN: This field is deprecated and not
                                                supported any more.
                                            pVSurplusActiveAt:
                                              description: >-
                                                Specifies the time at which the PV
                                                surplus charging mode is activated.
                                              nullable: true
                                              allOf:
                                                - &ref_25
                                                  description: Date time combination in RFC3339 format.
                                                  type: string
                                                  format: date-time
                                                  example: '2020-09-21T00:00:00Z'
                                            pVSurplusInactiveAt:
                                              description: >-
                                                Specifies the time at which the PV
                                                surplus charging mode is deactivated.
                                              nullable: true
                                              allOf:
                                                - *ref_25
                                            enabledBatteryFullGridCharge:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                If enabled, the battery can be recharged
                                                from the grid with 100% of the maximum
                                                charging power. If disabled, the default
                                                value is 30%.
                                            enabledLessConstrainingSOCLimits:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                If enabled, allows applying both "more
                                                constraining" and "less constraining"
                                                SOC limits. If disabled, only the "most
                                                constraining" SOC limits are considered.
                                            derAPISettings: &ref_294
                                              title: DerAPISettings
                                              type: object
                                              description: >-
                                                DerAPISettings represents the metadata
                                                related to DER API configuration.
                                              properties:
                                                enabledCloudAPI:
                                                  type: boolean
                                                  nullable: true
                                                  description: >-
                                                    EnabledCloudAPI enables assets control
                                                    with cloud DER API.
                                                constraints: &ref_26
                                                  title: SyncEntitySettings
                                                  type: object
                                                  description: >-
                                                    SyncEntitySettings configures entity
                                                    synchronisation parameters.
                                                  properties:
                                                    syncInterval:
                                                      type: number
                                                      nullable: true
                                                      format: double
                                                      description: >-
                                                        SyncInterval defines the period in
                                                        seconds for data to be synchronized
                                                        between gridBox and cloud DER API.
                                                    ttl:
                                                      type: number
                                                      nullable: true
                                                      format: double
                                                      description: >-
                                                        TTL defines the time to live in seconds
                                                        for entity.
                                                    disabled:
                                                      type: boolean
                                                      description: Disabled disables the sync of entities.
                                                flexibilities: *ref_26
                                            enabledTimeOfUseOptimization:
                                              deprecated: true
                                              type: boolean
                                              nullable: true
                                              description: >
                                                Indicates if time of use optimization is
                                                enabled for the system.

                                                *Deprecated* - Use
                                                `systems/{systemID}/timeofuse/options`
                                                endpoint instead.
                                            disableAveragePmaxCalculation:
                                              type: boolean
                                              nullable: true
                                              description: >-
                                                Disables the average pMax calculation.
                                                It means EMS will not calculate average
                                                pMax and will get the default value
                                                instead.
                                            excludeApplianceTypes:
                                              description: >-
                                                Appliance types to be ignored by the
                                                EMS. Updating this field to an empty
                                                array clears it. **Please note that this
                                                currently requires the box to be
                                                restarted to take effect**.
                                              nullable: true
                                              type: array
                                              items:
                                                type: string
                                                enum:
                                                  - HEAT_PUMP
                                            evChargingReallocationTolerance:
                                              description: >-
                                                Specifies the maximum power that can be
                                                drawn to charge an EV in case the PV
                                                surplus is not sufficient (in mVA).
                                              nullable: true
                                              type: number
                                              format: double
                                              example: 500000
                                        smartMeterInstallationTimestamp:
                                          nullable: true
                                          description: >-
                                            The time the smart meter has been
                                            installed (if any), in RFC3339 format.
                                          allOf:
                                            - *ref_25
                                    energySupplier: &ref_297
                                      title: Energy Supplier
                                      type: object
                                      description: >-
                                        MetadataEnergySupplier represents the
                                        metadata related to energy supplier.
                                      properties:
                                        type:
                                          type: string
                                          nullable: true
                                          deprecated: true
                                          description: >-
                                            Type determines if gridX is the energy
                                            supplier. The value is either "GRIDX" or
                                            "OTHER".
                                          enum:
                                            - GRIDX
                                            - OTHER
                                        unitPrice:
                                          type: number
                                          nullable: true
                                          description: >-
                                            UnitPrice is unit price per kWh in EU
                                            cent. Deprecated - Use TariffV2 instead.
                                          deprecated: true
                                        installment:
                                          type: number
                                          nullable: true
                                          description: Installment is the monthly payment.
                                        baseFee:
                                          type: number
                                          nullable: true
                                          description: BaseFee is the monthly base fee.
                                        feedInTariff:
                                          type: number
                                          nullable: true
                                          description: >-
                                            FeedInTariff is the cost-based
                                            compensation in EUR cent for feeding in.
                                            Deprecated - Use TariffV2 instead.
                                          deprecated: true
                                        expectedConsumption:
                                          type: number
                                          nullable: true
                                          description: >-
                                            ExpectedConsumption is the expected
                                            annual consumption in kWh.
                                    smartMeter: &ref_298
                                      title: Smart Meter
                                      description: >-
                                        Represents the metadata to report if a
                                        smart meter has been installed.
                                      type: object
                                      properties:
                                        installed:
                                          type: boolean
                                          nullable: true
                                          description: >-
                                            Reports if the smart meter has been
                                            installed.
                                        hasInstallationDate:
                                          type: boolean
                                          nullable: true
                                          description: >-
                                            Reports if the provider has sent us a
                                            installation date that can be found in
                                            energy metadata.
                                    electricVehicle: &ref_27
                                      title: ElectricVehicle
                                      description: >-
                                        MetadataElectricVehicle represents the
                                        metadata related to the ev. It acts as a
                                        fallback EV, if no matching EV profile
                                        has been found. See
                                        ElectricVehicleProfiles.
                                      type: object
                                      properties:
                                        manufacturer:
                                          type: string
                                          nullable: true
                                          description: Represents the manufacturer of the EV.
                                        model:
                                          type: string
                                          nullable: true
                                          description: Represents the model of the EV.
                                        capacity:
                                          type: number
                                          nullable: true
                                          description: Represents the capacity of the EV in Wh.
                                        averageConsumption:
                                          type: number
                                          nullable: true
                                          description: >-
                                            Represents the average consumption of
                                            the EV in Wh/km.
                                        phasesCount:
                                          type: integer
                                          nullable: true
                                          description: >-
                                            Number of phases used for charging the
                                            EV (range 1-3).
                                          minimum: 1
                                          maximum: 3
                                    electricVehicleProfiles:
                                      type: array
                                      items: &ref_299
                                        title: ElectricVehicleProfile
                                        type: object
                                        description: >-
                                          MetadataElectricVehicleProfile
                                          represents the metadata related to the
                                          ev. It has more information like
                                          ChargingStationApplianceID which
                                          contains the ID of the charging station
                                          appliance the EV is assigned to.
                                        allOf:
                                          - *ref_27
                                          - properties:
                                              chargingStationApplianceID:
                                                type: string
                                                nullable: true
                                                format: uuid
                                                example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                                                description: >-
                                                  Represents the charging station
                                                  appliance the EV is assigned to.
                                    availableSavings:
                                      type: array
                                      items: &ref_137
                                        description: >
                                          Saving due to various optimizations.


                                          * `CAPACITY_TARIFF_OPTIMIZATION` -
                                          Saving due to capacity tariff
                                          optimization

                                          * `SOLAR_GENERATION` - Saving due to
                                          optimal usage of solar generation

                                          * `TIME_OF_USE_OPTIMIZATION` - Saving
                                          due to optimization of day/night tariffs
                                        type: string
                                        enum:
                                          - CAPACITY_TARIFF_OPTIMIZATION
                                          - SOLAR_GENERATION
                                          - TIME_OF_USE_OPTIMIZATION
                            - properties:
                                id:
                                  type: string
                                  format: uuid
                                  readOnly: true
                                  description: Unique identifier of a system.
                                  example: aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc
                                createdAt:
                                  type: string
                                  format: date-time
                                  readOnly: true
                                  description: >-
                                    Date when the system was created in RFC3339
                                    format.
                                  example: '2017-12-22T14:20:50Z'
                                updatedAt:
                                  type: string
                                  format: date-time
                                  readOnly: true
                                  description: >-
                                    Date when the system was last updated in
                                    RFC3339 format.
                                  example: '2017-12-24T08:33:00Z'
                                chargingIntervals:
                                  type: array
                                  readOnly: true
                                  description: >-
                                    Displays charging intervals of the system's
                                    EV charging stations.
                                  items: &ref_129
                                    title: EV Charging Schedule
                                    type: object
                                    allOf:
                                      - &ref_130
                                        title: EV Charging Schedule
                                        description: >
                                          An Electric Vehicle charging schedule
                                          represents an interval in which

                                          the electric vehicle is supposed to
                                          charge at a defined limit.
                                        type: object
                                        properties:
                                          from:
                                            type: string
                                            format: date-time
                                            example: '2021-11-04T00:00:00Z'
                                            description: >
                                              Specifies when the schedule should start
                                              in RFC3339 format.
                                          to:
                                            type: string
                                            format: date-time
                                            example: '2021-11-04T00:30:00Z'
                                            description: >
                                              Specifies when the schedule should end
                                              in RFC3339 format.
                                          limit:
                                            description: >
                                              The maximum amount of power in Watts
                                              that will be used for scheduling
                                              charging in the interval [from, to].
                                            example: 75000
                                            title: Positive Power in Watt.
                                            type: integer
                                            format: int64
                                            minimum: 0
                                      - properties:
                                          id:
                                            type: string
                                            format: uuid
                                            example: ec4d0c89-a604-49ac-82f0-427f9cb42204
                                            readOnly: true
                                          updatedAt:
                                            type: string
                                            format: date-time
                                            readOnly: true
                                            description: >-
                                              Specifies when the schedule was updated
                                              the last time.
                                      - required:
                                          - id
                                          - from
                                          - to
                                          - limit
                                gateways:
                                  description: >-
                                    The gateways of which this system is
                                    comprised.
                                  type: array
                                  readOnly: true
                                  items: &ref_84
                                    allOf:
                                      - &ref_86
                                        title: Gateway
                                        description: >
                                          A gateway used to monitor and control
                                          appliances.


                                          For instance, our beloved gridbox is a
                                          gateway.
                                        type: object
                                        properties:
                                          name:
                                            type: string
                                            maxLength: 255
                                            description: Name of the gateway.
                                          debugModeUntil:
                                            type: string
                                            format: date-time
                                            description: >-
                                              Date until which debug messages are
                                              logged in RFC3339 format.
                                      - properties:
                                          id:
                                            type: string
                                            format: uuid
                                            example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                                            description: Unique identifier of a gateway.
                                            readOnly: true
                                          type: &ref_87
                                            type: string
                                            description: >
                                              Type of the gateway.


                                              **Deprecated** - Non-physical gateways
                                              will no longer be supported from
                                              01.03.2024. This field will consequently
                                              be removed.
                                            deprecated: true
                                            enum:
                                              - VIRTUAL
                                              - PHYSICAL
                                              - OTHER
                                          createdAt:
                                            type: string
                                            format: date-time
                                            readOnly: true
                                            description: >-
                                              Date when the Gateway was created in
                                              RFC3339 format.
                                          updatedAt:
                                            type: string
                                            format: date-time
                                            readOnly: true
                                            description: >-
                                              Date when the Gateway was last updated
                                              in RFC3339 format.
                                          registeredAt:
                                            type: string
                                            format: date-time
                                            readOnly: true
                                            description: >-
                                              Date when the Gateway was first
                                              registered in RFC3339 format.
                                          connectionStatus: &ref_301
                                            title: Connection Status
                                            type: object
                                            readOnly: true
                                            properties:
                                              status:
                                                type: string
                                                description: >-
                                                  Indicates the connection status. Is one
                                                  of:
                                                    * `AVAILABLE`: Gateway/Appliance has sent data in the last two minutes
                                                    * `TEMPORARILY_UNAVAILABLE`: Gateway/Appliance has not sent data in the last two minutes
                                                    * `UNAVAILABLE`: Gateway/Appliance has not sent data in the last 24 hours
                                                enum:
                                                  - AVAILABLE
                                                  - TEMPORARILY_UNAVAILABLE
                                                  - UNAVAILABLE
                                              contactedAt:
                                                type: string
                                                format: date-time
                                                description: >-
                                                  When the gateway/appliance has last
                                                  contacted the gridX cloud.
                                            required:
                                              - status
                                          vendorID:
                                            description: >-
                                              ID of the vendor account to which the
                                              corresponding system is assigned.
                                            type: string
                                            format: uuid
                                            example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                                          startcode:
                                            description: Code used to register a new gateway.
                                            type: string
                                            example: 39FDDF7D85BAAD2D
                                            pattern: '^[A-F0-9]{16}$'
                                          manufacturer:
                                            description: Manufacturer of the gateway.
                                            type: string
                                            example: gridX
                                            readOnly: true
                                          model:
                                            description: Model of the gateway.
                                            type: string
                                            example: 2.00P-X
                                            readOnly: true
                                          serialnumber:
                                            description: Serial number of the gateway.
                                            type: string
                                            example: C083-200-000-000-199-P-X
                                            readOnly: true
                                          additionalIdentifiers:
                                            description: >-
                                              Additional identifiers used by the
                                              gateway.
                                            type: array
                                            items: &ref_302
                                              title: Additional identifiers of the gridBox.
                                              description: >-
                                                Additional identifiers used by the
                                                gridBox.
                                              type: object
                                              properties:
                                                service:
                                                  type: string
                                                  readOnly: true
                                                  description: >-
                                                    The service this identifier is referring
                                                    to, e.g the protocol used for the
                                                    appliance-gridBox handshake
                                                  example: EEBUS
                                                type:
                                                  type: string
                                                  readOnly: true
                                                  description: The type of the identifier.
                                                  example: SKI
                                                  enum:
                                                    - UNKNOWN
                                                    - SKI
                                                identifier:
                                                  type: string
                                                  readOnly: true
                                                  description: >-
                                                    The actual identifier, e.g "SKI" used in
                                                    the TLS certificate for the
                                                    communication. If type is "SKI", it is
                                                    hexadecimal-encoded.
                                            readOnly: true
                                          scanners:
                                            type: array
                                            readOnly: true
                                            description: >-
                                              List of scanner names that are enabled
                                              for this gateway.
                                            items: &ref_88
                                              type: string
                                              description: >-
                                                The name of the scanner which searches
                                                for the appliance in the network.
                                              example: SMA_INVERTER_IGMP_HOST_DISCOVERY
                                              enum:
                                                - SMA_INVERTER_IGMP_HOST_DISCOVERY
                                                - SMA_INVERTER_ARP_HOST_DISCOVERY
                                                - SMA_METER
                                                - BCONTROL_METER
                                                - SOLAREDGE_INVERTER_METER_MODBUS_TCP
                                                - SOLAREDGE_INVERTER_METER_MODBUS_RTU
                                                - SOLARLOG_MONITOR
                                                - CUSTOMER_HOLFELDER_METER
                                                - CUSTOMER_HOLFELDER_INVERTER
                                                - E3DC_INVERTER_METER
                                                - KOSTAL_INVERTER
                                                - STUDER_INVERTER
                                                - FRONIUS_INVERTER
                                                - HUAWEI_INVERTER
                                                - KEBA_CHARGING_STATION
                                                - ECHARGE_CHARGING_STATION
                                                - INNOGY_CHARGING_STATION
                                                - ELECTRIS_METER
                                                - SOLARWATT_INVERTER_METER
                                                - ABL_CHARGING_STATION
                                                - SIEMENS_PAC_METER
                                                - JANITZA_METER
                                                - JANITZA_METER_RTU
                                                - EVTEC_CHARGING_STATION
                                                - HIKING_METER_RTU
                                                - EEBUS_FUEL_CELL_METER
                                                - KOSTAL_INVERTER_PLENTICORE
                                                - SONNENBATTERIE_UPNP
                                                - VIRTUAL_METER
                                                - MENNEKES_UPNP
                                                - ANYBUS_MBUS_CONVERTER_METER
                                                - EEBUS_GENERIC
                                                - SIMULATION_GENERIC
                                                - ALFEN_NG9XX_MODBUS_CHARGING_STATION
                                                - >-
                                                  ALPITRONIC_HYPERCHARGER_MODBUS_CHARGING_STATION
                                                - MY_PV_AC_THOR_HEATER
                                                - COMPLEO_MODBUS_CHARGING_STATION
                                                - OCPP_CHARGING_STATION
                                                - BENDER_CHARGING_STATION
                                                - VOLTERION_REDOX_FLOW_BATTERY
                                                - XNET_METER
                                                - RSW_METER
                                                - SCHNEIDER_METER
                                                - INNOGY_MODBUS_CHARGING_STATION
                                                - MENNEKES_PREMIUM_MODBUS_CHARGING_STATION
                                                - PLPLANO_MODBUS_RTU_METER
                                                - >-
                                                  HEIDELBERG_ENERGY_CONTROL_MODBUS_RTU_CHARGING_STATION
                                                - CARLO_GAVAZZI_MODBUS_RTU_METER
                                                - VESTEL_CHARGING_STATION
                                                - INNOTEC_HEAT_PUMP
                                                - WALLBE_MODBUS_CHARGING_STATION
                                                - EVBOX_MAX_CHARGING_STATION
                                                - ISKRAEMECO_METER
                                                - SUNGROW_MODBUS_INVERTER
                                                - WAGO_IO_DEVICE
                                                - GOE_CHARGING_STATION
                                                - XNET_CLOUD_HEAT_PUMP
                                                - XNET_CLOUD_GENERIC
                                                - LANDIS_GYR_METER
                                                - POWERDALE_CHARGING_STATION
                                                - EASTRON_SDM230_METER
                                                - EASTRON_SDM72DM_METER
                                                - ZUCCHETTI_CONNEXT_BOX
                                                - PLVARIO_ENERGY_METER_EM3
                                                - ABB_OPC_UA_CHARGING_STATION
                                                - DATA_LOGGER_DEVICE
                                                - POWERSIDE_METER
                                                - PPC_METER
                                                - RUTENBECK_TCR_IP4_IO_DEVICE
                                                - JEAN_MUELLER_PL_MULTI_METER
                                                - ENPHASE_ENVOY_S_GATEWAY
                                                - SOLAX_MODBUS_RTU_INVERTER
                                                - ALPHA_ESS_HI10_HYBRID_INVERTER
                                                - ZUCCHETTI_MODBUS_RTU_INVERTER
                                                - STIEBEL_ELTRON_MODBUS_TCP_HEAT_PUMP
                                                - >-
                                                  MENNEKES_AMTRON_COMPACT_2S_MODBUS_RTU_CHARGING_STATION
                                                - SAIA_PCD1_E_LINE_HEAT_PUMP
                                                - SUNGROW_SG_MODBUS_INVERTER
                                                - SOLAX_MODBUS_TCP_INVERTER
                                                - PHOENIX_CONTACT_EM_PRO_METER
                                          applianceComposition:
                                            type: array
                                            readOnly: true
                                            description: >-
                                              Appliance types that are connected to
                                              the gateway for overview purposes.
                                            example:
                                              - HEAT_PUMP
                                            items:
                                              type: string
                                        required:
                                          - id
                                          - type
                                          - startcode
                                          - connectionStatus
                                          - createdAt
                                          - updatedAt
                                status:
                                  type: string
                                  readOnly: true
                                  enum:
                                    - UNDEFINED
                                    - OK
                                    - WARNING
                                    - ERROR
                                  description: |
                                    Status of the system: 
                                      - OK: If there has been a successful heartbeat of an attached gateway recently.
                                      - WARNING: If the last heartbeat of an attached gateway is a longer time but less than 24h ago.
                                      - ERROR: If the last heartbeat of an attached gateway is longer than 24h ago. 
                                      - UNEFINED: otherwise
                        - &ref_81
                          title: Embedded accounts
                          description: >
                            Hierarchy of accounts the system belongs to, from
                            the authenticated account down to the end
                            customer's.
                          type: object
                          properties:
                            accounts:
                              type: array
                              items: *ref_10
                              readOnly: true
                        - properties:
                            productOption: &ref_177
                              type: object
                              allOf:
                                - &ref_175
                                  title: Product Option
                                  description: >
                                    A product option describes a set of features
                                    whose access should be restricted from or
                                    granted to users of a system.


                                    Systems can be assigned a product option to
                                    manage their access to these features.


                                    This is the base type for the more concrete
                                    usages and not used directly within
                                    operations.
                                  type: object
                                  properties:
                                    name:
                                      type: string
                                      description: Name of the product option.
                                      example: Default Product Option
                                    description:
                                      type: string
                                      description: >-
                                        Describes the purpose of the product
                                        option.
                                - properties:
                                    id:
                                      description: Unique identifier of the product option.
                                      type: string
                                      format: uuid
                                      example: d5166f02-8b56-4200-90bd-35d3d17391b4
                                    accountID:
                                      description: >-
                                        Unique identifier of the account that
                                        owns the product option.
                                      type: string
                                      format: uuid
                                      example: d73b6749-2c32-4bca-ab73-50d8e3744edf
                                    isDefault:
                                      type: boolean
                                      description: >-
                                        Indicates whether the product option
                                        should be assigned by default to all
                                        systems of the owning account.
                                    functionalities:
                                      description: >-
                                        The default functionalities that a
                                        product option restricts access to.
                                        Deprecated - Use `showFunctionalities`
                                        and `hideFunctionalities` instead.
                                      type: array
                                      readOnly: true
                                      deprecated: true
                                      items: &ref_28
                                        type: object
                                        allOf:
                                          - &ref_173
                                            description: >
                                              A product functionality describes a
                                              feature.


                                              It is used to manage access to this
                                              feature via product options.


                                              This is the base type for the more
                                              concrete usages and not used directly
                                              within operations.
                                            type: object
                                            properties:
                                              name:
                                                type: string
                                                maxLength: 256
                                                description: Name of the product functionality.
                                                example: EV Manager
                                              hide:
                                                type: boolean
                                                description: >-
                                                  Indicates whether the product
                                                  functionality should be hidden or shown.
                                              description:
                                                type: string
                                                description: >-
                                                  Describes the purpose of the product
                                                  functionality.
                                          - properties:
                                              id:
                                                description: >-
                                                  Unique identifier of the product
                                                  functionality.
                                                type: string
                                                format: uuid
                                                example: 4e3392ce-ed94-4946-8a11-665e0443723e
                                            required:
                                              - id
                                              - name
                                              - hide
                                    hideFunctionalities:
                                      readOnly: true
                                      description: >-
                                        The default functionalities that a
                                        product option restricts access to. Must
                                        be of type `hide=true`.
                                      type: array
                                      items: *ref_28
                                    showFunctionalities:
                                      readOnly: true
                                      description: >-
                                        The extra functionalities that a product
                                        option grants access to. Must be of type
                                        `hide=false`.
                                      type: array
                                      items: *ref_28
                                  required:
                                    - id
                                    - accountID
                                    - name
                                    - isDefault
                                    - functionalities
                                    - hideFunctionalities
                                    - showFunctionalities
                            productOptionUpdatedAt:
                              description: >-
                                Time at which the system's product option was
                                last changed in RFC3339 format.
                              type: string
                              format: date-time
                              readOnly: true
                              example: '2009-11-10T23:20:50Z'
                            tariffID:
                              type: string
                              format: uuid
                          required:
                            - id
                            - name
                            - createdAt
                            - updatedAt
                    - properties:
                        users:
                          description: |
                            The users belonging to this system.
                            Only set if `embed` query parameter includes `user`.
                          type: array
                          readOnly: true
                          items: *ref_29
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/systems',
              qs: {
                per_page: 'SOME_INTEGER_VALUE',
                page: 'SOME_INTEGER_VALUE',
                embed: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");


            req.query({
              "per_page": "SOME_INTEGER_VALUE",
              "page": "SOME_INTEGER_VALUE",
              "embed": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/systems');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE',
              'embed' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/systems');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE',
              'embed' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/systems"


            querystring =
            {"per_page":"SOME_INTEGER_VALUE","page":"SOME_INTEGER_VALUE","embed":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Assign a System to an Account
      tags:
        - System
      security:
        - BearerAuth:
            - AccountsWrite
      parameters:
        - *ref_1
      requestBody: &ref_73
        description: Assign a system (and its customers) to an account.
        required: true
        content:
          application/json:
            schema: &ref_304
              allOf:
                - &ref_303
                  title: System-Account assignment
                  type: object
                  required:
                    - uuids
                  properties:
                    moveSystemsAndCustomers:
                      description: >
                        - `true`: Moves the system from the origin account to
                        the target account (accountID parameter) and its parent
                        accounts. The customers that belong to that account are
                        also moved to the target account.

                        - `false`: Assigns the system to the target account
                        (accountID parameter) and its parent accounts.
                      type: boolean
                    moveVendorID:
                      description: >
                        `true` by default when moveSystemsAndCustomers is
                        `true`.
                          - `true`: Updates the vendorID of the gateway of the specified system to the target accountID.
                          - `false`: Does not update the vendorID of the gateway of the specified system.
                      type: boolean
                    uuids:
                      description: System IDs that will be moved to the target account.
                      type: array
                      items:
                        type: string
                        example: aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc
                - additionalProperties: false
      responses:
        '200': &ref_235
          description: System assigned to account.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_10
        '403': *ref_11
        '404': *ref_12
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/systems");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/systems\"\n\n\tpayload := strings.NewReader(\"{\\\"moveSystemsAndCustomers\\\":true,\\\"moveVendorID\\\":true,\\\"uuids\\\":[\\\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\\\"]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/systems")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/systems")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/systems",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": [
                "aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/systems",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/systems",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              moveSystemsAndCustomers: true,
              moveVendorID: true,
              uuids: ['aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc']
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/systems',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                moveSystemsAndCustomers: true,
                moveVendorID: true,
                uuids: ['aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc']
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": [
                "aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"moveSystemsAndCustomers": @YES,
                                          @"moveVendorID": @YES,
                                          @"uuids": @[ @"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc" ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/systems');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/systems');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/accounts/%7BaccountID%7D/systems", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/systems"


            payload = {
                "moveSystemsAndCustomers": True,
                "moveVendorID": True,
                "uuids": ["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/systems")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/systems \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}'
            |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/systems \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": ["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Unassign a System from an Account
      tags:
        - System
      security:
        - BearerAuth:
            - AccountsWrite
      parameters:
        - *ref_1
      requestBody: &ref_202
        description: Unassings a system (and its customers) from an account.
        required: true
        content:
          application/json:
            schema: &ref_305
              title: System-Account unassignment
              type: object
              required:
                - uuids
              properties:
                moveSystemsAndCustomers:
                  description: >
                    - `true`: Unassigns the system from the given account
                    (accountID parameter). Moves the customer account to the
                    parent account of the account the system is unassigned from
                    (accountID parameter).

                    - `false`: Unassigns the system from the given account
                    (accountID parameter).
                  type: boolean
                moveVendorID:
                  description: |
                    `true` by default when moveSystemsAndCustomers is `true`.

                      - `true`: Updates the vendorID of the gateway of the specified system to the target accounts' parentID.
                      - `false`: Does not update the vendorID of the gateway of the specified system.
                  type: boolean
                uuids:
                  description: System IDs that will be removed from the target account.
                  type: array
                  items:
                    type: string
                    example: aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc
      responses:
        '200': &ref_236
          description: System unassigned from account.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_10
        '403': *ref_11
        '404': *ref_12
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/systems");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/systems\"\n\n\tpayload := strings.NewReader(\"{\\\"moveSystemsAndCustomers\\\":true,\\\"moveVendorID\\\":true,\\\"uuids\\\":[\\\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\\\"]}\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/systems")
              .delete(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/systems")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/systems",
              "method": "DELETE",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": [
                "aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/systems",
              "method": "DELETE",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/systems",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              moveSystemsAndCustomers: true,
              moveVendorID: true,
              uuids: ['aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc']
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/systems',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                moveSystemsAndCustomers: true,
                moveVendorID: true,
                uuids: ['aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc']
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": [
                "aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"moveSystemsAndCustomers": @YES,
                                          @"moveVendorID": @YES,
                                          @"uuids": @[ @"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc" ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            in


            Client.call ~headers ~body `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_POSTFIELDS => "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/systems');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/systems');

            $request->setRequestMethod('DELETE');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("DELETE", "/accounts/%7BaccountID%7D/systems", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/systems"


            payload = {
                "moveSystemsAndCustomers": True,
                "moveVendorID": True,
                "uuids": ["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("DELETE", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/systems")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/systems \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}'
            |  \
              http DELETE https://api.gridx.de/accounts/%7BaccountID%7D/systems \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": ["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/policies':
    post:
      summary: Assign a Policy Document to an Account
      tags:
        - Policy
      security:
        - BearerAuth:
            - AccountsWrite
      parameters:
        - *ref_1
      requestBody: &ref_192
        description: Assigns a policy document to an account.
        required: true
        content:
          application/json:
            schema: &ref_307
              allOf:
                - &ref_306
                  title: Assign Policy Document to Account
                  description: >
                    Holds the data required to assign an existing policy
                    document by its ID to an existing account.
                  type: object
                  required:
                    - id
                  properties:
                    id:
                      type: string
                      format: uuid
                      description: >-
                        Unique identifier of the policy document to be assigned
                        to the account.
                      example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                - additionalProperties: false
      responses:
        '204':
          description: Policy document assigned to account successfully.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/policies");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/policies");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/policies\"\n\n\tpayload := strings.NewReader(\"{\\\"id\\\":\\\"97874c1b-d073-4b06-bf01-a1497fbe1146\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/policies")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/policies")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/policies",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "id": "97874c1b-d073-4b06-bf01-a1497fbe1146"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/policies");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/policies",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/policies",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({id:
            '97874c1b-d073-4b06-bf01-a1497fbe1146'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/policies',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {id: '97874c1b-d073-4b06-bf01-a1497fbe1146'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/policies");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "id": "97874c1b-d073-4b06-bf01-a1497fbe1146"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"id":
            @"97874c1b-d073-4b06-bf01-a1497fbe1146" };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/policies"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/policies" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/policies",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/policies');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/policies');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/accounts/%7BaccountID%7D/policies", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/policies"


            payload = {"id": "97874c1b-d073-4b06-bf01-a1497fbe1146"}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/policies")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Post.new(url)
            request["content-type"] = 'application/json'
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'
            request.body = "{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\"}"

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/policies \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146"}' |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/policies \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/policies
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["id": "97874c1b-d073-4b06-bf01-a1497fbe1146"] as
            [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/policies")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/documents':
    get:
      summary: Get Account Documents
      description: Lists files with keys that have a specific prefix
      tags:
        - Document
      security:
        - BearerAuth:
            - DocumentsRead
      parameters:
        - *ref_1
        - &ref_183
          name: prefix
          description: Limits the response to keys that begin with the specified prefix.
          in: query
          example: myKey_
          schema:
            type: string
      responses:
        '200': &ref_226
          description: Account documents returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_31
                  title: File
                  description: >
                    Used to represent a bunch of data related to files in the S3
                    bucket.
                  type: object
                  properties:
                    key:
                      type: string
                    size:
                      type: number
                    modified:
                      type: string
                      format: date-time
                  required:
                    - key
                    - size
                    - modified
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/documents',
              qs: {prefix: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents");


            req.query({
              "prefix": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'prefix' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'prefix' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/documents"


            querystring = {"prefix":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents?prefix=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/documents/{documentKey}':
    get:
      summary: Get Account Document
      description: Gets a file and downloads a file
      tags:
        - Document
      security:
        - BearerAuth:
            - DocumentsRead
      parameters:
        - *ref_1
        - &ref_30
          name: documentKey
          description: |
            Unique identifier that can be used to access documents.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': &ref_227
          description: |
            Account document returned.
            The MIME-Type and concrete content depends on the returned file.
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create Account Document
      description: Creates a new file in the s3 bucket
      tags:
        - Document
      security:
        - BearerAuth:
            - DocumentsWrite
      parameters:
        - *ref_1
        - *ref_30
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
              additionalProperties: false
      responses:
        '201': &ref_228
          description: Account document created.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_268
                allOf:
                  - *ref_31
                  - type: object
                    properties:
                      link:
                        description: URI location of the uploaded file
                        type: string
                    required:
                      - link
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            multipart/form-data");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "multipart/form-data");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"multipart/form-data\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")
              .post(null)
              .addHeader("content-type", "multipart/form-data")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")
              .header("content-type", "multipart/form-data")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "method": "POST",
              "headers": {
                "content-type": "multipart/form-data",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");

            xhr.setRequestHeader("content-type", "multipart/form-data");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "method": "POST",
              "headers": {
                "content-type": "multipart/form-data",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "headers": {
                "content-type": "multipart/form-data",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D',
              headers: {
                'content-type': 'multipart/form-data',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              }
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");


            req.headers({
              "content-type": "multipart/form-data",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"multipart/form-data",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };

            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "multipart/form-data");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in


            Client.call ~headers `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: multipart/form-data"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'multipart/form-data',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D');

            $request->setRequestMethod('POST');

            $request->setHeaders([
              'content-type' => 'multipart/form-data',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = {
                'content-type': "multipart/form-data",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"


            headers = {
                "content-type": "multipart/form-data",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'multipart/form-data'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: multipart/form-data'
        - lang: Shell + Httpie
          source: >-
            http POST
            https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:multipart/form-data
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: multipart/form-data' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "multipart/form-data",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Account Document
      description: Delete deletes a file using a given key
      tags:
        - Document
      security:
        - BearerAuth:
            - DocumentsWrite
      parameters:
        - *ref_1
        - *ref_30
      responses:
        '204':
          description: Account document deleted successfully.
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/documents/%7BdocumentKey%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/groups':
    get:
      summary: List all Groups
      tags:
        - Group
      security:
        - BearerAuth:
            - GroupsRead
      parameters:
        - *ref_1
      responses:
        '200': &ref_231
          description: Policy groups of the account returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_32
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/groups");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/groups\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/groups")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/groups")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/groups",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/groups',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/groups"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/groups",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/accounts/%7BaccountID%7D/groups",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/accounts/%7BaccountID%7D/groups"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/groups")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/groups \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/accounts/%7BaccountID%7D/groups \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/groups
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a Group
      tags:
        - Group
      security:
        - BearerAuth:
            - GroupsWrite
      parameters:
        - *ref_1
      requestBody: &ref_193
        description: Creates a policy group and related documents.
        required: true
        content:
          application/json:
            schema: &ref_309
              allOf:
                - &ref_308
                  type: object
                  allOf:
                    - *ref_33
                    - properties:
                        accountID:
                          type: string
                          format: uuid
                          description: Unique identifier of the creator account.
                          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                          readOnly: true
                        policies:
                          type: array
                          description: >-
                            the ID's of the policy documents that the group
                            should be assigned to.
                          example:
                            - 532365fc-5a0e-4323-bc66-4ce9f1308480
                          items:
                            type: string
                            format: uuid
                      required:
                        - name
                - additionalProperties: false
      responses:
        '200': &ref_232
          description: Policy group created.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_32
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/groups");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/groups\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"group name\\\",\\\"description\\\":\\\"Group provides read-access to accounts\\\",\\\"policies\\\":[\\\"532365fc-5a0e-4323-bc66-4ce9f1308480\\\"]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/groups")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/groups")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "group name",
              "description": "Group provides read-access to accounts",
              "policies": [
                "532365fc-5a0e-4323-bc66-4ce9f1308480"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/groups",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'group name',
              description: 'Group provides read-access to accounts',
              policies: ['532365fc-5a0e-4323-bc66-4ce9f1308480']
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/groups',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'group name',
                description: 'Group provides read-access to accounts',
                policies: ['532365fc-5a0e-4323-bc66-4ce9f1308480']
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "group name",
              "description": "Group provides read-access to accounts",
              "policies": [
                "532365fc-5a0e-4323-bc66-4ce9f1308480"
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"group name",
                                          @"description": @"Group provides read-access to accounts",
                                          @"policies": @[ @"532365fc-5a0e-4323-bc66-4ce9f1308480" ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/groups"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/groups",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"group name","description":"Group
            provides read-access to
            accounts","policies":["532365fc-5a0e-4323-bc66-4ce9f1308480"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"group name","description":"Group provides
            read-access to
            accounts","policies":["532365fc-5a0e-4323-bc66-4ce9f1308480"]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"group name\",\"description\":\"Group provides
            read-access to
            accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/accounts/%7BaccountID%7D/groups", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/groups"


            payload = {
                "name": "group name",
                "description": "Group provides read-access to accounts",
                "policies": ["532365fc-5a0e-4323-bc66-4ce9f1308480"]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/groups")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"group name\",\"description\":\"Group
            provides read-access to
            accounts\",\"policies\":[\"532365fc-5a0e-4323-bc66-4ce9f1308480\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/groups \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"group name","description":"Group provides read-access to accounts","policies":["532365fc-5a0e-4323-bc66-4ce9f1308480"]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"group name","description":"Group provides read-access
            to accounts","policies":["532365fc-5a0e-4323-bc66-4ce9f1308480"]}'
            |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/groups \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"group name","description":"Group provides read-access to accounts","policies":["532365fc-5a0e-4323-bc66-4ce9f1308480"]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/groups
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "group name",
              "description": "Group provides read-access to accounts",
              "policies": ["532365fc-5a0e-4323-bc66-4ce9f1308480"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/groups/{groupID}':
    get:
      summary: Retrieve a Group
      tags:
        - Group
      security:
        - BearerAuth:
            - GroupsRead
      parameters:
        - *ref_1
        - &ref_35
          name: groupID
          description: |
            Unique identifier that can be used to access policy groups.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': &ref_233
          description: Policy group returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_312
                allOf:
                  - *ref_32
                  - type: object
                    properties:
                      users:
                        type: array
                        items: &ref_311
                          title: Customer
                          description: Represents an end-customer user.
                          type: object
                          allOf:
                            - *ref_34
                            - &ref_310
                              title: Customer
                              description: Represents an end-customer user.
                              type: object
                              allOf:
                                - properties:
                                    deliveryAddress: *ref_9
                                    customerID:
                                      type: string
                                      description: Uniquely identifies the customer.
                                    meterID:
                                      type: string
                                    wizardCompleted:
                                      type: boolean
                                      description: True if the wizard has been completed.
                                    lastRequestAt:
                                      type: string
                                      format: date-time
                                      description: >-
                                        Specifies when the last request has been
                                        made by the customer. This field might
                                        not be always up-to-date and it might
                                        take some time for changes to be
                                        propagated.
                                      readOnly: true
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      tags:
        - Group
      summary: Update a Group
      security:
        - BearerAuth:
            - GroupsWrite
      parameters:
        - *ref_1
        - *ref_35
      requestBody:
        description: Policy Group
        required: true
        content:
          application/json:
            schema: &ref_314
              allOf:
                - &ref_313
                  title: Policy Group Update
                  type: object
                  allOf:
                    - *ref_33
                - additionalProperties: false
      responses:
        '200': &ref_234
          description: Updated policy group.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: object
                allOf:
                  - *ref_32
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to accounts\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"group name\\\",\\\"description\\\":\\\"Group provides read-access to accounts\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "group name",
              "description": "Group provides read-access to accounts"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({name: 'group name', description: 'Group
            provides read-access to accounts'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {name: 'group name', description: 'Group provides read-access to accounts'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "group name",
              "description": "Group provides read-access to accounts"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"group name",
                                          @"description": @"Group provides read-access to accounts" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to accounts\"}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"group name","description":"Group
            provides read-access to accounts"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"group name","description":"Group provides
            read-access to accounts"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"group name\",\"description\":\"Group provides
            read-access to accounts\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"


            payload = {
                "name": "group name",
                "description": "Group provides read-access to accounts"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"group name\",\"description\":\"Group
            provides read-access to accounts\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"group name","description":"Group provides read-access to accounts"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"group name","description":"Group provides read-access
            to accounts"}' |  \
              http PATCH https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"group name","description":"Group provides read-access to accounts"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "group name",
              "description": "Group provides read-access to accounts"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      tags:
        - Group
      summary: Delete a Group
      security:
        - BearerAuth:
            - GroupsWrite
      parameters:
        - *ref_1
        - *ref_35
      responses:
        '204':
          description: Policy group deleted successfully.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/groups/{groupID}/policies':
    get:
      summary: Get Policy Documents in a Group
      tags:
        - Group
      security:
        - BearerAuth:
            - GroupsRead
            - PoliciesRead
      parameters:
        - *ref_1
        - *ref_35
      responses:
        '200': &ref_229
          description: Policy documents returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_168
                  title: Policy Document
                  type: object
                  allOf:
                    - &ref_169
                      title: Policy Document
                      description: >
                        A policy document describes the permissions of the user
                        which can be used for access management.
                      type: object
                      required:
                        - name
                        - version
                      properties:
                        name:
                          type: string
                          maxLength: 256
                          description: Name of the policy.
                          example: Default Policy
                        version:
                          type: string
                          maxLength: 64
                          description: Version of the policy.
                          example: Default Policy
                    - properties:
                        id:
                          type: string
                          readOnly: true
                          format: uuid
                          description: Unique identifier of the policy document.
                          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                        createdAt:
                          type: string
                          format: date-time
                          description: >-
                            Date when the policy was created in UTC (RFC 3339
                            format).
                          readOnly: true
                        updatedAt:
                          type: string
                          format: date-time
                          description: >-
                            Date when the policy was last updated in UTC (RFC
                            3339 format).
                          readOnly: true
                        statements:
                          type: array
                          items: &ref_315
                            title: Policy Statement
                            type: object
                            allOf:
                              - &ref_170
                                title: Policy Statement
                                description: >
                                  A policy statement grants or restricts the
                                  permission to perform an action.
                                type: object
                                required:
                                  - name
                                  - action
                                  - resource
                                  - fields
                                  - effect
                                properties:
                                  id:
                                    type: string
                                    format: uuid
                                    description: Unique identifier of the policy statement.
                                    example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                                  name:
                                    type: string
                                    description: Name of the policy statement.
                                  action:
                                    type: string
                                    description: >-
                                      The action that this statement represents.
                                      An action is an operation on a resource.
                                    example: 'groups:Create'
                                  effect:
                                    type: string
                                    description: >-
                                      Whether this statement restricts or grants
                                      the permission to perform the described
                                      action.
                                    enum:
                                      - allow
                                      - deny
                                    example: allow
                                  fields:
                                    type: string
                                    description: >-
                                      Used for fine-grained control over request
                                      bodies, e.g. to allow/deny a certain field
                                      in the payload.
                                    example: '*'
                                  resource:
                                    type: string
                                    description: >
                                      Hierarchical structure over resources to
                                      control endpoint access.


                                      For instance, "accounts:*" means that the
                                      user can read/modify any account
                                      (represented by the wildcard '*').
                                    example: 'accounts:*:groups'
                              - properties:
                                  id:
                                    type: string
                                    format: uuid
                                    description: Unique identifier of the policy statement.
                                    example: 97874c1b-d073-4b06-bf01-a1497fbe1146
                                    readOnly: true
                                  createdAt:
                                    type: string
                                    format: date-time
                                    description: >-
                                      Date when the policy statement was created
                                      in UTC (RFC 3339 format).
                                    readOnly: true
                                  updatedAt:
                                    type: string
                                    format: date-time
                                    description: >-
                                      Date when the policy statement was last
                                      updated in UTC (RFC 3339 format).
                                    readOnly: true
                                required:
                                  - id
                                  - name
                                  - action
                                  - resource
                                  - fields
                                  - createdAt
                      required:
                        - id
                        - statements
                        - createdAt
                        - updatedAt
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/groups/%7BgroupID%7D/policies")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/users/{userID}':
    delete:
      summary: Delete User
      description: Delete a user given its ID.
      tags:
        - User
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - &ref_36
          name: userID
          description: |
            Unique identifier used to access a user.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
        - &ref_69
          name: delete-auth0
          description: |
            If set to `false`, it does not delete the user from Auth0.
          in: query
          required: false
          schema:
            type: boolean
            default: true
          example: false
      responses:
        '204':
          description: User deleted.
        '400': *ref_15
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D',
              qs: {'delete-auth0': 'SOME_BOOLEAN_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D");


            req.query({
              "delete-auth0": "SOME_BOOLEAN_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setQueryData([
              'delete-auth0' => 'SOME_BOOLEAN_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D');

            $request->setRequestMethod('DELETE');

            $request->setQuery(new http\QueryString([
              'delete-auth0' => 'SOME_BOOLEAN_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D"


            querystring = {"delete-auth0":"SOME_BOOLEAN_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D?delete-auth0=SOME_BOOLEAN_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/users/{userID}/notifications':
    get:
      summary: List all Notifications
      description: |
        Lists all notification for a user.

        User ID may be explicitly specified as a path parameter,
        otherwise the authenticated user will be used.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersRead
      parameters:
        - *ref_1
        - *ref_36
        - *ref_17
        - *ref_18
        - name: unread
          description: List only unread notifications.
          in: query
          schema:
            type: boolean
      responses:
        '200': &ref_238
          description: Notifications returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_37
                  allOf:
                    - &ref_181
                      title: Notification
                      type: object
                      properties:
                        eventType:
                          type: string
                          description: Type of the event that triggered the notification.
                        systemID:
                          type: string
                          format: uuid
                          description: Identifies the affected system.
                          example: 49a4f165-8233-426b-a1a4-e569665a25dd
                        content:
                          type: string
                          description: >-
                            Textual content that is displayed within the
                            dashboard.
                        read:
                          type: boolean
                          description: >-
                            If true, the message has been read by the user,
                            otherwise it was not read yet.
                        timestamp:
                          type: string
                          format: date-time
                          description: >-
                            Time at which the event with `eventType` was issued
                            by the notification system in UTC in RFC3339 format.
                    - properties:
                        id:
                          type: string
                          format: uuid
                          description: Uniquely identifies the notification.
                          example: 49a4f165-8233-426b-a1a4-e569665a25dd
                          readOnly: true
                        userID:
                          type: string
                          format: uuid
                          description: User ID of the recipient.
                          example: 49a4f165-8233-426b-a1a4-e569665a25dd
                          readOnly: true
                        createdAt:
                          type: string
                          format: date-time
                          description: >-
                            Time at which the notification was created in UTC in
                            RFC3339 format.
                          readOnly: true
                        updatedAt:
                          type: string
                          format: date-time
                          description: >-
                            Time at which the notification was updated in UTC in
                            RFC3339 format.
                          readOnly: true
                      required:
                        - id
                        - userID
                        - content
                        - eventType
                        - timestamp
                        - read
                        - createdAt
                        - updatedAt
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications',
              qs: {
                per_page: 'SOME_INTEGER_VALUE',
                page: 'SOME_INTEGER_VALUE',
                unread: 'SOME_BOOLEAN_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications");


            req.query({
              "per_page": "SOME_INTEGER_VALUE",
              "page": "SOME_INTEGER_VALUE",
              "unread": "SOME_BOOLEAN_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE',
              'unread' => 'SOME_BOOLEAN_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE',
              'unread' => 'SOME_BOOLEAN_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications"


            querystring =
            {"per_page":"SOME_INTEGER_VALUE","page":"SOME_INTEGER_VALUE","unread":"SOME_BOOLEAN_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create User Notifications
      description: |
        Creates a notification for a user.

        User ID may be explicitly specified as a path parameter,
        otherwise the authenticated user will be used.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - *ref_36
      requestBody: &ref_196
        description: Create a notification.
        required: true
        content:
          application/json:
            schema: &ref_39
              allOf:
                - *ref_37
                - additionalProperties: false
      responses:
        '201': &ref_240
          description: Notification created.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_37
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications\"\n\n\tpayload := strings.NewReader(\"{\\\"eventType\\\":\\\"string\\\",\\\"systemID\\\":\\\"49a4f165-8233-426b-a1a4-e569665a25dd\\\",\\\"content\\\":\\\"string\\\",\\\"read\\\":true,\\\"timestamp\\\":\\\"2019-08-24T14:15:22Z\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              eventType: 'string',
              systemID: '49a4f165-8233-426b-a1a4-e569665a25dd',
              content: 'string',
              read: true,
              timestamp: '2019-08-24T14:15:22Z'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                eventType: 'string',
                systemID: '49a4f165-8233-426b-a1a4-e569665a25dd',
                content: 'string',
                read: true,
                timestamp: '2019-08-24T14:15:22Z'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"eventType": @"string",
                                          @"systemID": @"49a4f165-8233-426b-a1a4-e569665a25dd",
                                          @"content": @"string",
                                          @"read": @YES,
                                          @"timestamp": @"2019-08-24T14:15:22Z" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications"


            payload = {
                "eventType": "string",
                "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
                "content": "string",
                "read": True,
                "timestamp": "2019-08-24T14:15:22Z"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}'
            |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/users/{userID}/notifications/{notificationID}':
    get:
      summary: Retrieve a Notification
      description: |
        Returns a notification by its ID.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersRead
      parameters:
        - *ref_1
        - *ref_36
        - &ref_38
          name: notificationID
          description: |
            Unique identifier that can be used to access notifications.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': &ref_40
          description: Notification returned.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_37
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    put:
      summary: Update Notification
      description: |
        Updates an existing notification.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - *ref_36
        - *ref_38
      requestBody: &ref_197
        description: Updates a notification.
        required: true
        content:
          application/json:
            schema: *ref_39
      responses:
        '200': *ref_40
        '403': *ref_11
        '404': &ref_239
          description: Notification not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"eventType\\\":\\\"string\\\",\\\"systemID\\\":\\\"49a4f165-8233-426b-a1a4-e569665a25dd\\\",\\\"content\\\":\\\"string\\\",\\\"read\\\":true,\\\"timestamp\\\":\\\"2019-08-24T14:15:22Z\\\"}\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")
              .put(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              eventType: 'string',
              systemID: '49a4f165-8233-426b-a1a4-e569665a25dd',
              content: 'string',
              read: true,
              timestamp: '2019-08-24T14:15:22Z'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                eventType: 'string',
                systemID: '49a4f165-8233-426b-a1a4-e569665a25dd',
                content: 'string',
                read: true,
                timestamp: '2019-08-24T14:15:22Z'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"eventType": @"string",
                                          @"systemID": @"49a4f165-8233-426b-a1a4-e569665a25dd",
                                          @"content": @"string",
                                          @"read": @YES,
                                          @"timestamp": @"2019-08-24T14:15:22Z" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            in


            Client.call ~headers ~body `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_POSTFIELDS => "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D');

            $request->setRequestMethod('PUT');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PUT",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"


            payload = {
                "eventType": "string",
                "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
                "content": "string",
                "read": True,
                "timestamp": "2019-08-24T14:15:22Z"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PUT", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}'
            |  \
              http PUT https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Notification
      description: |
        Deletes an existing notification.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - *ref_36
        - *ref_38
      responses:
        '204':
          description: Notification deleted successfully.
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/%7BnotificationID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/users/{userID}/notifications/rules':
    get:
      summary: List all Rules
      description: >
        Lists all rules for the user.


        The user and account may be specified explicitly via path parameters or
        implicitly via the authentication context. Explicitly specified values
        take precedence.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersRead
      parameters:
        - *ref_1
        - *ref_36
      responses:
        '200': &ref_241
          description: Notification rules returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_41
                  title: NotificationsRule
                  type: object
                  properties:
                    id:
                      type: string
                      format: uuid
                      example: 49a4f165-8233-426b-a1a4-e569665a25dd
                      readOnly: true
                    accountID:
                      type: string
                      format: uuid
                      example: 49a4f165-8233-426b-a1a4-e569665a25dd
                      readOnly: true
                    userID:
                      type: string
                      format: uuid
                      example: 49a4f165-8233-426b-a1a4-e569665a25dd
                      readOnly: true
                    eventType:
                      type: string
                    filters:
                      type: array
                      items: &ref_266
                        title: Filter
                        type: object
                        properties:
                          name:
                            type: string
                          condition:
                            type: string
                    notificationType: &ref_267
                      title: NotificationType
                      type: object
                      properties:
                        email:
                          type: object
                          properties:
                            address:
                              type: string
                        sms:
                          type: object
                          properties:
                            phonenumber:
                              type: string
                        dashboardNotification:
                          type: object
                          properties:
                            userID:
                              type: string
                        webhook:
                          type: object
                          properties:
                            targetURL:
                              type: string
                        mobile:
                          type: object
                          properties:
                            appName:
                              type: string
                            os:
                              type: string
                            deviceToken:
                              type: string
                    locale:
                      type: string
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a Rule
      description: >
        Creates a new rule.


        The user and account may be specified explicitly via path parameters or
        implicitly via the authentication context. Explicitly specified values
        take precedence.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - *ref_36
      requestBody: &ref_195
        description: Creates a notification rule.
        required: true
        content:
          application/json:
            schema: &ref_44
              allOf:
                - *ref_41
                - additionalProperties: false
      responses:
        '201': &ref_42
          description: Notifications rule returned.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_41
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules\"\n\n\tpayload := strings.NewReader(\"{\\\"eventType\\\":\\\"string\\\",\\\"filters\\\":[{\\\"name\\\":\\\"string\\\",\\\"condition\\\":\\\"string\\\"}],\\\"notificationType\\\":{\\\"email\\\":{\\\"address\\\":\\\"string\\\"},\\\"sms\\\":{\\\"phonenumber\\\":\\\"string\\\"},\\\"dashboardNotification\\\":{\\\"userID\\\":\\\"string\\\"},\\\"webhook\\\":{\\\"targetURL\\\":\\\"string\\\"},\\\"mobile\\\":{\\\"appName\\\":\\\"string\\\",\\\"os\\\":\\\"string\\\",\\\"deviceToken\\\":\\\"string\\\"}},\\\"locale\\\":\\\"string\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "eventType": "string",
              "filters": [
                {
                  "name": "string",
                  "condition": "string"
                }
              ],
              "notificationType": {
                "email": {
                  "address": "string"
                },
                "sms": {
                  "phonenumber": "string"
                },
                "dashboardNotification": {
                  "userID": "string"
                },
                "webhook": {
                  "targetURL": "string"
                },
                "mobile": {
                  "appName": "string",
                  "os": "string",
                  "deviceToken": "string"
                }
              },
              "locale": "string"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              eventType: 'string',
              filters: [{name: 'string', condition: 'string'}],
              notificationType: {
                email: {address: 'string'},
                sms: {phonenumber: 'string'},
                dashboardNotification: {userID: 'string'},
                webhook: {targetURL: 'string'},
                mobile: {appName: 'string', os: 'string', deviceToken: 'string'}
              },
              locale: 'string'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                eventType: 'string',
                filters: [{name: 'string', condition: 'string'}],
                notificationType: {
                  email: {address: 'string'},
                  sms: {phonenumber: 'string'},
                  dashboardNotification: {userID: 'string'},
                  webhook: {targetURL: 'string'},
                  mobile: {appName: 'string', os: 'string', deviceToken: 'string'}
                },
                locale: 'string'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "eventType": "string",
              "filters": [
                {
                  "name": "string",
                  "condition": "string"
                }
              ],
              "notificationType": {
                "email": {
                  "address": "string"
                },
                "sms": {
                  "phonenumber": "string"
                },
                "dashboardNotification": {
                  "userID": "string"
                },
                "webhook": {
                  "targetURL": "string"
                },
                "mobile": {
                  "appName": "string",
                  "os": "string",
                  "deviceToken": "string"
                }
              },
              "locale": "string"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"eventType": @"string",
                                          @"filters": @[ @{ @"name": @"string", @"condition": @"string" } ],
                                          @"notificationType": @{ @"email": @{ @"address": @"string" }, @"sms": @{ @"phonenumber": @"string" }, @"dashboardNotification": @{ @"userID": @"string" }, @"webhook": @{ @"targetURL": @"string" }, @"mobile": @{ @"appName": @"string", @"os": @"string", @"deviceToken": @"string" } },
                                          @"locale": @"string" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules"


            payload = {
                "eventType": "string",
                "filters": [
                    {
                        "name": "string",
                        "condition": "string"
                    }
                ],
                "notificationType": {
                    "email": {"address": "string"},
                    "sms": {"phonenumber": "string"},
                    "dashboardNotification": {"userID": "string"},
                    "webhook": {"targetURL": "string"},
                    "mobile": {
                        "appName": "string",
                        "os": "string",
                        "deviceToken": "string"
                    }
                },
                "locale": "string"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}'
            |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "eventType": "string",
              "filters": [
                [
                  "name": "string",
                  "condition": "string"
                ]
              ],
              "notificationType": [
                "email": ["address": "string"],
                "sms": ["phonenumber": "string"],
                "dashboardNotification": ["userID": "string"],
                "webhook": ["targetURL": "string"],
                "mobile": [
                  "appName": "string",
                  "os": "string",
                  "deviceToken": "string"
                ]
              ],
              "locale": "string"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/users/{userID}/notifications/rules/{ruleID}':
    get:
      summary: Retrieve a Rule
      description: >
        Returns a rule specified by its ID.


        The user and account may be specified explicitly via path parameters or
        implicitly via the authentication context. Explicitly specified values
        take precedence.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersRead
      parameters:
        - *ref_1
        - *ref_36
        - &ref_43
          name: ruleID
          description: |
            Unique identifier that can be used to access notification rules.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': *ref_42
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    put:
      summary: Update a Rule
      description: >
        Updates a rule specified by its ID.


        The user and account may be specified explicitly via path parameters or
        implicitly via the authentication context. Explicitly specified values
        take precedence.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - *ref_36
        - *ref_43
      requestBody: &ref_194
        description: Updates a notification rule.
        required: true
        content:
          application/json:
            schema: *ref_44
      responses:
        '204':
          description: Notification rule updated successfully.
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"eventType\\\":\\\"string\\\",\\\"filters\\\":[{\\\"name\\\":\\\"string\\\",\\\"condition\\\":\\\"string\\\"}],\\\"notificationType\\\":{\\\"email\\\":{\\\"address\\\":\\\"string\\\"},\\\"sms\\\":{\\\"phonenumber\\\":\\\"string\\\"},\\\"dashboardNotification\\\":{\\\"userID\\\":\\\"string\\\"},\\\"webhook\\\":{\\\"targetURL\\\":\\\"string\\\"},\\\"mobile\\\":{\\\"appName\\\":\\\"string\\\",\\\"os\\\":\\\"string\\\",\\\"deviceToken\\\":\\\"string\\\"}},\\\"locale\\\":\\\"string\\\"}\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")
              .put(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "eventType": "string",
              "filters": [
                {
                  "name": "string",
                  "condition": "string"
                }
              ],
              "notificationType": {
                "email": {
                  "address": "string"
                },
                "sms": {
                  "phonenumber": "string"
                },
                "dashboardNotification": {
                  "userID": "string"
                },
                "webhook": {
                  "targetURL": "string"
                },
                "mobile": {
                  "appName": "string",
                  "os": "string",
                  "deviceToken": "string"
                }
              },
              "locale": "string"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              eventType: 'string',
              filters: [{name: 'string', condition: 'string'}],
              notificationType: {
                email: {address: 'string'},
                sms: {phonenumber: 'string'},
                dashboardNotification: {userID: 'string'},
                webhook: {targetURL: 'string'},
                mobile: {appName: 'string', os: 'string', deviceToken: 'string'}
              },
              locale: 'string'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                eventType: 'string',
                filters: [{name: 'string', condition: 'string'}],
                notificationType: {
                  email: {address: 'string'},
                  sms: {phonenumber: 'string'},
                  dashboardNotification: {userID: 'string'},
                  webhook: {targetURL: 'string'},
                  mobile: {appName: 'string', os: 'string', deviceToken: 'string'}
                },
                locale: 'string'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "eventType": "string",
              "filters": [
                {
                  "name": "string",
                  "condition": "string"
                }
              ],
              "notificationType": {
                "email": {
                  "address": "string"
                },
                "sms": {
                  "phonenumber": "string"
                },
                "dashboardNotification": {
                  "userID": "string"
                },
                "webhook": {
                  "targetURL": "string"
                },
                "mobile": {
                  "appName": "string",
                  "os": "string",
                  "deviceToken": "string"
                }
              },
              "locale": "string"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"eventType": @"string",
                                          @"filters": @[ @{ @"name": @"string", @"condition": @"string" } ],
                                          @"notificationType": @{ @"email": @{ @"address": @"string" }, @"sms": @{ @"phonenumber": @"string" }, @"dashboardNotification": @{ @"userID": @"string" }, @"webhook": @{ @"targetURL": @"string" }, @"mobile": @{ @"appName": @"string", @"os": @"string", @"deviceToken": @"string" } },
                                          @"locale": @"string" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"
            in


            Client.call ~headers ~body `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_POSTFIELDS => "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D');

            $request->setRequestMethod('PUT');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PUT",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"


            payload = {
                "eventType": "string",
                "filters": [
                    {
                        "name": "string",
                        "condition": "string"
                    }
                ],
                "notificationType": {
                    "email": {"address": "string"},
                    "sms": {"phonenumber": "string"},
                    "dashboardNotification": {"userID": "string"},
                    "webhook": {"targetURL": "string"},
                    "mobile": {
                        "appName": "string",
                        "os": "string",
                        "deviceToken": "string"
                    }
                },
                "locale": "string"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PUT", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"eventType\":\"string\",\"filters\":[{\"name\":\"string\",\"condition\":\"string\"}],\"notificationType\":{\"email\":{\"address\":\"string\"},\"sms\":{\"phonenumber\":\"string\"},\"dashboardNotification\":{\"userID\":\"string\"},\"webhook\":{\"targetURL\":\"string\"},\"mobile\":{\"appName\":\"string\",\"os\":\"string\",\"deviceToken\":\"string\"}},\"locale\":\"string\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}'
            |  \
              http PUT https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"eventType":"string","filters":[{"name":"string","condition":"string"}],"notificationType":{"email":{"address":"string"},"sms":{"phonenumber":"string"},"dashboardNotification":{"userID":"string"},"webhook":{"targetURL":"string"},"mobile":{"appName":"string","os":"string","deviceToken":"string"}},"locale":"string"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "eventType": "string",
              "filters": [
                [
                  "name": "string",
                  "condition": "string"
                ]
              ],
              "notificationType": [
                "email": ["address": "string"],
                "sms": ["phonenumber": "string"],
                "dashboardNotification": ["userID": "string"],
                "webhook": ["targetURL": "string"],
                "mobile": [
                  "appName": "string",
                  "os": "string",
                  "deviceToken": "string"
                ]
              ],
              "locale": "string"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete a Rule
      description: >
        Deletes a rule specified by its ID.


        The user and account may be specified explicitly via path parameters or
        implicitly via the authentication context. Explicitly specified values
        take precedence.
      tags:
        - Notification
      security:
        - BearerAuth:
            - AccountsUsersWrite
      parameters:
        - *ref_1
        - *ref_36
        - *ref_43
      responses:
        '204':
          description: Notification rule deleted successfully.
        '403': *ref_11
        '404': &ref_55
          description: Requested entity not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/users/%7BuserID%7D/notifications/rules/%7BruleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/plans':
    get:
      summary: List Charge Plans
      description: |
        Lists all available charge plans.
      tags:
        - Plan
      security:
        - BearerAuth:
            - PlansRead
      parameters:
        - *ref_1
        - *ref_17
        - *ref_18
      responses:
        '200': &ref_242
          description: Charge plans returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_45
                  title: ChargePlan
                  type: object
                  properties:
                    id:
                      type: string
                      format: uuid
                      example: 49a4f165-8233-426b-a1a4-e569665a25dd
                      readOnly: true
                    name:
                      type: string
                    description:
                      type: string
                    createdAt:
                      type: string
                      format: date-time
                      readOnly: true
                    updatedAt:
                      type: string
                      format: date-time
                      readOnly: true
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/plans',
              qs: {per_page: 'SOME_INTEGER_VALUE', page: 'SOME_INTEGER_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans");


            req.query({
              "per_page": "SOME_INTEGER_VALUE",
              "page": "SOME_INTEGER_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/plans');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/plans');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/accounts/%7BaccountID%7D/plans"


            querystring =
            {"per_page":"SOME_INTEGER_VALUE","page":"SOME_INTEGER_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/plans/{planID}':
    post:
      summary: Assign Charge Plan.
      description: |
        Assign charge plan to account.
      tags:
        - Plan
      security:
        - BearerAuth:
            - PlansWrite
      parameters:
        - *ref_1
        - &ref_46
          name: planID
          description: |
            Unique identifier that can be used to access charge plans.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': &ref_243
          description: Charge plans assigned to account.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_45
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");

            var request = new RestRequest(Method.POST);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")
              .post(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D');

            $request->setRequestMethod('POST');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("POST", "/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("POST", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http POST
            https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Unassign Charge Plan.
      description: |
        Unassign charge plan from account.
      tags:
        - Plan
      security:
        - BearerAuth:
            - PlansWrite
      parameters:
        - *ref_1
        - *ref_46
      responses:
        '204':
          description: Charge plan unassigned.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/plans/%7BplanID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/plans/%7BplanID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/rfidtags/{tagID}':
    get:
      summary: Get RFID Tag
      description: |
        Gets RFID tag for account.
      tags:
        - RFIDTag
      security:
        - BearerAuth:
            - RFIDTagsRead
      parameters:
        - *ref_1
        - &ref_47
          name: tagID
          description: |
            Unique identifier that can be used to access RFID tags.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': &ref_244
          description: RFID tag returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_48
                title: RFIDTag
                type: object
                properties:
                  tagID:
                    type: string
                    format: uuid
                    example: 49a4f165-8233-426b-a1a4-e569665a25dd
                    readOnly: true
                  accountID:
                    type: string
                    format: uuid
                    example: 49a4f165-8233-426b-a1a4-e569665a25dd
                    readOnly: true
                  name:
                    type: string
                  createdAt:
                    type: string
                    format: date-time
                    readOnly: true
                  updatedAt:
                    type: string
                    format: date-time
                    readOnly: true
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update RFID Tag
      description: |
        Updates RFID tag for account.
      tags:
        - RFIDTag
        - Account
      security:
        - BearerAuth:
            - RFIDTagsWrite
      parameters:
        - *ref_1
        - *ref_47
      requestBody: &ref_199
        description: Updates RFID tag.
        required: true
        content:
          application/json:
            schema: &ref_198
              allOf:
                - *ref_48
                - additionalProperties: false
      responses:
        '200': &ref_245
          description: RFID tag updated.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_48
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"string\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"string\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"string\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":\"string\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"string\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "string"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({name: 'string'}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {name: 'string'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "string"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"string" };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"string\"}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"string\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"string"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"string"}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"string\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"


            payload = {"name": "string"}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"string\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"string"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"name":"string"}' |  \
              http PATCH https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"string"}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["name": "string"] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete RFID Tag
      description: |
        Deletes RFID tag for account.
      tags:
        - RFIDTag
      security:
        - BearerAuth:
            - RFIDTagsWrite
      parameters:
        - *ref_1
        - *ref_47
      responses:
        '204':
          description: RFID tag deleted successfully.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/rfidtags/{tagID}/appliances':
    get:
      summary: List Appliances by RFID Tag
      description: |
        Lists all appliances by RFID tag for account.
      tags:
        - RFIDTag
      security:
        - BearerAuth:
            - RFIDTagsRead
      parameters:
        - *ref_1
        - *ref_47
        - *ref_17
        - *ref_18
      responses:
        '200': &ref_246
          description: Appliances by RFID tag returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_62
                  title: Appliance
                  description: >
                    Appliance represents a monitor-/controllable device such as
                    Inverters,

                    Meters and Heat Pumps.
                  readOnly: true
                  oneOf:
                    - &ref_327
                      title: Inverter
                      description: >
                        Inverter represents a monitor-/controllable inverter. It
                        can be of kind:

                        - `PV`/`PV_EXTERNAL`: used as photovoltaic only.

                        - `BATTERY`: used as battery only.

                        - `HYBRID`: used as both photovoltaic and battery.

                        - `UNKNOWN`: default, when the inverter kind is not
                        determined.
                      allOf:
                        - &ref_51
                          title: Base Appliance
                          description: >
                            BaseAppliance contains fields that all appliances
                            have in common.


                            Specific appliance types extend this schema and add
                            new fields.
                          type: object
                          required:
                            - id
                            - inactive
                            - createdAt
                            - updatedAt
                            - type
                            - position
                            - reverseFlow
                            - connectionStatus
                            - state
                          properties:
                            id:
                              type: string
                              format: uuid
                              example: ec4d0c89-a604-49ac-82f0-427f9cb42204
                              description: Uniquely identifies the appliance.
                            createdAt:
                              type: string
                              format: date-time
                              description: Specifies when the appliance was created.
                            updatedAt:
                              type: string
                              format: date-time
                              description: >-
                                Specifies when the appliance was updated the
                                last time.
                            connectionStatus: &ref_316
                              title: Appliance connection status
                              type: object
                              readOnly: true
                              required:
                                - status
                              properties:
                                status:
                                  type: string
                                  description: >
                                    Indicates the connection status of an
                                    appliance.
                                        
                                    The connection status of an appliance is
                                    determined by the gateway. The gateway
                                    regularly

                                    sends the connection status of all connected
                                    appliances.


                                    It is one of:

                                    - `AVAILABLE`: Appliance was reported as
                                    available by the gateway.

                                    - `UNAVAILABLE`: Appliance was reported as
                                    unavailable by the gateway.

                                    - `UNKNOWN`: The gateway didn't report a
                                    status for the appliance.


                                    In case the connection status of the gateway
                                    this appliance belongs to is
                                    `TEMPORARILY_UNAVAILABLE` or `UNAVAILABLE`

                                    the status is always `UNAVAILABLE`. 
                                  enum:
                                    - AVAILABLE
                                    - UNAVAILABLE
                                    - UNKNOWN
                                contactedAt:
                                  type: string
                                  format: date-time
                                  deprecated: true
                                  description: >
                                    No longer supported. 


                                    Will be set approximately to a value
                                    matching the status field.

                                    If the appliance is `AVAILABLE`, it will be
                                    the current datetime.

                                    If the appliance is `UNAVAILABLE`, it will
                                    be a datetime 24 hours in the past. 
                            status: &ref_317
                              description: >
                                Status of the appliance. This field is set
                                dynamically in the appliance handler.


                                **Deprecated** - Use `ConnectionStatus` instead.
                              type: string
                              enum:
                                - UNDEFINED
                                - OK
                                - WARNING
                                - ERROR
                              deprecated: true
                            type: &ref_95
                              type: string
                              example: INVERTER
                              description: >
                                Describes the 'physical' type of the appliance.


                                See `kind` for further distinction of the type
                                in terms of the appliance's purpose/role,

                                e.g. appliance with type=INVERTER and
                                kind=BATTERY represents a battery inverter.
                              x-go-type-skip-optional-pointer: true
                            inactive: &ref_93
                              type: boolean
                            name: &ref_94
                              type: string
                              description: Name of the appliance.
                            reverseFlow: &ref_114
                              description: >
                                If true, changes the energy flow's direction.


                                If during installation the input/output wiring
                                is mixed up, set it to true in order to
                                compensate for that.

                                This impact the consumption/production
                                calculation as follows: 

                                It switches the algebraic sign of the
                                appliance's measurements, e.g. if an appliance
                                measurement showed supply (+), it will change to
                                feed-in (-) after this field is set to true (and
                                vice versa).
                              type: boolean
                            room: &ref_115
                              type: string
                              description: >-
                                The physical room/location of the appliance in
                                the building.
                            serialnumber: &ref_101
                              type: string
                              example: '1901000652'
                              description: Serialnumber of the appliance.
                            network: &ref_96
                              title: Network
                              description: Represents a network connection.
                              type: object
                              properties:
                                interface:
                                  type: string
                                  example: eth0
                                  description: >-
                                    Used network interface such as "eth0",
                                    "vpn0" etc.
                                address:
                                  type: string
                                  example: 192.168.178.153
                                  description: IP address of the device.
                                port:
                                  type: integer
                                  format: int32
                                  example: 0
                                  description: Port used for the connection.
                                protocol:
                                  type: string
                                  example: tcp/modbus
                                  description: Protocol used for the connection.
                            parent: &ref_100
                              type: string
                              format: uuid
                              description: >-
                                Specifies the parent appliance ID, for an
                                appliance which is a child of a `CONTAINER` or
                                `INVERTER` of kind `HYBRID`.
                            loadSettings: &ref_97
                              title: Load Settings
                              description: Configure load of appliance.
                              type: object
                              required:
                                - disabled
                              properties:
                                disabled:
                                  type: boolean
                                  description: >-
                                    If true, disable electrical load of the
                                    appliance (e.g. stops charging for EV
                                    charging station).
                            sensorSettings: &ref_318
                              title: Sensor Settings
                              type: object
                              allOf:
                                - &ref_98
                                  title: Sensor Settings
                                  type: object
                                  properties:
                                    sensorL1:
                                      type: integer
                                    sensorL2:
                                      type: integer
                                    sensorL3:
                                      type: integer
                                - required:
                                    - createdAt
                                    - updatedAt
                                  properties:
                                    createdAt:
                                      type: string
                                      format: date-time
                                    updatedAt:
                                      type: string
                                      format: date-time
                            source: &ref_319
                              title: Source
                              type: object
                              required:
                                - origin
                              properties:
                                origin:
                                  type: string
                                  description: >
                                    Specifies who created the appliance. This
                                    can be one of:

                                    - `GRIDBOX` if the appliance was found
                                    during a scan using a gridBox.

                                    - `API` if a user of the gridX API used the
                                    'Create Appliance' endpoint
                                      to create this appliance.
                                    - `UNKNOWN` otherwise.
                                  enum:
                                    - UNKNOWN
                                    - GRIDBOX
                                    - API
                                  example: API
                                uri:
                                  type: string
                                  description: >
                                    Contains an URI identifying the exact
                                    resource that created this appliance.


                                    If origin is 'GRID_BOX' the value will point
                                    to the gateway object of the gridBox. If

                                    origin is 'API' the value will specify the
                                    user that made the request to the gridX API.

                                    The 'UNKNOWN' origin should not occur in
                                    practice and is reserved for special cases
                                    (for now).
                                  example: >-
                                    accounts/b30510fa-a8a5-475f-a75d-82a46cb62582/users/b30510fa-a8a5-475f-a75d-82a46cb62582
                            commissioningKind: &ref_320
                              title: Commissioning Kind
                              description: >
                                Indicates special requirements to be fulfilled
                                during the commissioning for this appliance.


                                If empty or unset (default), the appliance can
                                be commissioned as regular.

                                - `property:CryptoSettings` means that the
                                appliance property `CryptoSettings` needs to be
                                set, e.g. for authenticating towards it with an
                                appliance-specific API token.

                                - `flow:Pairing` means that a coupling or
                                pairing flow has to be initiated and run-through
                                in order for the appliance to behave correctly.
                              type: string
                              enum:
                                - 'property:CryptoSettings'
                                - 'flow:Pairing'
                            state: &ref_322
                              title: State
                              description: >-
                                Contains information about the appliance's
                                state.
                              type: object
                              allOf:
                                - &ref_99
                                  title: State
                                  description: >-
                                    Contains information about the appliance's
                                    state.
                                  type: object
                                  properties:
                                    current:
                                      description: The state the appliance is currently in.
                                      example: SCANNED
                                      title: Appliance State
                                      type: string
                                      enum: &ref_49
                                        - UNKNOWN_APPLIANCE_STATE
                                        - SCANNED
                                        - CONNECTING
                                        - VERIFYING
                                        - UNTRUSTED
                                        - CONNECTED
                                        - DISCONNECTED
                                    transitions:
                                      description: >
                                        List with all the possible state
                                        transitions an appliance can go
                                        through. 

                                        An appliance can go from a `starting`
                                        state to a `target` state.
                                      type: array
                                      items: &ref_321
                                        title: State Transition
                                        description: >-
                                          Defines the properties of a transition
                                          an appliance can go through.
                                        type: object
                                        required:
                                          - start
                                          - target
                                        properties:
                                          start:
                                            description: The starting state of the appliance.
                                            example: CONNECTING
                                            title: Appliance State
                                            type: string
                                            enum: *ref_49
                                          target:
                                            description: The target state of the appliance.
                                            example: DISCONNECTED
                                            title: Appliance State
                                            type: string
                                            enum: *ref_49
                                - required:
                                    - current
                                    - desired
                                  properties:
                                    desired: &ref_118
                                      title: Appliance State
                                      description: State an appliance can be in.
                                      type: string
                                      enum: *ref_49
                            energySettings: &ref_323
                              title: Energy Management Settings
                              description: Contains energy management information
                              type: object
                              allOf:
                                - &ref_103
                                  title: Energy Management Settings
                                  description: Contains energy management information
                                  type: object
                                  properties:
                                    minControlInterval:
                                      type: integer
                                    socMax:
                                      description: >
                                        The maximum state of charge an energy
                                        storage can be charged to in a range
                                        from [0-100] in %.
                                      type: number
                                      format: double
                                      minimum: 0
                                      maximum: 100
                                    socLockMax:
                                      description: >
                                        The threshold above which no charging is
                                        allowed once SoC max is reached, in a
                                        range from [0-100] in %.

                                        Must be smaller than or equal to socMax.
                                      type: number
                                      format: double
                                      minimum: 0
                                      maximum: 100
                                    socMin:
                                      description: >
                                        The minimum state of charge an energy
                                        storage can be discharged to in a range
                                        from [0-100] in %.
                                      type: number
                                      format: double
                                      minimum: 0
                                      maximum: 100
                                    socLockMin:
                                      description: >
                                        The threshold below which no discharging
                                        is allowed once SoC min is reached, in a
                                        range from [0-100] in %.

                                        Must be larger than or equal to socMin.
                                      type: number
                                      format: double
                                      minimum: 0
                                      maximum: 100
                                    socDeepDischarge:
                                      description: >
                                        The lowest state of charge an energy
                                        storage can reach, in a range from
                                        [0-100] in %.

                                        Below this it is not usable and a forced
                                        recharge to at least socMin is required.
                                      type: number
                                      format: double
                                      minimum: 0
                                      maximum: 100
                                    phaseMapping:
                                      description: >
                                        Contains three indices representing the
                                        actual phases on the grid connection
                                        point this appliance is connected to. 

                                        Note that the first phase has index 0
                                        and last phase index 2.

                                        The index of the sequence is the phase
                                        on the gcp and the values are the
                                        appliance phases. Unused phases are
                                        marked with -1.
                                      type: array
                                      nullable: true
                                      minItems: 3
                                      maxItems: 3
                                      items:
                                        type: integer
                                    temperatureExtremeMax:
                                      description: >
                                        The temperature to which the system
                                        should be heated up to in °C, if there
                                        is an energy surplus.
                                      type: number
                                      format: double
                                    temperatureExtremeMin:
                                      description: >
                                        The minimum temperature the system can
                                        reach in °C.
                                      type: number
                                      format: double
                                    temperatureComfortMax:
                                      description: >
                                        The temperature to which the system
                                        should be heated up to in °C, if there
                                        is no energy surplus.
                                      type: number
                                      format: double
                                    temperatureComfortMin:
                                      description: >
                                        The temperature at which the system
                                        starts to heat up to in °C.
                                      type: number
                                      format: double
                                    surplusThreshold:
                                      description: >-
                                        The supply surplus threshold for the EMS
                                        to activate the appliance.
                                      type: integer
                                - required:
                                    - updatedAt
                                  properties:
                                    updatedAt:
                                      description: >-
                                        Specifies when the energy management
                                        settings were updated the last time.
                                      type: string
                                      format: date-time
                            cryptoSettings:
                              title: Crypto Settings
                              description: >-
                                Contains a list of crypto setting keys that are
                                associated with the appliance.
                              type: array
                              items: &ref_324
                                type: object
                                allOf:
                                  - &ref_102
                                    type: object
                                    required:
                                      - key
                                    properties:
                                      key:
                                        description: >-
                                          Crypto key data that is accessible to
                                          the appliance.
                                        type: string
                                  - properties:
                                      createdAt:
                                        type: string
                                        format: date-time
                                        description: >-
                                          Specifies when the crypto key was
                                          created.
                                      updatedAt:
                                        type: string
                                        format: date-time
                                        description: >-
                                          Specifies when the crypto key was
                                          updated the last time.
                        - &ref_104
                          type: object
                          properties:
                            type:
                              enum:
                                - INVERTER
                              type: string
                              x-go-type-skip-optional-pointer: true
                            kind: &ref_325
                              description: >
                                Indicates the role of the inverter.


                                Setting the kind impacts the system
                                measurements. So it's best to set it up
                                correctly as early as possible

                                in accordance to the actual installation in
                                order for the measurement calculation to be
                                correct (best during commissioning).
                              type: string
                              enum:
                                - UNKNOWN
                                - PV
                                - PV_EXTERNAL
                                - BATTERY
                                - HYBRID
                            manufacturer:
                              type: string
                              example: SMA
                              description: Manufacturer of the appliance.
                            model:
                              type: string
                              example: Sunny Boy Storage 2.5
                              description: Model of the appliance.
                            firmware:
                              type: string
                              example: 2.4.23.R
                              description: Firmware version of the appliance.
                            inverter:
                              type: object
                              description: The inverter specific information.
                              properties:
                                maxActivePowerOutput:
                                  description: >-
                                    Maximum active power output of the inverter
                                    in mW; set manually. Zero if not set.
                                  type: integer
                                type:
                                  description: Describes the specific type of the inverter.
                                  type: string
                                  example: SUNGROW_SG_20_RT
                            nominalPowerLimit:
                              description: >-
                                Designed maximal power output of the inverter in
                                mW.
                              type: integer
                            hybridCalcMode:
                              description: >-
                                The calculation mode for inverters of HYBRID
                                kind.
                              type: integer
                              enum:
                                - 0
                                - 1
                                - 2
                              example: 0
                            battery: &ref_50
                              title: Battery Information
                              type: object
                              description: >-
                                The battery specific information for inverters
                                of BATTERY and HYBRID kind.
                              properties:
                                maxCharge:
                                  type: integer
                                  title: Battery's maximum charge
                                  format: int64
                                  minimum: 0
                                  example: 501
                                maxDischarge:
                                  type: integer
                                  title: Battery's maximum discharge
                                  format: int64
                                  minimum: 0
                                  example: 501
                                controllable:
                                  type: boolean
                                  description: >-
                                    Controllable is true if the battery
                                    charging/discharging can be controlled.
                                dischargeLimit:
                                  type: integer
                                  description: >-
                                    DischargeLimit is the minimum state of
                                    charge in % from 0-100 to discharge to.
                                rechargeLimit:
                                  type: integer
                                  description: >
                                    RechargeLimit is the state of charge in %
                                    from 0-100 to which the battery needs to 

                                    recharge before allowing discharging again.
                                controlSettings:
                                  type: object
                                  description: >-
                                    Indicates the currently desired control
                                    settings for the battery.
                                  required:
                                    - value
                                    - command
                                  properties:
                                    value:
                                      type: integer
                                      description: >-
                                        Represents the charge/discharge power in
                                        mW.
                                    command:
                                      type: string
                                      description: Represents the current control command.
                                      enum:
                                        - none
                                        - charge
                                        - discharge
                        - required:
                            - kind
                            - inverter
                          properties:
                            hardwareStatus: &ref_120
                              title: Hardware Status
                              type: object
                              description: >
                                HardwareStatus provides information about the
                                condition of the inverter and in case of
                                issues, 

                                possible follow-up actions the user/installer
                                can perform to resolve them.
                              properties:
                                state:
                                  type: string
                                  enum:
                                    - UNKNOWN
                                    - OK
                                    - WARNING
                                    - ERROR
                                  description: State of the inverter.
                                action:
                                  type: string
                                  description: >-
                                    Recommended action to resolve ERROR/WARNING
                                    state.
                                  enum:
                                    - CONSULT_DEVICE_READOUT
                                    - CONTACT_INSTALLER
                                    - CONTACT_MANUFACTURER
                                    - CONTACT_GRID_OPERATOR
                                errorCode:
                                  type: string
                                  description: >-
                                    Inverter manufacturer/model dependent error
                                    code formatted as it would be shown on
                                    display.
                                description:
                                  type: string
                                  description: >-
                                    Contains details about the inverter ERROR
                                    and WARNING states.
                                  enum:
                                    - OTHER
                                    - GRID_FAULT
                                    - INSULATION_FAILURE
                                    - INTERFERENCE_DEVICE
                                    - FAN_FAULT
                                    - WAIT_FOR_UPDATE
                                    - SOFTWARE_FAULT
                                    - HARDWARE_FAULT
                                    - PARAMETER_FAULT
                                    - HIGH_TEMPERATURE
                                    - HIGH_DC_VOLTAGE
                                    - LOW_DC_POWER
                                    - DC_OVERCURRENT
                                    - INSTALLATION_FAULT
                                    - COMMUNICATION_FAULT
                                    - BATTERY_FAULT
                                measuredAt:
                                  type: string
                                  format: date-time
                                  example: '2018-04-15T00:00:00Z'
                            inverter:
                              required:
                                - type
                            battery: &ref_326
                              title: Battery Information
                              type: object
                              description: >-
                                The battery specific information for inverters
                                of BATTERY and HYBRID kind.
                              allOf:
                                - *ref_50
                                - required:
                                    - controllable
                    - &ref_329
                      title: Meter
                      description: Meter represents a monitor-/controllable meter.
                      allOf:
                        - *ref_51
                        - &ref_106
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - METER
                              x-go-type-skip-optional-pointer: true
                            model:
                              type: string
                              example: B-control Energy Manager 300
                              description: Model of the meter.
                            firmware:
                              type: string
                              example: '2.03'
                              description: Firmware version of the meter.
                            auxMeter:
                              type: object
                              description: The meter specific information.
                              properties:
                                location:
                                  type: string
                                  enum:
                                    - UNKNOWN
                                    - PV
                                    - GRID
                                    - BATTERY
                                    - HEAT_PUMP
                                    - FUEL_CELL
                                    - HEAT_PUMP_EXTERNAL
                                    - EVSTATION
                                    - PV_EXTERNAL
                                    - BTTP
                                    - HEATING
                                    - MISC
                                    - CLUSTER
                                    - WIND_TURBINE
                                  description: >
                                    Indicates that the meter is in front of
                                    given location for measuring the consumption
                                    and production.
                                type:
                                  description: Describes the specific type of the meter.
                                  type: string
                                  example: SE_SINGLE_PHASE
                                modbusAddress:
                                  type: integer
                        - type: object
                          required:
                            - auxMeter
                            - kind
                          properties:
                            kind: &ref_328
                              description: >-
                                Indicates what the meter measures.

                                Setting the kind impacts the system
                                measurements. So it's best to set it up
                                correctly as early as possible in accordance to
                                the actual installation in order for the
                                measurement calculation to be correct (best
                                during commissioning).
                              type: string
                              enum:
                                - UNKNOWN
                                - PV
                                - GRID
                                - BATTERY
                                - HEAT_PUMP
                                - FUEL_CELL
                                - HEAT_PUMP_EXTERNAL
                                - EVSTATION
                                - PV_EXTERNAL
                                - BTTP
                                - HEATING
                                - MISC
                                - CLUSTER
                                - WIND_TURBINE
                            manufacturer:
                              type: string
                              example: TQ Systems
                              description: Manufacturer of the meter.
                            auxMeter:
                              required:
                                - location
                                - type
                    - &ref_331
                      title: Heat Pump
                      description: Heat Pump represents a monitor-/controllable heat pump.
                      allOf:
                        - *ref_51
                        - &ref_108
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - HEAT_PUMP
                              x-go-type-skip-optional-pointer: true
                            manufacturer:
                              type: string
                              example: Stiebel Eltron
                              description: Manufacturer of the heat pump.
                            model:
                              type: string
                              example: WPMsystem
                              description: Model of the heat pump.
                            firmware:
                              type: string
                              example: 'mac_02:80:ad:24:d5:ab'
                              description: Firmware version of the heat pump.
                            heatPump: &ref_52
                              title: Heat Pump Information
                              description: The heat pump specific information.
                              type: object
                              properties:
                                type:
                                  description: >-
                                    Describes the specific type of the heat
                                    pump.
                                  type: string
                                  enum:
                                    - UNKNOWN
                                    - EEBUS
                                    - SIMULATION
                                    - INNOTEC
                                    - XNET_CLOUD
                                    - EXT_IO_DEVICE
                                    - EXT_IO_DEVICE_DHW
                                    - STIEBEL_ELTRON_WPMSYSTEM
                                    - SAIA_PCD_E_LINE
                                    - DAIKIN_HOMEHUB
                                controllable:
                                  description: >-
                                    Specifies whether this appliance is
                                    controllable by the EMS.
                                  type: boolean
                                behindGCP:
                                  description: >-
                                    Specifies whether this heat pump exists
                                    behind a GCP meter.
                                  type: boolean
                                withOwnTariff:
                                  description: >-
                                    Specifies whether this heat pump has its own
                                    meter and tariff.
                                  type: boolean
                                userControlEnabled:
                                  description: >-
                                    Specifies whether EMS control of this
                                    appliance is enabled by the user.
                                  type: boolean
                        - required:
                            - heatPump
                          properties:
                            heatPump: &ref_330
                              title: Heat Pump Information
                              description: The heat pump specific information.
                              type: object
                              allOf:
                                - *ref_52
                                - required:
                                    - type
                                    - controllable
                                    - behindGCP
                                    - withOwnTariff
                                    - userControlEnabled
                    - &ref_332
                      title: EV Charging Station
                      description: >
                        EV Charging Station represents a monitor-/controllable
                        electric vehicle charging station.
                      allOf:
                        - *ref_51
                        - &ref_107
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - EVSTATION
                              x-go-type-skip-optional-pointer: true
                            manufacturer:
                              type: string
                              example: Echarge Hardy Barth
                              description: Manufacturer of the ev charging station.
                            model:
                              type: string
                              example: eCHARGE/PV
                              description: Model of the ev charging station.
                            firmware:
                              type: string
                              example: 0.38-78000001
                              description: Firmware version of the ev charging station.
                            evseID: &ref_117
                              description: The EVSE-ID related to the charge point.
                              type: string
                            evLoadManagementParameters: &ref_116
                              title: EvLoadManagementParameters
                              description: >
                                Load management configuration for EV charging
                                stations.


                                **Deprecated** - Use the system's EV charging
                                station configuration instead.
                              deprecated: true
                              type: object
                              properties:
                                enabled:
                                  description: >-
                                    Indicates whether the load management is
                                    enabled.
                                  type: boolean
                                maxPower:
                                  description: The maximum power in W.
                                  type: number
                                  format: double
                                  minimum: 0
                    - &ref_333
                      title: Heat Meter
                      description: >-
                        Heat Meter represents a monitor-/controllable heat
                        meter.
                      allOf:
                        - *ref_51
                        - &ref_109
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - HEAT_METER
                              x-go-type-skip-optional-pointer: true
                    - &ref_334
                      title: Electrolyzer
                      description: >-
                        Electrolyzer represents a monitor-/controllable
                        electrolyzer.
                      allOf:
                        - *ref_51
                        - &ref_110
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - ELECTROLYZER
                              x-go-type-skip-optional-pointer: true
                    - &ref_341
                      title: IO Device
                      description: >-
                        IO devices represent configuration options that can be
                        applied for appliances of the fieldbus coupler type
                      allOf:
                        - *ref_51
                        - &ref_111
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - IO_DEVICE
                              x-go-type-skip-optional-pointer: true
                            manufacturer:
                              type: string
                              example: Siemens AG
                              description: Manufacturer of the io device.
                            model:
                              type: string
                              example: Siemens AG 7KM2200-2EA30-1EA1
                              description: Model of the io device.
                            firmware:
                              type: string
                              example: HW 3 SW V3.2.2
                              description: Firmware version of the io device.
                            ioDevice: &ref_53
                              title: IO Device Information
                              description: The io device specific information.
                              type: object
                              properties:
                                type:
                                  description: Describes the specific type of the device.
                                  type: string
                                  enum:
                                    - UNKNOWN
                                    - WAGO
                                    - SGREADY
                                    - JANITZA_UMG604
                                    - RUTENBECK_TCR_IP4
                                    - SIEMENS_PAC_7KM_2200
                                    - JANITZA
                                inChannelsCount:
                                  type: integer
                                  description: >-
                                    The number of input ports on the device,
                                    real physical ports you can connect a cable
                                    to.
                                outChannelsCount:
                                  type: integer
                                  description: >-
                                    The number of output ports on the device,
                                    real physical ports you can connect a cable
                                    to.
                                inputChannels:
                                  type: array
                                  description: >-
                                    Input channels of the fieldbus coupler,
                                    containing actions.
                                  items: &ref_336
                                    title: IO Device Input Channel
                                    type: object
                                    properties:
                                      bitMask:
                                        type: string
                                        format: base64
                                        description: BitMask used to identify the channel.
                                      bitValue:
                                        type: string
                                        format: base64
                                        description: BitValue used to trigger the action.
                                      actions:
                                        type: array
                                        items: &ref_335
                                          title: IO Device Input Action
                                          description: >-
                                            One individual input action, that can be
                                            registered to a channel of a fieldbus
                                            coppler appliance.
                                          type: object
                                          required:
                                            - name
                                            - value
                                          properties:
                                            name:
                                              type: string
                                              description: Name of the action.
                                            value:
                                              type: number
                                              description: >-
                                                Value of the action. Unit must be
                                                derived from Name.
                                outputChannels:
                                  type: array
                                  description: >
                                    Output channels of the IODevice, containing
                                    actions. An output channel must not always
                                    use exactly one port, but can use multiple
                                    physical connections.

                                    SGReady heat pumps for example are connected
                                    using two output ports (which are grouped in
                                    one OutputChannel).
                                  items: &ref_339
                                    title: IO Device Output Channel
                                    description: >-
                                      Represents one output channel of the
                                      IODevice.
                                    type: object
                                    properties:
                                      bitMask:
                                        type: string
                                        format: base64
                                        description: Bit mask identifying the output channel.
                                      actions:
                                        type: array
                                        description: >-
                                          Actions (name/value pairs) that are
                                          applied to the channel when enabled.
                                        items: &ref_338
                                          title: IO Device Output Action
                                          description: >-
                                            An individual output action, that can be
                                            registered to an output channel of an
                                            IODevice.
                                          type: object
                                          properties:
                                            bitValue:
                                              type: string
                                              format: base64
                                              description: >-
                                                The value to write to the IODevice's
                                                output channel. Each action has its own
                                                bit value, to allow arbitrary
                                                combinations to be written to the output
                                                channel.
                                            sgReady: &ref_337
                                              title: IO Device Output Action SGReady
                                              description: >-
                                                Used to specify a connection to a heat
                                                pump supporting the SGReady standard.
                                              type: object
                                              required:
                                                - pMin
                                                - pMax
                                                - state
                                                - applianceID
                                              properties:
                                                pMin:
                                                  type: number
                                                pMax:
                                                  type: number
                                                state:
                                                  description: >-
                                                    Represents one state of the sg ready
                                                    standard.
                                                  type: string
                                                  enum:
                                                    - UNKNOWN
                                                    - 'OFF'
                                                    - AUTO
                                                    - RECOMMEND_ON
                                                    - 'ON'
                                                applianceID:
                                                  type: string
                                                  format: uuid
                        - properties:
                            ioDevice: &ref_340
                              title: IO Device Information
                              description: The io device specific information.
                              type: object
                              allOf:
                                - *ref_53
                                - required:
                                    - type
                    - &ref_342
                      title: Heater
                      description: Heater represents a monitor-/controllable heater.
                      allOf:
                        - *ref_51
                        - &ref_112
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - HEATER
                              x-go-type-skip-optional-pointer: true
                            firmware:
                              type: string
                              example: '101.3'
                              description: Firmware version of the heater.
                            heater:
                              description: The heater specific information.
                              type: object
                              properties:
                                type:
                                  description: Describes the specific type of the heater.
                                  type: string
                                  enum:
                                    - UNKNOWN
                                    - MY_PV_AC_THOR
                                    - SIMULATION
                                    - EXT_IO_DEVICE_ELECTRIC
                                medium:
                                  description: The medium the heater is working with.
                                  type: integer
                                  enum:
                                    - 0
                                    - 1
                                    - 2
                                nominalPower:
                                  description: The nominal power of the heater.
                                  type: integer
                        - required:
                            - heater
                          properties:
                            manufacturer:
                              type: string
                              example: my-PV
                              description: Manufacturer of the heater.
                            heater:
                              required:
                                - type
                                - medium
                    - &ref_343
                      title: Container
                      description: >-
                        Container represents a container appliance, used to
                        group multiple child appliances.
                      allOf:
                        - *ref_51
                        - &ref_113
                          type: object
                          properties:
                            type:
                              type: string
                              enum:
                                - CONTAINER
                              x-go-type-skip-optional-pointer: true
                            manufacturer:
                              type: string
                              example: Loxone
                              description: Manufacturer of the container.
                            model:
                              type: string
                              example: Miniserver
                              description: Model of the container.
                            container:
                              description: The container specific information.
                              type: object
                              properties:
                                type:
                                  description: >-
                                    Describes the specific type of the
                                    container.
                                  type: string
                                  enum:
                                    - UNKNOWN
                                    - EEBUS
                        - required:
                            - container
                          properties:
                            container:
                              required:
                                - type
                  discriminator:
                    propertyName: type
                    mapping:
                      INVERTER: '#/components/schemas/Inverter'
                      METER: '#/components/schemas/Meter'
                      HEAT_PUMP: '#/components/schemas/HeatPump'
                      EVSTATION: '#/components/schemas/EVStation'
                      HEAT_METER: '#/components/schemas/HeatMeter'
                      ELECTROLYZER: '#/components/schemas/Electrolyzer'
                      IO_DEVICE: '#/components/schemas/IODevice'
                      HEATER: '#/components/schemas/Heater'
                      CONTAINER: '#/components/schemas/Container'
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances',
              qs: {per_page: 'SOME_INTEGER_VALUE', page: 'SOME_INTEGER_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances");


            req.query({
              "per_page": "SOME_INTEGER_VALUE",
              "page": "SOME_INTEGER_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'per_page' => 'SOME_INTEGER_VALUE',
              'page' => 'SOME_INTEGER_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances"


            querystring =
            {"per_page":"SOME_INTEGER_VALUE","page":"SOME_INTEGER_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances?per_page=SOME_INTEGER_VALUE&page=SOME_INTEGER_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/rfidtags/{tagID}/appliances/{applianceID}':
    put:
      summary: Assign Tag to Appliances
      description: |
        Assigns a tag to an appliance.
      tags:
        - RFIDTag
      security:
        - BearerAuth:
            - RFIDTagsWrite
      parameters:
        - *ref_1
        - *ref_47
        - &ref_54
          name: applianceID
          description: |
            Unique identifier used to access an appliance.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: bb2681ab-9526-49ca-bc52-a5f4ec366958
      responses:
        '204':
          description: Tag assigned to appliance successfully.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D\"\n\n\treq, _ := http.NewRequest(\"PUT\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")
              .put(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              "method": "PUT",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              "method": "PUT",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D');

            $request->setRequestMethod('PUT');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("PUT",
            "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("PUT", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http PUT
            https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Unassign Tag from Appliances
      description: |
        Unassigns a tag from an appliance.
      tags:
        - RFIDTag
      security:
        - BearerAuth:
            - RFIDTagsWrite
      parameters:
        - *ref_1
        - *ref_47
        - *ref_54
      responses:
        '204':
          description: Tag unassigned from appliance successfully.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/rfidtags/%7BtagID%7D/appliances/%7BapplianceID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/parents':
    get:
      summary: List all parent accounts
      description: |
        Lists all parent accounts starting at the passed account until root.
      tags:
        - Account
      parameters:
        - *ref_1
      responses:
        '200': &ref_248
          description: |
            Account parents sorted hierarchical.
            The first item is the parent of the passed account. 
            The next is the parent of the parent of the passed account. 
          content:
            application/json:
              example:
                - accountID: parent
                - accountID: parent-parent
                  audience: my-audience
                - accountID: root
              schema:
                type: array
                items:
                  type: object
                  properties:
                    accountID:
                      type: string
                    audience:
                      type: string
                  required:
                    - accountID
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      security: []
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/parents");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/parents");

            var request = new RestRequest(Method.GET);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/parents\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/parents")
              .get()
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/parents")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/parents",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/parents");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/parents",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/parents",
              "headers": {}
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: >
            const request = require('request');


            const options = {method: 'GET', url:
            'https://api.gridx.de/accounts/%7BaccountID%7D/parents'};


            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/parents");


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/parents"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/parents" in


            Client.call `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/parents",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/parents');

            $request->setMethod(HTTP_METH_GET);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/parents');

            $request->setRequestMethod('GET');

            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            conn.request("GET", "/accounts/%7BaccountID%7D/parents")

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/accounts/%7BaccountID%7D/parents"

            response = requests.request("GET", url)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/accounts/%7BaccountID%7D/parents")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/parents
        - lang: Shell + Httpie
          source: 'http GET https://api.gridx.de/accounts/%7BaccountID%7D/parents'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/parents
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/parents")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/platform-mapping':
    get:
      summary: Get Platform Mapping
      description: Get the platform-related information of the given accountID.
      tags:
        - Platform
      security:
        - BearerAuth: []
      parameters:
        - *ref_1
      responses:
        '200':
          description: Platform Mapping
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_265
                title: PlatformMapping
                description: >-
                  Represents a 1:1 mapping from a XENON account to a Platform
                  workspace and application.
                type: object
                required:
                  - applicationID
                  - workspaceID
                  - accountID
                properties:
                  accountID:
                    type: string
                    format: uuid
                    example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                    readOnly: true
                    description: Unique identifier of a XENON account.
                  applicationID:
                    type: string
                    format: uuid
                    example: 7af138d7-717d-486e-8ad1-1d4ed4b1669e
                    description: >-
                      Unique identifier of the corresponding platform
                      application.
                  workspaceID:
                    type: string
                    format: uuid
                    example: 2549665c-5067-49ad-af6a-9c74e74095e8
                    description: Unique identifier of the corresponding platform workspace.
        '204':
          description: No platform-related information found for the given accountID
        '403': *ref_11
        '404': *ref_12
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/platform-mapping",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/accounts/%7BaccountID%7D/platform-mapping",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/platform-mapping")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/bidding-zone':
    get:
      summary: Get bidding zone
      description: |
        Get the electricity market bidding zone of the given accountID.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountRead
      parameters:
        - *ref_1
      responses:
        '200':
          description: Bidding zone of the account.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_57
                allOf:
                  - &ref_56
                    type: object
                    description: >
                      The bidding zone determines from which electricity market
                      bidding zone the raw market prices for

                      market data tariffs are used.


                      The bidding zone is the ENTSOE-E Area EIC codes (Y).

                      See
                      https://www.entsoe.eu/data/energy-identification-codes-eic/eic-approved-codes/
                      &
                      https://www.entsoe.eu/data/energy-identification-codes-eic/eic-approved-codes/

                      for available codes.
                    properties:
                      biddingZone:
                        example: 10Y1001A1001A44P
                        type: string
                    required:
                      - biddingZone
                  - type: object
                    properties:
                      biddingZone:
                        nullable: true
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/bidding-zone",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/accounts/%7BaccountID%7D/bidding-zone",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    put:
      summary: Set bidding zone
      description: |
        Set the electricity market bidding zone of the given accountID.
      tags:
        - Account
      security:
        - BearerAuth:
            - AccountWrite
      parameters:
        - *ref_1
      requestBody:
        required: true
        content:
          application/vnd.gridx.v2+json:
            schema: &ref_345
              allOf:
                - &ref_344
                  allOf:
                    - *ref_56
                    - type: object
                      properties:
                        biddingZone:
                          nullable: false
                - additionalProperties: false
      responses:
        '200':
          description: Bidding zone of the account.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_57
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/vnd.gridx.v2+json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("content-type", "application/vnd.gridx.v2+json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone\"\n\n\treq, _ := http.NewRequest(\"PUT\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/vnd.gridx.v2+json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")
              .put(null)
              .addHeader("content-type", "application/vnd.gridx.v2+json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")
              .header("content-type", "application/vnd.gridx.v2+json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone",
              "method": "PUT",
              "headers": {
                "content-type": "application/vnd.gridx.v2+json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");

            xhr.setRequestHeader("content-type",
            "application/vnd.gridx.v2+json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone",
              "method": "PUT",
              "headers": {
                "content-type": "application/vnd.gridx.v2+json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/bidding-zone",
              "headers": {
                "content-type": "application/vnd.gridx.v2+json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone',
              headers: {
                'content-type': 'application/vnd.gridx.v2+json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              }
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone");


            req.headers({
              "content-type": "application/vnd.gridx.v2+json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type":
            @"application/vnd.gridx.v2+json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };

            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/vnd.gridx.v2+json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in


            Client.call ~headers `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/vnd.gridx.v2+json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'content-type' => 'application/vnd.gridx.v2+json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone');

            $request->setRequestMethod('PUT');

            $request->setHeaders([
              'content-type' => 'application/vnd.gridx.v2+json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = {
                'content-type': "application/vnd.gridx.v2+json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PUT", "/accounts/%7BaccountID%7D/bidding-zone",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone"

            headers = {
                "content-type": "application/vnd.gridx.v2+json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }

            response = requests.request("PUT", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["content-type"] = 'application/vnd.gridx.v2+json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/vnd.gridx.v2+json'
        - lang: Shell + Httpie
          source: >-
            http PUT https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:'application/vnd.gridx.v2+json'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'content-type: application/vnd.gridx.v2+json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/vnd.gridx.v2+json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/bidding-zone")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /account/tariffs:
    get:
      summary: List Energy Tariffs
      deprecated: true
      description: |
        List all available energy tariffs of the account.

        **Deprecated** - Use TariffV2 instead.
      tags:
        - Energy Tariff
      security:
        - BearerAuth:
            - AccountTariffRead
      responses:
        '200':
          description: All available energy tariffs.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items:
                  allOf:
                    - &ref_58
                      title: Energy Tariff
                      type: object
                      properties:
                        id:
                          type: string
                          description: Unique ID to identify the energy tariff.
                          format: uuid
                          example: fc8ee525-669f-45de-9bca-bf5a51829d33
                          readOnly: true
                        name:
                          type: string
                          description: 'Name of the energy tariff, to be chosen freely.'
                          example: E.ON Strom
                        createdAt:
                          type: string
                          description: >-
                            Time at which the tariff was created in UTC using
                            the RFC3339 format.
                          example: '2021-10-10T23:20:50Z'
                          format: date-time
                          readOnly: true
                        periods:
                          type: array
                          items: &ref_270
                            title: Energy Tariff Period
                            type: object
                            properties:
                              day:
                                type: integer
                                description: >-
                                  Numeric day of week. 1 means Monday and 7
                                  means Sunday.
                                example: 1
                              from:
                                type: integer
                                description: >-
                                  Time of day in seconds at which the period
                                  starts, e.g. 07:00 = 7*60*60 = 25200.
                                example: 25200
                              to:
                                type: integer
                                description: >-
                                  Time of day in seconds at which the period
                                  ends, e.g. 20:00 = 20*60*60 = 72000.
                                example: 72000
                              feedinPrice:
                                type: number
                                format: double
                                description: >-
                                  Price in cents per kWh (ct/kWh) for fed in
                                  energy in the period [from, to).
                              offtakePrice:
                                type: number
                                format: double
                                description: >-
                                  Price in cents per kWh (ct/kWh) for consumed
                                  energy in the period [from, to).
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tariffs");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/account/tariffs");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tariffs\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tariffs")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/account/tariffs")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/account/tariffs");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tariffs",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/account/tariffs',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/account/tariffs");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tariffs"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/account/tariffs" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tariffs",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/account/tariffs');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/account/tariffs');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/account/tariffs", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account/tariffs"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account/tariffs")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/account/tariffs \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/account/tariffs \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account/tariffs
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tariffs")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create Energy Tariff
      deprecated: true
      description: |
        Create an energy tariff for the account.

        **Deprecated** - Use TariffV2 instead.
      tags:
        - Energy Tariff
      security:
        - BearerAuth:
            - AccountTariffWrite
      requestBody:
        description: Energy tariff to be created for the account.
        required: true
        content:
          application/json:
            schema: &ref_269
              allOf:
                - *ref_58
                - additionalProperties: false
      responses:
        '201':
          description: The created tariff.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_58
        '400': *ref_15
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tariffs");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"E.ON
            Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/account/tariffs");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"E.ON
            Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tariffs\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"E.ON Strom\\\",\\\"periods\\\":[{\\\"day\\\":1,\\\"from\\\":25200,\\\"to\\\":72000,\\\"feedinPrice\\\":0.1,\\\"offtakePrice\\\":0.1}]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"E.ON
            Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tariffs")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/account/tariffs")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"E.ON Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"E.ON Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "E.ON Strom",
              "periods": [
                {
                  "day": 1,
                  "from": 25200,
                  "to": 72000,
                  "feedinPrice": 0.1,
                  "offtakePrice": 0.1
                }
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/account/tariffs");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"E.ON Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tariffs",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'E.ON Strom',
              periods: [{day: 1, from: 25200, to: 72000, feedinPrice: 0.1, offtakePrice: 0.1}]
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/account/tariffs',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'E.ON Strom',
                periods: [{day: 1, from: 25200, to: 72000, feedinPrice: 0.1, offtakePrice: 0.1}]
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/account/tariffs");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "name": "E.ON Strom",
              "periods": [
                {
                  "day": 1,
                  "from": 25200,
                  "to": 72000,
                  "feedinPrice": 0.1,
                  "offtakePrice": 0.1
                }
              ]
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"E.ON Strom",
                                          @"periods": @[ @{ @"day": @1, @"from": @25200, @"to": @72000, @"feedinPrice": @0.1, @"offtakePrice": @0.1 } ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tariffs"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/account/tariffs" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"E.ON
            Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tariffs",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"E.ON Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tariffs');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"E.ON
            Strom","periods":[{"day":1,"from":25200,"to":72000,"feedinPrice":0.1,"offtakePrice":0.1}]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"E.ON
            Strom","periods":[{"day":1,"from":25200,"to":72000,"feedinPrice":0.1,"offtakePrice":0.1}]}');


            $request->setRequestUrl('https://api.gridx.de/account/tariffs');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"E.ON
            Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/account/tariffs", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/account/tariffs"


            payload = {
                "name": "E.ON Strom",
                "periods": [
                    {
                        "day": 1,
                        "from": 25200,
                        "to": 72000,
                        "feedinPrice": 0.1,
                        "offtakePrice": 0.1
                    }
                ]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/account/tariffs")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"E.ON
            Strom\",\"periods\":[{\"day\":1,\"from\":25200,\"to\":72000,\"feedinPrice\":0.1,\"offtakePrice\":0.1}]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/account/tariffs \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"E.ON Strom","periods":[{"day":1,"from":25200,"to":72000,"feedinPrice":0.1,"offtakePrice":0.1}]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"E.ON
            Strom","periods":[{"day":1,"from":25200,"to":72000,"feedinPrice":0.1,"offtakePrice":0.1}]}'
            |  \
              http POST https://api.gridx.de/account/tariffs \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"E.ON Strom","periods":[{"day":1,"from":25200,"to":72000,"feedinPrice":0.1,"offtakePrice":0.1}]}' \
              --output-document \
              - https://api.gridx.de/account/tariffs
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "E.ON Strom",
              "periods": [
                [
                  "day": 1,
                  "from": 25200,
                  "to": 72000,
                  "feedinPrice": 0.1,
                  "offtakePrice": 0.1
                ]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tariffs")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/account/tariffs/{tariffID}':
    get:
      summary: Get Energy Tariff
      deprecated: true
      description: |
        Get the specified energy tariff of the account.

        **Deprecated** - Use TariffV2 instead.
      parameters:
        - &ref_59
          name: tariffID
          description: |
            Unique identifier for the energy tariff.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 17874c1b-d073-4b06-bf01-a1497fbe1142
      tags:
        - Energy Tariff
      security:
        - BearerAuth:
            - AccountTariffRead
      responses:
        '200':
          description: The specified energy tariff.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_58
        '403': *ref_11
        '404': &ref_60
          description: Tariff not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tariffs/%7BtariffID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tariffs/%7BtariffID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tariffs/%7BtariffID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/account/tariffs/%7BtariffID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tariffs/%7BtariffID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/account/tariffs/%7BtariffID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tariffs/%7BtariffID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tariffs/%7BtariffID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/tariffs/%7BtariffID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/account/tariffs/%7BtariffID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account/tariffs/%7BtariffID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account/tariffs/%7BtariffID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/account/tariffs/%7BtariffID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/account/tariffs/%7BtariffID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account/tariffs/%7BtariffID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update Energy Tariff
      deprecated: true
      description: |
        Update the specified energy tariff of the account.

        **Deprecated** - Use TariffV2 instead.
      parameters:
        - *ref_59
      tags:
        - Energy Tariff
      security:
        - BearerAuth:
            - AccountTariffWrite
      responses:
        '200':
          description: The updated energy tariff.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_58
        '403': *ref_11
        '404': *ref_60
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tariffs/%7BtariffID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tariffs/%7BtariffID%7D\"\n\n\treq, _ := http.NewRequest(\"PATCH\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tariffs/%7BtariffID%7D")
              .patch(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/account/tariffs/%7BtariffID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              "method": "PATCH",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              "method": "PATCH",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tariffs/%7BtariffID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/account/tariffs/%7BtariffID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tariffs/%7BtariffID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tariffs/%7BtariffID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/tariffs/%7BtariffID%7D');

            $request->setRequestMethod('PATCH');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("PATCH", "/account/tariffs/%7BtariffID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account/tariffs/%7BtariffID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("PATCH", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account/tariffs/%7BtariffID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Patch.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/account/tariffs/%7BtariffID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http PATCH https://api.gridx.de/account/tariffs/%7BtariffID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account/tariffs/%7BtariffID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Energy Tariff
      deprecated: true
      description: |
        Delete the specified energy tariff of the account.

        **Deprecated** - Use TariffV2 instead.
      parameters:
        - *ref_59
      tags:
        - Energy Tariff
      security:
        - BearerAuth:
            - AccountTariffWrite
      responses:
        '204':
          description: Tariff has been deleted successfully.
        '403': *ref_11
        '404': *ref_60
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/account/tariffs/%7BtariffID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/account/tariffs/%7BtariffID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/account/tariffs/%7BtariffID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/account/tariffs/%7BtariffID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/account/tariffs/%7BtariffID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/account/tariffs/%7BtariffID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/account/tariffs/%7BtariffID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/account/tariffs/%7BtariffID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/account/tariffs/%7BtariffID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/account/tariffs/%7BtariffID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE", "/account/tariffs/%7BtariffID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/account/tariffs/%7BtariffID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/account/tariffs/%7BtariffID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/account/tariffs/%7BtariffID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/account/tariffs/%7BtariffID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/account/tariffs/%7BtariffID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/account/tariffs/%7BtariffID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /beta/systems:
    get:
      summary: Proxy of the AMT endpoint.
      description: >
        This endpoint proxies the AMT endpoint.

        The request and response are the same, the only difference is the
        endpoint.

        See
        [links](https://backstage.sre.gridx.de/catalog/default/api/system-api/definition#/System/get_applications__application_id__systems)
      tags:
        - Asset
      responses:
        '200':
          description: Success
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/beta/systems");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/beta/systems");
            var request = new RestRequest(Method.GET);
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/beta/systems\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/beta/systems")
              .get()
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/beta/systems")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/beta/systems",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: |-
            const data = null;

            const xhr = new XMLHttpRequest();
            xhr.withCredentials = true;

            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });

            xhr.open("GET", "https://api.gridx.de/beta/systems");

            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/beta/systems",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/beta/systems",
              "headers": {}
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: >
            const request = require('request');


            const options = {method: 'GET', url:
            'https://api.gridx.de/beta/systems'};


            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/beta/systems");

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/beta/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: |-
            open Cohttp_lwt_unix
            open Cohttp
            open Lwt

            let uri = Uri.of_string "https://api.gridx.de/beta/systems" in

            Client.call `GET uri
            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/beta/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/beta/systems');
            $request->setMethod(HTTP_METH_GET);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/beta/systems');
            $request->setRequestMethod('GET');
            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            conn.request("GET", "/beta/systems")

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/beta/systems"

            response = requests.request("GET", url)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/beta/systems")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/beta/systems
        - lang: Shell + Httpie
          source: 'http GET https://api.gridx.de/beta/systems'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --output-document \
              - https://api.gridx.de/beta/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/beta/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /clusters:
    get:
      security:
        - BearerAuth:
            - ClustersRead
      summary: Allows to retrieve the list of all available clusters.
      tags:
        - Clusters
      responses:
        '200':
          description: OK
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_61
                  allOf:
                    - &ref_63
                      type: object
                      properties:
                        priority:
                          description: >-
                            The higher the priority, the more energy the
                            appliances will get; a cluster with higher priority
                            will be curtailed least.
                          type: integer
                          format: int
                          example: 1
                        name:
                          description: >-
                            The cluster's name meant to be displayable to the
                            user.
                          type: string
                          example: E Corp HQ
                        strategy:
                          description: >-
                            Identifies the specific curtailment approach within
                            the cluster.
                          type: string
                          enum:
                            - SERIES
                            - EQUALLY
                            - FIRST_COME_FIRST_SERVE
                            - LAST_COME_FIRST_SERVE
                            - ROUND_ROBIN
                            - AI
                            - PROPORTIONAL
                        priorities:
                          description: Defines the priority for the EMS.
                          type: array
                          items:
                            type: string
                            enum:
                              - BATTERY
                              - HEATER
                              - EV
                              - HEATPUMP
                        maxPower:
                          description: The maximum power in W.
                          type: integer
                        maxPowerL1:
                          description: The maximum power in W for phase L1.
                          type: integer
                        maxPowerL2:
                          description: The maximum power in W for phase L2.
                          type: integer
                        maxPowerL3:
                          description: The maximum power in W for phase L3.
                          type: integer
                        maxPowerMargin:
                          description: The maximum power safety margin in W.
                          type: integer
                        maxPowerMarginL1:
                          description: The maximum power safety margin in W for phase L1.
                          type: integer
                        maxPowerMarginL2:
                          description: The maximum power safety margin in W for phase L2.
                          type: integer
                        maxPowerMarginL3:
                          description: The maximum power safety margin in W for phase L3.
                          type: integer
                        maxPowerWorstCase:
                          description: >-
                            The assumed maximum power in W in case of a lost
                            connection.
                          type: integer
                        maxPowerWorstCaseL1:
                          description: >-
                            The assumed maximum power in W in case of a lost
                            connection for phase L1.
                          type: integer
                        maxPowerWorstCaseL2:
                          description: >-
                            The assumed maximum power in W in case of a lost
                            connection for phase L2.
                          type: integer
                        maxPowerWorstCaseL3:
                          description: >-
                            The assumed maximum power in W in case of a lost
                            connection for phase L3.
                          type: integer
                        dynamicPowerDistribution:
                          description: >-
                            Specifies whether dynamic power distribution should
                            be enabled or not.
                          type: boolean
                    - properties:
                        id:
                          description: Identifier of the cluster.
                          type: string
                          format: uuid
                          readOnly: true
                        systemID:
                          description: Identifier of the system.
                          type: string
                          format: uuid
                        createdAt:
                          description: >-
                            Time at which the cluster was created in UTC using
                            the ISO 8601 full-time format.
                          type: string
                          format: date-time
                          example: '1985-04-12T23:20:50Z'
                          readOnly: true
                        updatedAt:
                          description: >-
                            Time at which the cluster was updated in UTC using
                            the ISO 8601 full-time format.
                          type: string
                          format: date-time
                          example: '1985-04-12T23:20:50Z'
                          readOnly: true
                        dynamicPowerDistribution:
                          default: false
                        clusters:
                          description: Clusters that belong to the cluster.
                          type: array
                          items: *ref_61
                        appliances:
                          description: Appliances that belong to the cluster.
                          type: array
                          items: *ref_62
                      required:
                        - id
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/clusters");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/clusters");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/clusters")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/clusters");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/clusters',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/clusters");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/clusters" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/clusters');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/clusters');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/clusters", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/clusters"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/clusters")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/clusters \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/clusters \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      security:
        - BearerAuth:
            - ClustersWrite
      summary: Create a new cluster.
      tags:
        - Clusters
      requestBody:
        content:
          application/json:
            schema: &ref_65
              allOf:
                - &ref_350
                  allOf:
                    - *ref_63
                    - properties:
                        systemID:
                          description: Identifier of the system.
                          type: string
                          format: uuid
                      required:
                        - systemID
                - additionalProperties: false
        required: true
      responses:
        '201':
          description: Created resource
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_61
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/clusters");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/clusters");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters\"\n\n\tpayload := strings.NewReader(\"{\\\"priority\\\":1,\\\"name\\\":\\\"E Corp HQ\\\",\\\"strategy\\\":\\\"SERIES\\\",\\\"priorities\\\":[\\\"BATTERY\\\"],\\\"maxPower\\\":0,\\\"maxPowerL1\\\":0,\\\"maxPowerL2\\\":0,\\\"maxPowerL3\\\":0,\\\"maxPowerMargin\\\":0,\\\"maxPowerMarginL1\\\":0,\\\"maxPowerMarginL2\\\":0,\\\"maxPowerMarginL3\\\":0,\\\"maxPowerWorstCase\\\":0,\\\"maxPowerWorstCaseL1\\\":0,\\\"maxPowerWorstCaseL2\\\":0,\\\"maxPowerWorstCaseL3\\\":0,\\\"dynamicPowerDistribution\\\":true,\\\"systemID\\\":\\\"442178e1-171b-41ea-95bd-7826b0975827\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/clusters")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": [
                "BATTERY"
              ],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true,
              "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/clusters");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              priority: 1,
              name: 'E Corp HQ',
              strategy: 'SERIES',
              priorities: ['BATTERY'],
              maxPower: 0,
              maxPowerL1: 0,
              maxPowerL2: 0,
              maxPowerL3: 0,
              maxPowerMargin: 0,
              maxPowerMarginL1: 0,
              maxPowerMarginL2: 0,
              maxPowerMarginL3: 0,
              maxPowerWorstCase: 0,
              maxPowerWorstCaseL1: 0,
              maxPowerWorstCaseL2: 0,
              maxPowerWorstCaseL3: 0,
              dynamicPowerDistribution: true,
              systemID: '442178e1-171b-41ea-95bd-7826b0975827'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/clusters',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                priority: 1,
                name: 'E Corp HQ',
                strategy: 'SERIES',
                priorities: ['BATTERY'],
                maxPower: 0,
                maxPowerL1: 0,
                maxPowerL2: 0,
                maxPowerL3: 0,
                maxPowerMargin: 0,
                maxPowerMarginL1: 0,
                maxPowerMarginL2: 0,
                maxPowerMarginL3: 0,
                maxPowerWorstCase: 0,
                maxPowerWorstCaseL1: 0,
                maxPowerWorstCaseL2: 0,
                maxPowerWorstCaseL3: 0,
                dynamicPowerDistribution: true,
                systemID: '442178e1-171b-41ea-95bd-7826b0975827'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/clusters");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": [
                "BATTERY"
              ],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true,
              "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"priority": @1,
                                          @"name": @"E Corp HQ",
                                          @"strategy": @"SERIES",
                                          @"priorities": @[ @"BATTERY" ],
                                          @"maxPower": @0,
                                          @"maxPowerL1": @0,
                                          @"maxPowerL2": @0,
                                          @"maxPowerL3": @0,
                                          @"maxPowerMargin": @0,
                                          @"maxPowerMarginL1": @0,
                                          @"maxPowerMarginL2": @0,
                                          @"maxPowerMarginL3": @0,
                                          @"maxPowerWorstCase": @0,
                                          @"maxPowerWorstCaseL1": @0,
                                          @"maxPowerWorstCaseL2": @0,
                                          @"maxPowerWorstCaseL3": @0,
                                          @"dynamicPowerDistribution": @YES,
                                          @"systemID": @"442178e1-171b-41ea-95bd-7826b0975827" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/clusters" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"priority\":1,\"name\":\"E
            Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}');


            $request->setRequestUrl('https://api.gridx.de/clusters');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/clusters", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/clusters"


            payload = {
                "priority": 1,
                "name": "E Corp HQ",
                "strategy": "SERIES",
                "priorities": ["BATTERY"],
                "maxPower": 0,
                "maxPowerL1": 0,
                "maxPowerL2": 0,
                "maxPowerL3": 0,
                "maxPowerMargin": 0,
                "maxPowerMarginL1": 0,
                "maxPowerMarginL2": 0,
                "maxPowerMarginL3": 0,
                "maxPowerWorstCase": 0,
                "maxPowerWorstCaseL1": 0,
                "maxPowerWorstCaseL2": 0,
                "maxPowerWorstCaseL3": 0,
                "dynamicPowerDistribution": True,
                "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/clusters")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/clusters \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"priority":1,"name":"E Corp HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}'
            |  \
              http POST https://api.gridx.de/clusters \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"priority":1,"name":"E Corp HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}' \
              --output-document \
              - https://api.gridx.de/clusters
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": ["BATTERY"],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true,
              "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/clusters/{clusterID}':
    get:
      security:
        - BearerAuth:
            - ClustersRead
      summary: Allows to retrieve a cluster.
      tags:
        - Clusters
      parameters:
        - &ref_64
          name: clusterID
          description: Unique identifier used to access a cluster.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 2c7043ae-1539-4e02-bdbd-0395c90d6bd0
      responses:
        '200':
          description: OK
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_61
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/clusters/%7BclusterID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/clusters/%7BclusterID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/clusters/%7BclusterID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/clusters/%7BclusterID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/clusters/%7BclusterID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/clusters/%7BclusterID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/clusters/%7BclusterID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      security:
        - BearerAuth:
            - ClustersWrite
      summary: Partially update a cluster.
      tags:
        - Clusters
      requestBody:
        content:
          application/json:
            schema: &ref_349
              allOf:
                - *ref_63
                - additionalProperties: false
        required: true
      parameters:
        - *ref_64
      responses:
        '200':
          description: OK
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_61
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"priority\\\":1,\\\"name\\\":\\\"E Corp HQ\\\",\\\"strategy\\\":\\\"SERIES\\\",\\\"priorities\\\":[\\\"BATTERY\\\"],\\\"maxPower\\\":0,\\\"maxPowerL1\\\":0,\\\"maxPowerL2\\\":0,\\\"maxPowerL3\\\":0,\\\"maxPowerMargin\\\":0,\\\"maxPowerMarginL1\\\":0,\\\"maxPowerMarginL2\\\":0,\\\"maxPowerMarginL3\\\":0,\\\"maxPowerWorstCase\\\":0,\\\"maxPowerWorstCaseL1\\\":0,\\\"maxPowerWorstCaseL2\\\":0,\\\"maxPowerWorstCaseL3\\\":0,\\\"dynamicPowerDistribution\\\":true}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/clusters/%7BclusterID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": [
                "BATTERY"
              ],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/clusters/%7BclusterID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              priority: 1,
              name: 'E Corp HQ',
              strategy: 'SERIES',
              priorities: ['BATTERY'],
              maxPower: 0,
              maxPowerL1: 0,
              maxPowerL2: 0,
              maxPowerL3: 0,
              maxPowerMargin: 0,
              maxPowerMarginL1: 0,
              maxPowerMarginL2: 0,
              maxPowerMarginL3: 0,
              maxPowerWorstCase: 0,
              maxPowerWorstCaseL1: 0,
              maxPowerWorstCaseL2: 0,
              maxPowerWorstCaseL3: 0,
              dynamicPowerDistribution: true
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                priority: 1,
                name: 'E Corp HQ',
                strategy: 'SERIES',
                priorities: ['BATTERY'],
                maxPower: 0,
                maxPowerL1: 0,
                maxPowerL2: 0,
                maxPowerL3: 0,
                maxPowerMargin: 0,
                maxPowerMarginL1: 0,
                maxPowerMarginL2: 0,
                maxPowerMarginL3: 0,
                maxPowerWorstCase: 0,
                maxPowerWorstCaseL1: 0,
                maxPowerWorstCaseL2: 0,
                maxPowerWorstCaseL3: 0,
                dynamicPowerDistribution: true
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": [
                "BATTERY"
              ],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"priority": @1,
                                          @"name": @"E Corp HQ",
                                          @"strategy": @"SERIES",
                                          @"priorities": @[ @"BATTERY" ],
                                          @"maxPower": @0,
                                          @"maxPowerL1": @0,
                                          @"maxPowerL2": @0,
                                          @"maxPowerL3": @0,
                                          @"maxPowerMargin": @0,
                                          @"maxPowerMarginL1": @0,
                                          @"maxPowerMarginL2": @0,
                                          @"maxPowerMarginL3": @0,
                                          @"maxPowerWorstCase": @0,
                                          @"maxPowerWorstCaseL1": @0,
                                          @"maxPowerWorstCaseL2": @0,
                                          @"maxPowerWorstCaseL3": @0,
                                          @"dynamicPowerDistribution": @YES };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"priority\":1,\"name\":\"E
            Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true}');


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/clusters/%7BclusterID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/clusters/%7BclusterID%7D"


            payload = {
                "priority": 1,
                "name": "E Corp HQ",
                "strategy": "SERIES",
                "priorities": ["BATTERY"],
                "maxPower": 0,
                "maxPowerL1": 0,
                "maxPowerL2": 0,
                "maxPowerL3": 0,
                "maxPowerMargin": 0,
                "maxPowerMarginL1": 0,
                "maxPowerMarginL2": 0,
                "maxPowerMarginL3": 0,
                "maxPowerWorstCase": 0,
                "maxPowerWorstCaseL1": 0,
                "maxPowerWorstCaseL2": 0,
                "maxPowerWorstCaseL3": 0,
                "dynamicPowerDistribution": True
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/clusters/%7BclusterID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/clusters/%7BclusterID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"priority":1,"name":"E Corp HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true}'
        - lang: Shell + Httpie
          source: >-
            echo '{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true}'
            |  \
              http PATCH https://api.gridx.de/clusters/%7BclusterID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"priority":1,"name":"E Corp HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true}' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": ["BATTERY"],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    put:
      security:
        - BearerAuth:
            - ClustersWrite
      summary: Replace an existing cluster.
      tags:
        - Clusters
      requestBody:
        content:
          application/json:
            schema: *ref_65
        required: true
      parameters:
        - *ref_64
      responses:
        '200':
          description: OK
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_61
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"priority\\\":1,\\\"name\\\":\\\"E Corp HQ\\\",\\\"strategy\\\":\\\"SERIES\\\",\\\"priorities\\\":[\\\"BATTERY\\\"],\\\"maxPower\\\":0,\\\"maxPowerL1\\\":0,\\\"maxPowerL2\\\":0,\\\"maxPowerL3\\\":0,\\\"maxPowerMargin\\\":0,\\\"maxPowerMarginL1\\\":0,\\\"maxPowerMarginL2\\\":0,\\\"maxPowerMarginL3\\\":0,\\\"maxPowerWorstCase\\\":0,\\\"maxPowerWorstCaseL1\\\":0,\\\"maxPowerWorstCaseL2\\\":0,\\\"maxPowerWorstCaseL3\\\":0,\\\"dynamicPowerDistribution\\\":true,\\\"systemID\\\":\\\"442178e1-171b-41ea-95bd-7826b0975827\\\"}\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D")
              .put(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/clusters/%7BclusterID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": [
                "BATTERY"
              ],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true,
              "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT", "https://api.gridx.de/clusters/%7BclusterID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              priority: 1,
              name: 'E Corp HQ',
              strategy: 'SERIES',
              priorities: ['BATTERY'],
              maxPower: 0,
              maxPowerL1: 0,
              maxPowerL2: 0,
              maxPowerL3: 0,
              maxPowerMargin: 0,
              maxPowerMarginL1: 0,
              maxPowerMarginL2: 0,
              maxPowerMarginL3: 0,
              maxPowerWorstCase: 0,
              maxPowerWorstCaseL1: 0,
              maxPowerWorstCaseL2: 0,
              maxPowerWorstCaseL3: 0,
              dynamicPowerDistribution: true,
              systemID: '442178e1-171b-41ea-95bd-7826b0975827'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                priority: 1,
                name: 'E Corp HQ',
                strategy: 'SERIES',
                priorities: ['BATTERY'],
                maxPower: 0,
                maxPowerL1: 0,
                maxPowerL2: 0,
                maxPowerL3: 0,
                maxPowerMargin: 0,
                maxPowerMarginL1: 0,
                maxPowerMarginL2: 0,
                maxPowerMarginL3: 0,
                maxPowerWorstCase: 0,
                maxPowerWorstCaseL1: 0,
                maxPowerWorstCaseL2: 0,
                maxPowerWorstCaseL3: 0,
                dynamicPowerDistribution: true,
                systemID: '442178e1-171b-41ea-95bd-7826b0975827'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": [
                "BATTERY"
              ],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true,
              "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"priority": @1,
                                          @"name": @"E Corp HQ",
                                          @"strategy": @"SERIES",
                                          @"priorities": @[ @"BATTERY" ],
                                          @"maxPower": @0,
                                          @"maxPowerL1": @0,
                                          @"maxPowerL2": @0,
                                          @"maxPowerL3": @0,
                                          @"maxPowerMargin": @0,
                                          @"maxPowerMarginL1": @0,
                                          @"maxPowerMarginL2": @0,
                                          @"maxPowerMarginL3": @0,
                                          @"maxPowerWorstCase": @0,
                                          @"maxPowerWorstCaseL1": @0,
                                          @"maxPowerWorstCaseL2": @0,
                                          @"maxPowerWorstCaseL3": @0,
                                          @"dynamicPowerDistribution": @YES,
                                          @"systemID": @"442178e1-171b-41ea-95bd-7826b0975827" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"priority\":1,\"name\":\"E
            Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"
            in


            Client.call ~headers ~body `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_POSTFIELDS => "{\"priority\":1,\"name\":\"E Corp HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}');


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D');

            $request->setRequestMethod('PUT');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PUT", "/clusters/%7BclusterID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/clusters/%7BclusterID%7D"


            payload = {
                "priority": 1,
                "name": "E Corp HQ",
                "strategy": "SERIES",
                "priorities": ["BATTERY"],
                "maxPower": 0,
                "maxPowerL1": 0,
                "maxPowerL2": 0,
                "maxPowerL3": 0,
                "maxPowerMargin": 0,
                "maxPowerMarginL1": 0,
                "maxPowerMarginL2": 0,
                "maxPowerMarginL3": 0,
                "maxPowerWorstCase": 0,
                "maxPowerWorstCaseL1": 0,
                "maxPowerWorstCaseL2": 0,
                "maxPowerWorstCaseL3": 0,
                "dynamicPowerDistribution": True,
                "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PUT", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/clusters/%7BclusterID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"priority\":1,\"name\":\"E Corp
            HQ\",\"strategy\":\"SERIES\",\"priorities\":[\"BATTERY\"],\"maxPower\":0,\"maxPowerL1\":0,\"maxPowerL2\":0,\"maxPowerL3\":0,\"maxPowerMargin\":0,\"maxPowerMarginL1\":0,\"maxPowerMarginL2\":0,\"maxPowerMarginL3\":0,\"maxPowerWorstCase\":0,\"maxPowerWorstCaseL1\":0,\"maxPowerWorstCaseL2\":0,\"maxPowerWorstCaseL3\":0,\"dynamicPowerDistribution\":true,\"systemID\":\"442178e1-171b-41ea-95bd-7826b0975827\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/clusters/%7BclusterID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"priority":1,"name":"E Corp HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"priority":1,"name":"E Corp
            HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}'
            |  \
              http PUT https://api.gridx.de/clusters/%7BclusterID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"priority":1,"name":"E Corp HQ","strategy":"SERIES","priorities":["BATTERY"],"maxPower":0,"maxPowerL1":0,"maxPowerL2":0,"maxPowerL3":0,"maxPowerMargin":0,"maxPowerMarginL1":0,"maxPowerMarginL2":0,"maxPowerMarginL3":0,"maxPowerWorstCase":0,"maxPowerWorstCaseL1":0,"maxPowerWorstCaseL2":0,"maxPowerWorstCaseL3":0,"dynamicPowerDistribution":true,"systemID":"442178e1-171b-41ea-95bd-7826b0975827"}' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "priority": 1,
              "name": "E Corp HQ",
              "strategy": "SERIES",
              "priorities": ["BATTERY"],
              "maxPower": 0,
              "maxPowerL1": 0,
              "maxPowerL2": 0,
              "maxPowerL3": 0,
              "maxPowerMargin": 0,
              "maxPowerMarginL1": 0,
              "maxPowerMarginL2": 0,
              "maxPowerMarginL3": 0,
              "maxPowerWorstCase": 0,
              "maxPowerWorstCaseL1": 0,
              "maxPowerWorstCaseL2": 0,
              "maxPowerWorstCaseL3": 0,
              "dynamicPowerDistribution": true,
              "systemID": "442178e1-171b-41ea-95bd-7826b0975827"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      security:
        - BearerAuth:
            - ClustersWrite
      summary: Delete an existing cluster.
      tags:
        - Clusters
      parameters:
        - *ref_64
      responses:
        '204':
          description: No content
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/clusters/%7BclusterID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE", "https://api.gridx.de/clusters/%7BclusterID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/clusters/%7BclusterID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("DELETE", "/clusters/%7BclusterID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/clusters/%7BclusterID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/clusters/%7BclusterID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/clusters/%7BclusterID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/clusters/%7BclusterID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/clusters/{clusterID}/members/{memberID}':
    post:
      security:
        - BearerAuth:
            - ClustersWrite
      summary: Assign a member to an existing cluster.
      description: >
        Assign a member to an existing cluster. 

        A cluster member can be either an appliance or another cluster (nested
        cluster).
      tags:
        - Clusters
      parameters:
        - *ref_64
        - &ref_66
          name: memberID
          in: path
          description: Identifier of a member (Appliance ID/Cluster ID).
          required: true
          example: 2c7043ae-1539-4e02-bdbd-0395c90d6bd0
          schema:
            type: string
            format: uuid
      responses:
        '204':
          description: No content
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");

            var request = new RestRequest(Method.POST);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")
              .post(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D');

            $request->setRequestMethod('POST');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("POST",
            "/clusters/%7BclusterID%7D/members/%7BmemberID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("POST", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http POST
            https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      security:
        - BearerAuth:
            - ClustersWrite
      summary: Unassign a member to an existing cluster.
      tags:
        - Clusters
      parameters:
        - *ref_64
        - *ref_66
      responses:
        '204':
          description: No content
        '500':
          description: Internal error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/clusters/%7BclusterID%7D/members/%7BmemberID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D/members/%7BmemberID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /customers:
    get:
      summary: List all Customers
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersRead
      parameters:
        - *ref_18
        - *ref_17
        - *ref_67
        - &ref_70
          name: order
          description: >-
            Order direction of the results, to be used in combination with
            `sort` parameter.
          in: query
          schema:
            type: string
          example: desc
      responses:
        '200':
          description: Customers returned
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_68
                  title: Customer Account
                  description: Represents an end-customer account.
                  type: object
                  allOf:
                    - *ref_10
                    - properties:
                        kind:
                          example: end-user
        '401': &ref_166
          description: Unauthorized.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_352
                readOnly: true
                allOf:
                  - *ref_0
                  - title: ClientError - Unauthorized
                    description: >-
                      The client isn't authorized to access the requested
                      resource.
                    example:
                      message: Unauthorized
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/customers',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                sort: 'SOME_STRING_VALUE',
                order: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/customers");

            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "sort": "SOME_STRING_VALUE",
              "order": "SOME_STRING_VALUE"
            });

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/customers');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE',
              'order' => 'SOME_STRING_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/customers');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE',
              'order' => 'SOME_STRING_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","sort":"SOME_STRING_VALUE","order":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create Customer
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersWrite
      requestBody:
        description: Create customer
        required: true
        content:
          application/json:
            schema: &ref_353
              allOf:
                - *ref_68
                - additionalProperties: false
      responses:
        '201':
          description: Customer created
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_68
        '400': *ref_15
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/customers");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"solution\\\":\\\"HOME\\\",\\\"id\\\":\\\"49a4f165-8233-426b-a1a4-e569665a25dd\\\",\\\"parentID\\\":\\\"19a4f165-8233-426b-a1a4-e569665a25dd\\\",\\\"createdAt\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"updatedAt\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"systemsCount\\\":1,\\\"kind\\\":\\\"end-user\\\",\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"},\\\"customization\\\":null}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/customers")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "id": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
              "createdAt": "2019-08-24T14:15:22Z",
              "updatedAt": "2019-08-24T14:15:22Z",
              "systemsCount": 1,
              "kind": "end-user",
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              },
              "customization": null
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/customers");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'John Doe',
              email: 'john@doe.com',
              solution: 'HOME',
              id: '49a4f165-8233-426b-a1a4-e569665a25dd',
              parentID: '19a4f165-8233-426b-a1a4-e569665a25dd',
              createdAt: '2019-08-24T14:15:22Z',
              updatedAt: '2019-08-24T14:15:22Z',
              systemsCount: 1,
              kind: 'end-user',
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              },
              customization: null
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/customers',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'John Doe',
                email: 'john@doe.com',
                solution: 'HOME',
                id: '49a4f165-8233-426b-a1a4-e569665a25dd',
                parentID: '19a4f165-8233-426b-a1a4-e569665a25dd',
                createdAt: '2019-08-24T14:15:22Z',
                updatedAt: '2019-08-24T14:15:22Z',
                systemsCount: 1,
                kind: 'end-user',
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                },
                customization: null
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/customers");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "id": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
              "createdAt": "2019-08-24T14:15:22Z",
              "updatedAt": "2019-08-24T14:15:22Z",
              "systemsCount": 1,
              "kind": "end-user",
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              },
              "customization": null
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"solution": @"HOME",
                                          @"id": @"49a4f165-8233-426b-a1a4-e569665a25dd",
                                          @"parentID": @"19a4f165-8233-426b-a1a4-e569665a25dd",
                                          @"createdAt": @"2019-08-24T14:15:22Z",
                                          @"updatedAt": @"2019-08-24T14:15:22Z",
                                          @"systemsCount": @1,
                                          @"kind": @"end-user",
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" },
                                          @"customization":  };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/customers" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","id":"49a4f165-8233-426b-a1a4-e569665a25dd","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","createdAt":"2019-08-24T14:15:22Z","updatedAt":"2019-08-24T14:15:22Z","systemsCount":1,"kind":"end-user","mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"customization":null}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","id":"49a4f165-8233-426b-a1a4-e569665a25dd","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","createdAt":"2019-08-24T14:15:22Z","updatedAt":"2019-08-24T14:15:22Z","systemsCount":1,"kind":"end-user","mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"customization":null}');


            $request->setRequestUrl('https://api.gridx.de/customers');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/customers", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers"


            payload = {
                "name": "John Doe",
                "email": "john@doe.com",
                "solution": "HOME",
                "id": "49a4f165-8233-426b-a1a4-e569665a25dd",
                "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
                "createdAt": "2019-08-24T14:15:22Z",
                "updatedAt": "2019-08-24T14:15:22Z",
                "systemsCount": 1,
                "kind": "end-user",
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                },
                "customization": None
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/customers")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"id\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"parentID\":\"19a4f165-8233-426b-a1a4-e569665a25dd\",\"createdAt\":\"2019-08-24T14:15:22Z\",\"updatedAt\":\"2019-08-24T14:15:22Z\",\"systemsCount\":1,\"kind\":\"end-user\",\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"customization\":null}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/customers \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","id":"49a4f165-8233-426b-a1a4-e569665a25dd","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","createdAt":"2019-08-24T14:15:22Z","updatedAt":"2019-08-24T14:15:22Z","systemsCount":1,"kind":"end-user","mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"customization":null}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","id":"49a4f165-8233-426b-a1a4-e569665a25dd","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","createdAt":"2019-08-24T14:15:22Z","updatedAt":"2019-08-24T14:15:22Z","systemsCount":1,"kind":"end-user","mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"customization":null}'
            |  \
              http POST https://api.gridx.de/customers \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","id":"49a4f165-8233-426b-a1a4-e569665a25dd","parentID":"19a4f165-8233-426b-a1a4-e569665a25dd","createdAt":"2019-08-24T14:15:22Z","updatedAt":"2019-08-24T14:15:22Z","systemsCount":1,"kind":"end-user","mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"customization":null}' \
              --output-document \
              - https://api.gridx.de/customers
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "id": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "parentID": "19a4f165-8233-426b-a1a4-e569665a25dd",
              "createdAt": "2019-08-24T14:15:22Z",
              "updatedAt": "2019-08-24T14:15:22Z",
              "systemsCount": 1,
              "kind": "end-user",
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ],
              "customization": 
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/customers/{accountID}':
    get:
      summary: Get Customer
      description: Get a single customer given its account ID.
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersRead
      parameters:
        - *ref_1
      responses:
        '200':
          description: Customer returned
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_68
        '400': *ref_3
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BaccountID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BaccountID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BaccountID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/customers/%7BaccountID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/customers/%7BaccountID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BaccountID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/customers/%7BaccountID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/customers/%7BaccountID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BaccountID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/customers/%7BaccountID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/customers/%7BaccountID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/customers/%7BaccountID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/customers/%7BaccountID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/customers/%7BaccountID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/customers/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/customers/%7BaccountID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/customers/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Edit a single customer
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersWrite
      parameters:
        - *ref_1
      requestBody: &ref_204
        description: Updates an end-customer account.
        required: true
        content:
          application/json:
            schema: &ref_355
              allOf:
                - &ref_354
                  allOf:
                    - *ref_7
                    - properties:
                        customization:
                          description: Customization can be used to store arbitrary data.
                        mainAddress: *ref_9
                - additionalProperties: false
      responses:
        '200':
          description: Customers updated
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_68
        '400': *ref_15
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BaccountID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BaccountID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"solution\\\":\\\"HOME\\\",\\\"customization\\\":null,\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BaccountID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/customers/%7BaccountID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/customers/%7BaccountID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BaccountID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'John Doe',
              email: 'john@doe.com',
              solution: 'HOME',
              customization: null,
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/customers/%7BaccountID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'John Doe',
                email: 'john@doe.com',
                solution: 'HOME',
                customization: null,
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/customers/%7BaccountID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "customization": null,
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"solution": @"HOME",
                                          @"customization": ,
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BaccountID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"John Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BaccountID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}');


            $request->setRequestUrl('https://api.gridx.de/customers/%7BaccountID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/customers/%7BaccountID%7D", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers/%7BaccountID%7D"


            payload = {
                "name": "John Doe",
                "email": "john@doe.com",
                "solution": "HOME",
                "customization": None,
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/customers/%7BaccountID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"John
            Doe\",\"email\":\"john@doe.com\",\"solution\":\"HOME\",\"customization\":null,\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/customers/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"John
            Doe","email":"john@doe.com","solution":"HOME","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}'
            |  \
              http PATCH https://api.gridx.de/customers/%7BaccountID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"John Doe","email":"john@doe.com","solution":"HOME","customization":null,"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"}}' \
              --output-document \
              - https://api.gridx.de/customers/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "John Doe",
              "email": "john@doe.com",
              "solution": "HOME",
              "customization": ,
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Customer
      description: Delete a customer given its ID.
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersWrite
      parameters:
        - *ref_1
        - *ref_69
      responses:
        '204':
          description: Customer deleted.
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/customers/%7BaccountID%7D',
              qs: {'delete-auth0': 'SOME_BOOLEAN_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/customers/%7BaccountID%7D");


            req.query({
              "delete-auth0": "SOME_BOOLEAN_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/customers/%7BaccountID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setQueryData([
              'delete-auth0' => 'SOME_BOOLEAN_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/customers/%7BaccountID%7D');

            $request->setRequestMethod('DELETE');

            $request->setQuery(new http\QueryString([
              'delete-auth0' => 'SOME_BOOLEAN_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers/%7BaccountID%7D"


            querystring = {"delete-auth0":"SOME_BOOLEAN_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url 'https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            'https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BaccountID%7D?delete-auth0=SOME_BOOLEAN_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/customers/{customerID}/users':
    get:
      summary: List Customer's users
      description: Get a list of all users that belong to this customer.
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersUsersRead
      parameters:
        - &ref_71
          name: customerID
          description: >
            customerID is universally unique identifier (UUID V4) used identify
            a

            customer in our backend.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 37874c1b-d073-4b06-bf01-a1497fbe1142
        - *ref_18
        - *ref_17
        - *ref_67
        - *ref_70
      responses:
        '200':
          description: Users returned
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_29
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/customers/%7BcustomerID%7D/users',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                sort: 'SOME_STRING_VALUE',
                order: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/customers/%7BcustomerID%7D/users");


            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "sort": "SOME_STRING_VALUE",
              "order": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BcustomerID%7D/users');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE',
              'order' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/customers/%7BcustomerID%7D/users');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE',
              'order' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers/%7BcustomerID%7D/users"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","sort":"SOME_STRING_VALUE","order":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BcustomerID%7D/users?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create User in Customer
      description: Create a new user for the customer.
      parameters:
        - *ref_71
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersUsersWrite
      requestBody:
        description: Create user
        required: true
        content:
          application/json:
            schema: &ref_180
              allOf:
                - *ref_29
                - additionalProperties: false
      responses:
        '201':
          description: User created.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_29
        '400': *ref_15
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BcustomerID%7D/users");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BcustomerID%7D/users");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BcustomerID%7D/users\"\n\n\tpayload := strings.NewReader(\"{\\\"newPassword\\\":\\\"string\\\",\\\"mfaReset\\\":true,\\\"fullName\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"groups\\\":[{\\\"name\\\":\\\"group name\\\",\\\"description\\\":\\\"Group provides read-access to accounts\\\"}],\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"},\\\"language\\\":{\\\"tag\\\":\\\"de_DE\\\"}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BcustomerID%7D/users")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/customers/%7BcustomerID%7D/users")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BcustomerID%7D/users",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "newPassword": "string",
              "mfaReset": true,
              "fullName": "John Doe",
              "email": "john@doe.com",
              "groups": [
                {
                  "name": "group name",
                  "description": "Group provides read-access to accounts"
                }
              ],
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              },
              "language": {
                "tag": "de_DE"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/customers/%7BcustomerID%7D/users");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BcustomerID%7D/users",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BcustomerID%7D/users",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              newPassword: 'string',
              mfaReset: true,
              fullName: 'John Doe',
              email: 'john@doe.com',
              groups: [{name: 'group name', description: 'Group provides read-access to accounts'}],
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              },
              language: {tag: 'de_DE'}
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/customers/%7BcustomerID%7D/users',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                newPassword: 'string',
                mfaReset: true,
                fullName: 'John Doe',
                email: 'john@doe.com',
                groups: [{name: 'group name', description: 'Group provides read-access to accounts'}],
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                },
                language: {tag: 'de_DE'}
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/customers/%7BcustomerID%7D/users");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "newPassword": "string",
              "mfaReset": true,
              "fullName": "John Doe",
              "email": "john@doe.com",
              "groups": [
                {
                  "name": "group name",
                  "description": "Group provides read-access to accounts"
                }
              ],
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              },
              "language": {
                "tag": "de_DE"
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"newPassword": @"string",
                                          @"mfaReset": @YES,
                                          @"fullName": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"groups": @[ @{ @"name": @"group name", @"description": @"Group provides read-access to accounts" } ],
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" },
                                          @"language": @{ @"tag": @"de_DE" } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BcustomerID%7D/users"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BcustomerID%7D/users" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BcustomerID%7D/users",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BcustomerID%7D/users');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}');


            $request->setRequestUrl('https://api.gridx.de/customers/%7BcustomerID%7D/users');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/customers/%7BcustomerID%7D/users", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers/%7BcustomerID%7D/users"


            payload = {
                "newPassword": "string",
                "mfaReset": True,
                "fullName": "John Doe",
                "email": "john@doe.com",
                "groups": [
                    {
                        "name": "group name",
                        "description": "Group provides read-access to accounts"
                    }
                ],
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                },
                "language": {"tag": "de_DE"}
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/customers/%7BcustomerID%7D/users")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/customers/%7BcustomerID%7D/users \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"newPassword":"string","mfaReset":true,"fullName":"John Doe","email":"john@doe.com","groups":[{"name":"group name","description":"Group provides read-access to accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}'
            |  \
              http POST https://api.gridx.de/customers/%7BcustomerID%7D/users \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"newPassword":"string","mfaReset":true,"fullName":"John Doe","email":"john@doe.com","groups":[{"name":"group name","description":"Group provides read-access to accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}' \
              --output-document \
              - https://api.gridx.de/customers/%7BcustomerID%7D/users
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "newPassword": "string",
              "mfaReset": true,
              "fullName": "John Doe",
              "email": "john@doe.com",
              "groups": [
                [
                  "name": "group name",
                  "description": "Group provides read-access to accounts"
                ]
              ],
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ],
              "language": ["tag": "de_DE"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BcustomerID%7D/users")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/customers/{customerID}/users/{userID}/impersonation':
    post:
      summary: Create Redirect Token
      description: Create a new token for the customer's user.
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersUsersImpersonationWrite
      parameters:
        - *ref_71
        - *ref_36
      requestBody: &ref_205
        description: Impersonate as user
        required: true
        content:
          application/json:
            schema: &ref_356
              description: Impersonate as user
              type: object
              properties:
                dashboard:
                  type: string
                  example: 'https://my.gridx.de'
              additionalProperties: false
              required:
                - dashboard
      responses:
        '201': &ref_249
          description: Impersonated.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: object
                properties:
                  dashboard:
                    type: string
                    example: 'https://my.gridx.de'
                  location:
                    type: string
                required:
                  - dashboard
                  - location
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"dashboard\":\"https://my.gridx.de\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"dashboard\":\"https://my.gridx.de\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation\"\n\n\tpayload := strings.NewReader(\"{\\\"dashboard\\\":\\\"https://my.gridx.de\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"dashboard\":\"https://my.gridx.de\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"dashboard\":\"https://my.gridx.de\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"dashboard\":\"https://my.gridx.de\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "dashboard": "https://my.gridx.de"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"dashboard\":\"https://my.gridx.de\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({dashboard: 'https://my.gridx.de'}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {dashboard: 'https://my.gridx.de'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "dashboard": "https://my.gridx.de"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"dashboard": @"https://my.gridx.de"
            };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"dashboard\":\"https://my.gridx.de\"}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"dashboard\":\"https://my.gridx.de\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"dashboard":"https://my.gridx.de"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"dashboard":"https://my.gridx.de"}');


            $request->setRequestUrl('https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"dashboard\":\"https://my.gridx.de\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation"


            payload = {"dashboard": "https://my.gridx.de"}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"dashboard\":\"https://my.gridx.de\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"dashboard":"https://my.gridx.de"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"dashboard":"https://my.gridx.de"}' |  \
              http POST https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"dashboard":"https://my.gridx.de"}' \
              --output-document \
              - https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["dashboard": "https://my.gridx.de"] as [String :
            Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BcustomerID%7D/users/%7BuserID%7D/impersonation")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/customers/{accountID}/systems':
    get:
      summary: List Systems of a Account
      description: List Systems that belong to a Account of a Customer
      tags:
        - System
        - Customer
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - *ref_1
      responses:
        '200':
          description: List of Systems returned.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_72
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BaccountID%7D/systems");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BaccountID%7D/systems");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BaccountID%7D/systems\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BaccountID%7D/systems")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/customers/%7BaccountID%7D/systems")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D/systems",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/customers/%7BaccountID%7D/systems");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D/systems",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BaccountID%7D/systems",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/customers/%7BaccountID%7D/systems',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/customers/%7BaccountID%7D/systems");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BaccountID%7D/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BaccountID%7D/systems" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BaccountID%7D/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BaccountID%7D/systems');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/customers/%7BaccountID%7D/systems');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/customers/%7BaccountID%7D/systems",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/customers/%7BaccountID%7D/systems"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/customers/%7BaccountID%7D/systems")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/customers/%7BaccountID%7D/systems \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/customers/%7BaccountID%7D/systems \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/customers/%7BaccountID%7D/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BaccountID%7D/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Adds a System to an Account
      description: Adds a new System to an Account of a Customer
      tags:
        - System
        - Customer
      security:
        - BearerAuth:
            - SystemsWrite
      parameters:
        - *ref_1
      requestBody: *ref_73
      responses:
        '201':
          description: System added
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_10
        '400': *ref_15
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BaccountID%7D/systems");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BaccountID%7D/systems");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BaccountID%7D/systems\"\n\n\tpayload := strings.NewReader(\"{\\\"moveSystemsAndCustomers\\\":true,\\\"moveVendorID\\\":true,\\\"uuids\\\":[\\\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\\\"]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BaccountID%7D/systems")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/customers/%7BaccountID%7D/systems")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D/systems",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": [
                "aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/customers/%7BaccountID%7D/systems");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D/systems",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BaccountID%7D/systems",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              moveSystemsAndCustomers: true,
              moveVendorID: true,
              uuids: ['aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc']
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/customers/%7BaccountID%7D/systems',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                moveSystemsAndCustomers: true,
                moveVendorID: true,
                uuids: ['aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc']
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/customers/%7BaccountID%7D/systems");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": [
                "aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"moveSystemsAndCustomers": @YES,
                                          @"moveVendorID": @YES,
                                          @"uuids": @[ @"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc" ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BaccountID%7D/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BaccountID%7D/systems" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BaccountID%7D/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BaccountID%7D/systems');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}');


            $request->setRequestUrl('https://api.gridx.de/customers/%7BaccountID%7D/systems');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/customers/%7BaccountID%7D/systems", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/customers/%7BaccountID%7D/systems"


            payload = {
                "moveSystemsAndCustomers": True,
                "moveVendorID": True,
                "uuids": ["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/customers/%7BaccountID%7D/systems")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"moveSystemsAndCustomers\":true,\"moveVendorID\":true,\"uuids\":[\"aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc\"]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/customers/%7BaccountID%7D/systems \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}'
            |  \
              http POST https://api.gridx.de/customers/%7BaccountID%7D/systems \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"moveSystemsAndCustomers":true,"moveVendorID":true,"uuids":["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]}' \
              --output-document \
              - https://api.gridx.de/customers/%7BaccountID%7D/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "moveSystemsAndCustomers": true,
              "moveVendorID": true,
              "uuids": ["aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BaccountID%7D/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/customers/{accountID}/users/{userID}/logins':
    get:
      summary: List Login Events of a User
      description: returns a list of authentication events of the authenticated user
      tags:
        - Customer
      security:
        - BearerAuth:
            - CustomersUsersRead
      parameters:
        - *ref_36
        - *ref_1
      responses:
        '200':
          description: return a list of authentication events
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_351
                  title: AuthEvent
                  description: >-
                    AuthEvent represents auth events such as login, password
                    reset.
                  type: object
                  properties:
                    createdAt:
                      type: string
                      format: date-time
                      readOnly: true
                    type:
                      type: string
                    ip:
                      type: string
                      format: ip
                      example: 192.168.178.153
                      description: IP is the IP address of the person who created the event
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/customers/%7BaccountID%7D/users/%7BuserID%7D/logins",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/customers/%7BaccountID%7D/users/%7BuserID%7D/logins",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/customers/%7BaccountID%7D/users/%7BuserID%7D/logins")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/gateways/{gatewayID}/import-power-limit':
    get:
      summary: Retrieve gateway's current import power limit.
      tags:
        - Import Power Limit
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - &ref_74
          name: systemID
          description: |
            Unique identifier used to access a system.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: aa3e5a93-bb38-4b15-b7f2-af40daf3a1dc
        - &ref_75
          name: gatewayID
          description: |
            Unique identifier used to access a gateway.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 4ef41512-8445-4b90-aa53-8f8549b3f4bd
      responses:
        '200': &ref_250
          description: Import power limit returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_77
                allOf:
                  - &ref_76
                    title: Import power limit
                    type: object
                    properties:
                      maxImportTotal:
                        type: integer
                        description: Maximum total import power in W.
                        format: int64
                      maxImportL1:
                        type: integer
                        description: Maximum total import power in the first phase in W.
                        format: int64
                      maxImportL2:
                        type: integer
                        description: Maximum total import power in the second phase in W.
                        format: int64
                      maxImportL3:
                        type: integer
                        description: Maximum total import power in the third phase in W.
                        format: int64
                      importEVMarginTotal:
                        type: integer
                        format: int64
                      importEVMarginPhase:
                        type: integer
                        format: int64
                      maxImportEVMarginL1:
                        type: integer
                        description: Maximum import power margin in the first phase in W.
                        format: int64
                      maxImportEVMarginL2:
                        type: integer
                        description: Maximum import power margin in the second phase in W.
                        format: int64
                      maxImportEVMarginL3:
                        type: integer
                        description: Maximum import power margin in the third phase in W.
                        format: int64
                      maxImportEVWorstCase:
                        type: integer
                        description: >-
                          The assumed maximum charging power in W for all EVs in
                          case the connection to the grid connection point is
                          lost.
                        format: int64
                      maxImportEVWorstCaseL1:
                        type: integer
                        description: >-
                          The assumed maximum charging power in W for all EVs in
                          case the connection to the grid connection point is
                          lost for the first phase.
                        format: int64
                      maxImportEVWorstCaseL2:
                        type: integer
                        description: >-
                          The assumed maximum charging power in W for all EVs in
                          case the connection to the grid connection point is
                          lost for the second phase.
                        format: int64
                      maxImportEVWorstCaseL3:
                        type: integer
                        description: >-
                          The assumed maximum charging power in W for all EVs in
                          case the connection to the grid connection point is
                          lost for the third phase.
                        format: int64
                  - properties:
                      internalDeviceID:
                        type: string
                        description: >-
                          Unique ID to identify the gateway the import power
                          limit belongs to.
                        example: >-
                          aeb639cf0793e81f0804c6647af7f0900a847921c0596726f1afdfd04a3a3186
                        readOnly: true
                      createdAt:
                        type: string
                        description: >-
                          Time at which the import power limit was created in
                          UTC using the RFC3339 format.
                        example: '2021-10-10T23:20:50Z'
                        format: date-time
                        readOnly: true
                      updatedAt:
                        type: string
                        description: >-
                          Time at which the import power limit was updated in
                          UTC using the RFC3339 format.
                        example: '2021-10-10T23:20:50Z'
                        format: date-time
                        readOnly: true
                    required:
                      - internalDeviceID
                      - createdAt
                      - updatedAt
                      - maxImportTotal
                      - maxImportL1
                      - maxImportL2
                      - maxImportL3
                      - importEVMarginTotal
                      - importEVMarginPhase
                      - maxImportEVMarginL1
                      - maxImportEVMarginL2
                      - maxImportEVMarginL3
                      - maxImportEVWorstCase
                      - maxImportEVWorstCaseL1
                      - maxImportEVWorstCaseL2
                      - maxImportEVWorstCaseL3
        '403': *ref_11
        '404': &ref_252
          description: Import power limit not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    put:
      summary: Set gateway's import power limit.
      tags:
        - Import Power Limit
      security:
        - BearerAuth:
            - SystemsWrite
      parameters:
        - *ref_74
        - *ref_75
      requestBody: &ref_206
        description: Set a gateway's import power limit.
        required: true
        content:
          application/json:
            schema: &ref_357
              allOf:
                - *ref_76
                - additionalProperties: false
      responses:
        '201': &ref_251
          description: Import power limit set.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_77
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit\"\n\n\tpayload := strings.NewReader(\"{\\\"maxImportTotal\\\":0,\\\"maxImportL1\\\":0,\\\"maxImportL2\\\":0,\\\"maxImportL3\\\":0,\\\"importEVMarginTotal\\\":0,\\\"importEVMarginPhase\\\":0,\\\"maxImportEVMarginL1\\\":0,\\\"maxImportEVMarginL2\\\":0,\\\"maxImportEVMarginL3\\\":0,\\\"maxImportEVWorstCase\\\":0,\\\"maxImportEVWorstCaseL1\\\":0,\\\"maxImportEVWorstCaseL2\\\":0,\\\"maxImportEVWorstCaseL3\\\":0}\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")
              .put(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "maxImportTotal": 0,
              "maxImportL1": 0,
              "maxImportL2": 0,
              "maxImportL3": 0,
              "importEVMarginTotal": 0,
              "importEVMarginPhase": 0,
              "maxImportEVMarginL1": 0,
              "maxImportEVMarginL2": 0,
              "maxImportEVMarginL3": 0,
              "maxImportEVWorstCase": 0,
              "maxImportEVWorstCaseL1": 0,
              "maxImportEVWorstCaseL2": 0,
              "maxImportEVWorstCaseL3": 0
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              maxImportTotal: 0,
              maxImportL1: 0,
              maxImportL2: 0,
              maxImportL3: 0,
              importEVMarginTotal: 0,
              importEVMarginPhase: 0,
              maxImportEVMarginL1: 0,
              maxImportEVMarginL2: 0,
              maxImportEVMarginL3: 0,
              maxImportEVWorstCase: 0,
              maxImportEVWorstCaseL1: 0,
              maxImportEVWorstCaseL2: 0,
              maxImportEVWorstCaseL3: 0
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                maxImportTotal: 0,
                maxImportL1: 0,
                maxImportL2: 0,
                maxImportL3: 0,
                importEVMarginTotal: 0,
                importEVMarginPhase: 0,
                maxImportEVMarginL1: 0,
                maxImportEVMarginL2: 0,
                maxImportEVMarginL3: 0,
                maxImportEVWorstCase: 0,
                maxImportEVWorstCaseL1: 0,
                maxImportEVWorstCaseL2: 0,
                maxImportEVWorstCaseL3: 0
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "maxImportTotal": 0,
              "maxImportL1": 0,
              "maxImportL2": 0,
              "maxImportL3": 0,
              "importEVMarginTotal": 0,
              "importEVMarginPhase": 0,
              "maxImportEVMarginL1": 0,
              "maxImportEVMarginL2": 0,
              "maxImportEVMarginL3": 0,
              "maxImportEVWorstCase": 0,
              "maxImportEVWorstCaseL1": 0,
              "maxImportEVWorstCaseL2": 0,
              "maxImportEVWorstCaseL3": 0
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"maxImportTotal": @0,
                                          @"maxImportL1": @0,
                                          @"maxImportL2": @0,
                                          @"maxImportL3": @0,
                                          @"importEVMarginTotal": @0,
                                          @"importEVMarginPhase": @0,
                                          @"maxImportEVMarginL1": @0,
                                          @"maxImportEVMarginL2": @0,
                                          @"maxImportEVMarginL3": @0,
                                          @"maxImportEVWorstCase": @0,
                                          @"maxImportEVWorstCaseL1": @0,
                                          @"maxImportEVWorstCaseL2": @0,
                                          @"maxImportEVWorstCaseL3": @0 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}"
            in


            Client.call ~headers ~body `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_POSTFIELDS => "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"maxImportTotal":0,"maxImportL1":0,"maxImportL2":0,"maxImportL3":0,"importEVMarginTotal":0,"importEVMarginPhase":0,"maxImportEVMarginL1":0,"maxImportEVMarginL2":0,"maxImportEVMarginL3":0,"maxImportEVWorstCase":0,"maxImportEVWorstCaseL1":0,"maxImportEVWorstCaseL2":0,"maxImportEVWorstCaseL3":0}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"maxImportTotal":0,"maxImportL1":0,"maxImportL2":0,"maxImportL3":0,"importEVMarginTotal":0,"importEVMarginPhase":0,"maxImportEVMarginL1":0,"maxImportEVMarginL2":0,"maxImportEVMarginL3":0,"maxImportEVWorstCase":0,"maxImportEVWorstCaseL1":0,"maxImportEVWorstCaseL2":0,"maxImportEVWorstCaseL3":0}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit');

            $request->setRequestMethod('PUT');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PUT",
            "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"


            payload = {
                "maxImportTotal": 0,
                "maxImportL1": 0,
                "maxImportL2": 0,
                "maxImportL3": 0,
                "importEVMarginTotal": 0,
                "importEVMarginPhase": 0,
                "maxImportEVMarginL1": 0,
                "maxImportEVMarginL2": 0,
                "maxImportEVMarginL3": 0,
                "maxImportEVWorstCase": 0,
                "maxImportEVWorstCaseL1": 0,
                "maxImportEVWorstCaseL2": 0,
                "maxImportEVWorstCaseL3": 0
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PUT", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"maxImportTotal\":0,\"maxImportL1\":0,\"maxImportL2\":0,\"maxImportL3\":0,\"importEVMarginTotal\":0,\"importEVMarginPhase\":0,\"maxImportEVMarginL1\":0,\"maxImportEVMarginL2\":0,\"maxImportEVMarginL3\":0,\"maxImportEVWorstCase\":0,\"maxImportEVWorstCaseL1\":0,\"maxImportEVWorstCaseL2\":0,\"maxImportEVWorstCaseL3\":0}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"maxImportTotal":0,"maxImportL1":0,"maxImportL2":0,"maxImportL3":0,"importEVMarginTotal":0,"importEVMarginPhase":0,"maxImportEVMarginL1":0,"maxImportEVMarginL2":0,"maxImportEVMarginL3":0,"maxImportEVWorstCase":0,"maxImportEVWorstCaseL1":0,"maxImportEVWorstCaseL2":0,"maxImportEVWorstCaseL3":0}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"maxImportTotal":0,"maxImportL1":0,"maxImportL2":0,"maxImportL3":0,"importEVMarginTotal":0,"importEVMarginPhase":0,"maxImportEVMarginL1":0,"maxImportEVMarginL2":0,"maxImportEVMarginL3":0,"maxImportEVWorstCase":0,"maxImportEVWorstCaseL1":0,"maxImportEVWorstCaseL2":0,"maxImportEVWorstCaseL3":0}'
            |  \
              http PUT https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"maxImportTotal":0,"maxImportL1":0,"maxImportL2":0,"maxImportL3":0,"importEVMarginTotal":0,"importEVMarginPhase":0,"maxImportEVMarginL1":0,"maxImportEVMarginL2":0,"maxImportEVMarginL3":0,"maxImportEVWorstCase":0,"maxImportEVWorstCaseL1":0,"maxImportEVWorstCaseL2":0,"maxImportEVWorstCaseL3":0}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "maxImportTotal": 0,
              "maxImportL1": 0,
              "maxImportL2": 0,
              "maxImportL3": 0,
              "importEVMarginTotal": 0,
              "importEVMarginPhase": 0,
              "maxImportEVMarginL1": 0,
              "maxImportEVMarginL2": 0,
              "maxImportEVMarginL3": 0,
              "maxImportEVWorstCase": 0,
              "maxImportEVWorstCaseL1": 0,
              "maxImportEVWorstCaseL2": 0,
              "maxImportEVWorstCaseL3": 0
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete gateway's import power limit.
      tags:
        - Import Power Limit
      security:
        - BearerAuth:
            - SystemsWrite
      parameters:
        - *ref_74
        - *ref_75
      responses:
        '204':
          description: Import power limit deleted successfully!
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/gateways/{gatewayID}/import-power-limit/historical':
    get:
      summary: Get gateway's historical import power limits.
      tags:
        - Import Power Limit
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - *ref_74
        - *ref_75
      responses:
        '200': &ref_253
          description: Historical import power limits returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_359
                title: Historical import power limit
                type: object
                properties:
                  systemID:
                    type: string
                    format: uuid
                    description: >-
                      Unique ID to identify the system the import power limits
                      belong to.
                    readOnly: true
                    example: 512654ea-5328-4c79-8ed7-b4136aa31679
                  data:
                    type: array
                    items: &ref_358
                      title: Import power limits stored with the dynamic API.
                      type: object
                      properties:
                        maxImportMeasuredTimestamp:
                          type: string
                          description: >-
                            Time at which the import power limit was created in
                            UTC using the RFC3339 format.
                          example: '2021-10-10T23:20:50Z'
                          format: date-time
                          readOnly: true
                        maxImportTotal:
                          type: integer
                          format: int64
                          description: Maximum total import power in mW.
                        maxImportL1:
                          type: integer
                          format: int64
                          description: Maximum total import power in the first phase in mW.
                        maxImportL2:
                          type: integer
                          format: int64
                          description: >-
                            Maximum total import power in the second phase in
                            mW.
                        maxImportL3:
                          type: integer
                          format: int64
                          description: Maximum total import power in the third phase in mW.
                        maxImportEvMarginTotal:
                          type: integer
                          format: int64
                          description: >-
                            maxImportTotal - importEVMarginTotal is the maximum
                            import power considered in total in mW.
                        maxImportEvMarginL1:
                          type: integer
                          format: int64
                          description: >-
                            Maximum import power margin in the first phase in
                            mW.
                        maxImportEvMarginL2:
                          type: integer
                          format: int64
                          description: >-
                            Maximum import power margin in the second phase in
                            mW.
                        maxImportEvMarginL3:
                          type: integer
                          format: int64
                          description: >-
                            Maximum import power margin in the third phase in
                            mW.
                        maxImportEvMarginWorstCaseTotal:
                          type: integer
                          format: int64
                          description: >-
                            The assumed maximum charging power in mW for all EVs
                            in case the connection to the grid connection point
                            is lost.
                        maxImportEvMarginWorstCaseL1:
                          type: integer
                          format: int64
                          description: >-
                            The assumed maximum charging power in mW for all EVs
                            in case the connection to the grid connection point
                            is lost for the first phase.
                        maxImportEvMarginWorstCaseL2:
                          type: integer
                          format: int64
                          description: >-
                            The assumed maximum charging power in mW for all EVs
                            in case the connection to the grid connection point
                            is lost for the second phase.
                        maxImportEvMarginWorstCaseL3:
                          type: integer
                          format: int64
                          description: >-
                            The assumed maximum charging power in mW for all EVs
                            in case the connection to the grid connection point
                            is lost for the third phase.
                      required:
                        - maxImportMeasuredTimestamp
                        - maxImportTotal
                        - maxImportL1
                        - maxImportL2
                        - maxImportL3
                        - maxImportEvMarginTotal
                        - maxImportEvMarginL1
                        - maxImportEvMarginL2
                        - maxImportEvMarginL3
                        - maxImportEvMarginWorstCaseTotal
                        - maxImportEvMarginWorstCaseL1
                        - maxImportEvMarginWorstCaseL2
                        - maxImportEvMarginWorstCaseL3
                required:
                  - systemID
                  - data
        '403': *ref_11
        '404': &ref_254
          description: Historical import power limits not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways/%7BgatewayID%7D/import-power-limit/historical")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /systems:
    get:
      summary: List all Systems
      description: List systems that are accessible to the authenticated user.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - *ref_18
        - *ref_17
        - *ref_78
      responses:
        '200':
          description: >
            An array of systems of up to `per_page` systems.


            Each entry in the array is a separate system. If no system is
            available, the resulting array will be empty.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_79
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                embed: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/systems");

            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "embed": "SOME_STRING_VALUE"
            });

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/systems');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'embed' => 'SOME_STRING_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/systems');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'embed' => 'SOME_STRING_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","embed":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&embed=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a System
      description: Creates a System.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsWrite
      requestBody: &ref_209
        description: The body of a system creation request.
        required: true
        content:
          application/json:
            schema: &ref_372
              allOf:
                - &ref_371
                  type: object
                  allOf:
                    - *ref_80
                    - type: object
                      properties:
                        priorities:
                          readOnly: true
                        curtailmentStrategy:
                          readOnly: true
                - additionalProperties: false
      responses:
        '201': &ref_257
          description: The created system.
          content:
            application/vnd.gridx.v2+json:
              schema:
                allOf:
                  - *ref_80
                  - *ref_81
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/systems");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"gridX
            Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/systems");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"gridX
            Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"gridX Headquarter\\\",\\\"solution\\\":\\\"HOME\\\",\\\"labels\\\":[\\\"beta\\\",\\\"sma\\\"],\\\"priorities\\\":[\\\"EV\\\",\\\"BATTERY\\\"],\\\"appliancePriorities\\\":[\\\"497f6eca-6276-4993-bfeb-53cbbbba6f08\\\"],\\\"tariffID\\\":\\\"string\\\",\\\"plan\\\":\\\"string\\\",\\\"operatingSince\\\":\\\"2017-12-23T10:15:40Z\\\",\\\"curtailmentStrategy\\\":\\\"SERIES\\\",\\\"location\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"countryCode\\\":\\\"DE\\\",\\\"postalCode\\\":\\\"52062\\\"},\\\"metadata\\\":{\\\"wizard\\\":{\\\"step\\\":\\\"string\\\"},\\\"energy\\\":{\\\"installer\\\":\\\"string\\\",\\\"norminalPower\\\":0,\\\"curtailment\\\":0,\\\"heatingSystem\\\":\\\"string\\\",\\\"agreedEMSTerms\\\":true,\\\"ems\\\":{\\\"agreedEMSTerms\\\":true,\\\"enabledEMS\\\":true,\\\"agreedDynamicPVControlTerms\\\":true,\\\"enabledDynamicPVControl\\\":true,\\\"agreedForecastBasedEMSTerms\\\":true,\\\"enabledForecastBasedEMS\\\":true,\\\"agreedPriorityConfigurationTerms\\\":true,\\\"enabledPriorityConfiguration\\\":true,\\\"agreedPowerManagementTerms\\\":true,\\\"enabledPowerManagement\\\":true,\\\"enabledStaticPowerManagement\\\":true,\\\"enabledPowerImportPeakOptimization\\\":true,\\\"powerImportPeakPerOptimizationInterval\\\":0.1,\\\"enabledPVSurplusChargeMode\\\":true,\\\"powerPVSurplusThreshold\\\":0.1,\\\"pVSurplusActiveAt\\\":\\\"2020-09-21T00:00:00Z\\\",\\\"pVSurplusInactiveAt\\\":\\\"2020-09-21T00:00:00Z\\\",\\\"enabledBatteryFullGridCharge\\\":true,\\\"enabledLessConstrainingSOCLimits\\\":true,\\\"derAPISettings\\\":{\\\"enabledCloudAPI\\\":true,\\\"constraints\\\":{\\\"syncInterval\\\":0.1,\\\"ttl\\\":0.1,\\\"disabled\\\":true},\\\"flexibilities\\\":{\\\"syncInterval\\\":0.1,\\\"ttl\\\":0.1,\\\"disabled\\\":true}},\\\"enabledTimeOfUseOptimization\\\":true,\\\"disableAveragePmaxCalculation\\\":true,\\\"excludeApplianceTypes\\\":[\\\"HEAT_PUMP\\\"],\\\"evChargingReallocationTolerance\\\":500000},\\\"smartMeterInstallationTimestamp\\\":\\\"2020-09-21T00:00:00Z\\\"},\\\"energySupplier\\\":{\\\"type\\\":\\\"GRIDX\\\",\\\"unitPrice\\\":0,\\\"installment\\\":0,\\\"baseFee\\\":0,\\\"feedInTariff\\\":0,\\\"expectedConsumption\\\":0},\\\"smartMeter\\\":{\\\"installed\\\":true,\\\"hasInstallationDate\\\":true},\\\"electricVehicle\\\":{\\\"manufacturer\\\":\\\"string\\\",\\\"model\\\":\\\"string\\\",\\\"capacity\\\":0,\\\"averageConsumption\\\":0,\\\"phasesCount\\\":1},\\\"electricVehicleProfiles\\\":[{\\\"manufacturer\\\":\\\"string\\\",\\\"model\\\":\\\"string\\\",\\\"capacity\\\":0,\\\"averageConsumption\\\":0,\\\"phasesCount\\\":1,\\\"chargingStationApplianceID\\\":\\\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\\\"}],\\\"availableSavings\\\":[\\\"CAPACITY_TARIFF_OPTIMIZATION\\\"]}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"gridX
            Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"gridX Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"gridX Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "gridX Headquarter",
              "solution": "HOME",
              "labels": [
                "beta",
                "sma"
              ],
              "priorities": [
                "EV",
                "BATTERY"
              ],
              "appliancePriorities": [
                "497f6eca-6276-4993-bfeb-53cbbbba6f08"
              ],
              "tariffID": "string",
              "plan": "string",
              "operatingSince": "2017-12-23T10:15:40Z",
              "curtailmentStrategy": "SERIES",
              "location": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "countryCode": "DE",
                "postalCode": "52062"
              },
              "metadata": {
                "wizard": {
                  "step": "string"
                },
                "energy": {
                  "installer": "string",
                  "norminalPower": 0,
                  "curtailment": 0,
                  "heatingSystem": "string",
                  "agreedEMSTerms": true,
                  "ems": {
                    "agreedEMSTerms": true,
                    "enabledEMS": true,
                    "agreedDynamicPVControlTerms": true,
                    "enabledDynamicPVControl": true,
                    "agreedForecastBasedEMSTerms": true,
                    "enabledForecastBasedEMS": true,
                    "agreedPriorityConfigurationTerms": true,
                    "enabledPriorityConfiguration": true,
                    "agreedPowerManagementTerms": true,
                    "enabledPowerManagement": true,
                    "enabledStaticPowerManagement": true,
                    "enabledPowerImportPeakOptimization": true,
                    "powerImportPeakPerOptimizationInterval": 0.1,
                    "enabledPVSurplusChargeMode": true,
                    "powerPVSurplusThreshold": 0.1,
                    "pVSurplusActiveAt": "2020-09-21T00:00:00Z",
                    "pVSurplusInactiveAt": "2020-09-21T00:00:00Z",
                    "enabledBatteryFullGridCharge": true,
                    "enabledLessConstrainingSOCLimits": true,
                    "derAPISettings": {
                      "enabledCloudAPI": true,
                      "constraints": {
                        "syncInterval": 0.1,
                        "ttl": 0.1,
                        "disabled": true
                      },
                      "flexibilities": {
                        "syncInterval": 0.1,
                        "ttl": 0.1,
                        "disabled": true
                      }
                    },
                    "enabledTimeOfUseOptimization": true,
                    "disableAveragePmaxCalculation": true,
                    "excludeApplianceTypes": [
                      "HEAT_PUMP"
                    ],
                    "evChargingReallocationTolerance": 500000
                  },
                  "smartMeterInstallationTimestamp": "2020-09-21T00:00:00Z"
                },
                "energySupplier": {
                  "type": "GRIDX",
                  "unitPrice": 0,
                  "installment": 0,
                  "baseFee": 0,
                  "feedInTariff": 0,
                  "expectedConsumption": 0
                },
                "smartMeter": {
                  "installed": true,
                  "hasInstallationDate": true
                },
                "electricVehicle": {
                  "manufacturer": "string",
                  "model": "string",
                  "capacity": 0,
                  "averageConsumption": 0,
                  "phasesCount": 1
                },
                "electricVehicleProfiles": [
                  {
                    "manufacturer": "string",
                    "model": "string",
                    "capacity": 0,
                    "averageConsumption": 0,
                    "phasesCount": 1,
                    "chargingStationApplianceID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
                  }
                ],
                "availableSavings": [
                  "CAPACITY_TARIFF_OPTIMIZATION"
                ]
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/systems");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"gridX Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'gridX Headquarter',
              solution: 'HOME',
              labels: ['beta', 'sma'],
              priorities: ['EV', 'BATTERY'],
              appliancePriorities: ['497f6eca-6276-4993-bfeb-53cbbbba6f08'],
              tariffID: 'string',
              plan: 'string',
              operatingSince: '2017-12-23T10:15:40Z',
              curtailmentStrategy: 'SERIES',
              location: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                countryCode: 'DE',
                postalCode: '52062'
              },
              metadata: {
                wizard: {step: 'string'},
                energy: {
                  installer: 'string',
                  norminalPower: 0,
                  curtailment: 0,
                  heatingSystem: 'string',
                  agreedEMSTerms: true,
                  ems: {
                    agreedEMSTerms: true,
                    enabledEMS: true,
                    agreedDynamicPVControlTerms: true,
                    enabledDynamicPVControl: true,
                    agreedForecastBasedEMSTerms: true,
                    enabledForecastBasedEMS: true,
                    agreedPriorityConfigurationTerms: true,
                    enabledPriorityConfiguration: true,
                    agreedPowerManagementTerms: true,
                    enabledPowerManagement: true,
                    enabledStaticPowerManagement: true,
                    enabledPowerImportPeakOptimization: true,
                    powerImportPeakPerOptimizationInterval: 0.1,
                    enabledPVSurplusChargeMode: true,
                    powerPVSurplusThreshold: 0.1,
                    pVSurplusActiveAt: '2020-09-21T00:00:00Z',
                    pVSurplusInactiveAt: '2020-09-21T00:00:00Z',
                    enabledBatteryFullGridCharge: true,
                    enabledLessConstrainingSOCLimits: true,
                    derAPISettings: {
                      enabledCloudAPI: true,
                      constraints: {syncInterval: 0.1, ttl: 0.1, disabled: true},
                      flexibilities: {syncInterval: 0.1, ttl: 0.1, disabled: true}
                    },
                    enabledTimeOfUseOptimization: true,
                    disableAveragePmaxCalculation: true,
                    excludeApplianceTypes: ['HEAT_PUMP'],
                    evChargingReallocationTolerance: 500000
                  },
                  smartMeterInstallationTimestamp: '2020-09-21T00:00:00Z'
                },
                energySupplier: {
                  type: 'GRIDX',
                  unitPrice: 0,
                  installment: 0,
                  baseFee: 0,
                  feedInTariff: 0,
                  expectedConsumption: 0
                },
                smartMeter: {installed: true, hasInstallationDate: true},
                electricVehicle: {
                  manufacturer: 'string',
                  model: 'string',
                  capacity: 0,
                  averageConsumption: 0,
                  phasesCount: 1
                },
                electricVehicleProfiles: [
                  {
                    manufacturer: 'string',
                    model: 'string',
                    capacity: 0,
                    averageConsumption: 0,
                    phasesCount: 1,
                    chargingStationApplianceID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f'
                  }
                ],
                availableSavings: ['CAPACITY_TARIFF_OPTIMIZATION']
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'gridX Headquarter',
                solution: 'HOME',
                labels: ['beta', 'sma'],
                priorities: ['EV', 'BATTERY'],
                appliancePriorities: ['497f6eca-6276-4993-bfeb-53cbbbba6f08'],
                tariffID: 'string',
                plan: 'string',
                operatingSince: '2017-12-23T10:15:40Z',
                curtailmentStrategy: 'SERIES',
                location: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  countryCode: 'DE',
                  postalCode: '52062'
                },
                metadata: {
                  wizard: {step: 'string'},
                  energy: {
                    installer: 'string',
                    norminalPower: 0,
                    curtailment: 0,
                    heatingSystem: 'string',
                    agreedEMSTerms: true,
                    ems: {
                      agreedEMSTerms: true,
                      enabledEMS: true,
                      agreedDynamicPVControlTerms: true,
                      enabledDynamicPVControl: true,
                      agreedForecastBasedEMSTerms: true,
                      enabledForecastBasedEMS: true,
                      agreedPriorityConfigurationTerms: true,
                      enabledPriorityConfiguration: true,
                      agreedPowerManagementTerms: true,
                      enabledPowerManagement: true,
                      enabledStaticPowerManagement: true,
                      enabledPowerImportPeakOptimization: true,
                      powerImportPeakPerOptimizationInterval: 0.1,
                      enabledPVSurplusChargeMode: true,
                      powerPVSurplusThreshold: 0.1,
                      pVSurplusActiveAt: '2020-09-21T00:00:00Z',
                      pVSurplusInactiveAt: '2020-09-21T00:00:00Z',
                      enabledBatteryFullGridCharge: true,
                      enabledLessConstrainingSOCLimits: true,
                      derAPISettings: {
                        enabledCloudAPI: true,
                        constraints: {syncInterval: 0.1, ttl: 0.1, disabled: true},
                        flexibilities: {syncInterval: 0.1, ttl: 0.1, disabled: true}
                      },
                      enabledTimeOfUseOptimization: true,
                      disableAveragePmaxCalculation: true,
                      excludeApplianceTypes: ['HEAT_PUMP'],
                      evChargingReallocationTolerance: 500000
                    },
                    smartMeterInstallationTimestamp: '2020-09-21T00:00:00Z'
                  },
                  energySupplier: {
                    type: 'GRIDX',
                    unitPrice: 0,
                    installment: 0,
                    baseFee: 0,
                    feedInTariff: 0,
                    expectedConsumption: 0
                  },
                  smartMeter: {installed: true, hasInstallationDate: true},
                  electricVehicle: {
                    manufacturer: 'string',
                    model: 'string',
                    capacity: 0,
                    averageConsumption: 0,
                    phasesCount: 1
                  },
                  electricVehicleProfiles: [
                    {
                      manufacturer: 'string',
                      model: 'string',
                      capacity: 0,
                      averageConsumption: 0,
                      phasesCount: 1,
                      chargingStationApplianceID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f'
                    }
                  ],
                  availableSavings: ['CAPACITY_TARIFF_OPTIMIZATION']
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/systems");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "name": "gridX Headquarter",
              "solution": "HOME",
              "labels": [
                "beta",
                "sma"
              ],
              "priorities": [
                "EV",
                "BATTERY"
              ],
              "appliancePriorities": [
                "497f6eca-6276-4993-bfeb-53cbbbba6f08"
              ],
              "tariffID": "string",
              "plan": "string",
              "operatingSince": "2017-12-23T10:15:40Z",
              "curtailmentStrategy": "SERIES",
              "location": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "countryCode": "DE",
                "postalCode": "52062"
              },
              "metadata": {
                "wizard": {
                  "step": "string"
                },
                "energy": {
                  "installer": "string",
                  "norminalPower": 0,
                  "curtailment": 0,
                  "heatingSystem": "string",
                  "agreedEMSTerms": true,
                  "ems": {
                    "agreedEMSTerms": true,
                    "enabledEMS": true,
                    "agreedDynamicPVControlTerms": true,
                    "enabledDynamicPVControl": true,
                    "agreedForecastBasedEMSTerms": true,
                    "enabledForecastBasedEMS": true,
                    "agreedPriorityConfigurationTerms": true,
                    "enabledPriorityConfiguration": true,
                    "agreedPowerManagementTerms": true,
                    "enabledPowerManagement": true,
                    "enabledStaticPowerManagement": true,
                    "enabledPowerImportPeakOptimization": true,
                    "powerImportPeakPerOptimizationInterval": 0.1,
                    "enabledPVSurplusChargeMode": true,
                    "powerPVSurplusThreshold": 0.1,
                    "pVSurplusActiveAt": "2020-09-21T00:00:00Z",
                    "pVSurplusInactiveAt": "2020-09-21T00:00:00Z",
                    "enabledBatteryFullGridCharge": true,
                    "enabledLessConstrainingSOCLimits": true,
                    "derAPISettings": {
                      "enabledCloudAPI": true,
                      "constraints": {
                        "syncInterval": 0.1,
                        "ttl": 0.1,
                        "disabled": true
                      },
                      "flexibilities": {
                        "syncInterval": 0.1,
                        "ttl": 0.1,
                        "disabled": true
                      }
                    },
                    "enabledTimeOfUseOptimization": true,
                    "disableAveragePmaxCalculation": true,
                    "excludeApplianceTypes": [
                      "HEAT_PUMP"
                    ],
                    "evChargingReallocationTolerance": 500000
                  },
                  "smartMeterInstallationTimestamp": "2020-09-21T00:00:00Z"
                },
                "energySupplier": {
                  "type": "GRIDX",
                  "unitPrice": 0,
                  "installment": 0,
                  "baseFee": 0,
                  "feedInTariff": 0,
                  "expectedConsumption": 0
                },
                "smartMeter": {
                  "installed": true,
                  "hasInstallationDate": true
                },
                "electricVehicle": {
                  "manufacturer": "string",
                  "model": "string",
                  "capacity": 0,
                  "averageConsumption": 0,
                  "phasesCount": 1
                },
                "electricVehicleProfiles": [
                  {
                    "manufacturer": "string",
                    "model": "string",
                    "capacity": 0,
                    "averageConsumption": 0,
                    "phasesCount": 1,
                    "chargingStationApplianceID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
                  }
                ],
                "availableSavings": [
                  "CAPACITY_TARIFF_OPTIMIZATION"
                ]
              }
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"gridX Headquarter",
                                          @"solution": @"HOME",
                                          @"labels": @[ @"beta", @"sma" ],
                                          @"priorities": @[ @"EV", @"BATTERY" ],
                                          @"appliancePriorities": @[ @"497f6eca-6276-4993-bfeb-53cbbbba6f08" ],
                                          @"tariffID": @"string",
                                          @"plan": @"string",
                                          @"operatingSince": @"2017-12-23T10:15:40Z",
                                          @"curtailmentStrategy": @"SERIES",
                                          @"location": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"countryCode": @"DE", @"postalCode": @"52062" },
                                          @"metadata": @{ @"wizard": @{ @"step": @"string" }, @"energy": @{ @"installer": @"string", @"norminalPower": @0, @"curtailment": @0, @"heatingSystem": @"string", @"agreedEMSTerms": @YES, @"ems": @{ @"agreedEMSTerms": @YES, @"enabledEMS": @YES, @"agreedDynamicPVControlTerms": @YES, @"enabledDynamicPVControl": @YES, @"agreedForecastBasedEMSTerms": @YES, @"enabledForecastBasedEMS": @YES, @"agreedPriorityConfigurationTerms": @YES, @"enabledPriorityConfiguration": @YES, @"agreedPowerManagementTerms": @YES, @"enabledPowerManagement": @YES, @"enabledStaticPowerManagement": @YES, @"enabledPowerImportPeakOptimization": @YES, @"powerImportPeakPerOptimizationInterval": @0.1, @"enabledPVSurplusChargeMode": @YES, @"powerPVSurplusThreshold": @0.1, @"pVSurplusActiveAt": @"2020-09-21T00:00:00Z", @"pVSurplusInactiveAt": @"2020-09-21T00:00:00Z", @"enabledBatteryFullGridCharge": @YES, @"enabledLessConstrainingSOCLimits": @YES, @"derAPISettings": @{ @"enabledCloudAPI": @YES, @"constraints": @{ @"syncInterval": @0.1, @"ttl": @0.1, @"disabled": @YES }, @"flexibilities": @{ @"syncInterval": @0.1, @"ttl": @0.1, @"disabled": @YES } }, @"enabledTimeOfUseOptimization": @YES, @"disableAveragePmaxCalculation": @YES, @"excludeApplianceTypes": @[ @"HEAT_PUMP" ], @"evChargingReallocationTolerance": @500000 }, @"smartMeterInstallationTimestamp": @"2020-09-21T00:00:00Z" }, @"energySupplier": @{ @"type": @"GRIDX", @"unitPrice": @0, @"installment": @0, @"baseFee": @0, @"feedInTariff": @0, @"expectedConsumption": @0 }, @"smartMeter": @{ @"installed": @YES, @"hasInstallationDate": @YES }, @"electricVehicle": @{ @"manufacturer": @"string", @"model": @"string", @"capacity": @0, @"averageConsumption": @0, @"phasesCount": @1 }, @"electricVehicleProfiles": @[ @{ @"manufacturer": @"string", @"model": @"string", @"capacity": @0, @"averageConsumption": @0, @"phasesCount": @1, @"chargingStationApplianceID": @"6dd0a658-5828-4d30-bc65-a03c6d6e425f" } ], @"availableSavings": @[ @"CAPACITY_TARIFF_OPTIMIZATION" ] } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL URLWithString:@"https://api.gridx.de/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/systems" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"gridX
            Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"gridX Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"gridX
            Headquarter","solution":"HOME","labels":["beta","sma"],"priorities":["EV","BATTERY"],"appliancePriorities":["497f6eca-6276-4993-bfeb-53cbbbba6f08"],"tariffID":"string","plan":"string","operatingSince":"2017-12-23T10:15:40Z","curtailmentStrategy":"SERIES","location":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","countryCode":"DE","postalCode":"52062"},"metadata":{"wizard":{"step":"string"},"energy":{"installer":"string","norminalPower":0,"curtailment":0,"heatingSystem":"string","agreedEMSTerms":true,"ems":{"agreedEMSTerms":true,"enabledEMS":true,"agreedDynamicPVControlTerms":true,"enabledDynamicPVControl":true,"agreedForecastBasedEMSTerms":true,"enabledForecastBasedEMS":true,"agreedPriorityConfigurationTerms":true,"enabledPriorityConfiguration":true,"agreedPowerManagementTerms":true,"enabledPowerManagement":true,"enabledStaticPowerManagement":true,"enabledPowerImportPeakOptimization":true,"powerImportPeakPerOptimizationInterval":0.1,"enabledPVSurplusChargeMode":true,"powerPVSurplusThreshold":0.1,"pVSurplusActiveAt":"2020-09-21T00:00:00Z","pVSurplusInactiveAt":"2020-09-21T00:00:00Z","enabledBatteryFullGridCharge":true,"enabledLessConstrainingSOCLimits":true,"derAPISettings":{"enabledCloudAPI":true,"constraints":{"syncInterval":0.1,"ttl":0.1,"disabled":true},"flexibilities":{"syncInterval":0.1,"ttl":0.1,"disabled":true}},"enabledTimeOfUseOptimization":true,"disableAveragePmaxCalculation":true,"excludeApplianceTypes":["HEAT_PUMP"],"evChargingReallocationTolerance":500000},"smartMeterInstallationTimestamp":"2020-09-21T00:00:00Z"},"energySupplier":{"type":"GRIDX","unitPrice":0,"installment":0,"baseFee":0,"feedInTariff":0,"expectedConsumption":0},"smartMeter":{"installed":true,"hasInstallationDate":true},"electricVehicle":{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1},"electricVehicleProfiles":[{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1,"chargingStationApplianceID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}],"availableSavings":["CAPACITY_TARIFF_OPTIMIZATION"]}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"gridX
            Headquarter","solution":"HOME","labels":["beta","sma"],"priorities":["EV","BATTERY"],"appliancePriorities":["497f6eca-6276-4993-bfeb-53cbbbba6f08"],"tariffID":"string","plan":"string","operatingSince":"2017-12-23T10:15:40Z","curtailmentStrategy":"SERIES","location":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","countryCode":"DE","postalCode":"52062"},"metadata":{"wizard":{"step":"string"},"energy":{"installer":"string","norminalPower":0,"curtailment":0,"heatingSystem":"string","agreedEMSTerms":true,"ems":{"agreedEMSTerms":true,"enabledEMS":true,"agreedDynamicPVControlTerms":true,"enabledDynamicPVControl":true,"agreedForecastBasedEMSTerms":true,"enabledForecastBasedEMS":true,"agreedPriorityConfigurationTerms":true,"enabledPriorityConfiguration":true,"agreedPowerManagementTerms":true,"enabledPowerManagement":true,"enabledStaticPowerManagement":true,"enabledPowerImportPeakOptimization":true,"powerImportPeakPerOptimizationInterval":0.1,"enabledPVSurplusChargeMode":true,"powerPVSurplusThreshold":0.1,"pVSurplusActiveAt":"2020-09-21T00:00:00Z","pVSurplusInactiveAt":"2020-09-21T00:00:00Z","enabledBatteryFullGridCharge":true,"enabledLessConstrainingSOCLimits":true,"derAPISettings":{"enabledCloudAPI":true,"constraints":{"syncInterval":0.1,"ttl":0.1,"disabled":true},"flexibilities":{"syncInterval":0.1,"ttl":0.1,"disabled":true}},"enabledTimeOfUseOptimization":true,"disableAveragePmaxCalculation":true,"excludeApplianceTypes":["HEAT_PUMP"],"evChargingReallocationTolerance":500000},"smartMeterInstallationTimestamp":"2020-09-21T00:00:00Z"},"energySupplier":{"type":"GRIDX","unitPrice":0,"installment":0,"baseFee":0,"feedInTariff":0,"expectedConsumption":0},"smartMeter":{"installed":true,"hasInstallationDate":true},"electricVehicle":{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1},"electricVehicleProfiles":[{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1,"chargingStationApplianceID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}],"availableSavings":["CAPACITY_TARIFF_OPTIMIZATION"]}}');


            $request->setRequestUrl('https://api.gridx.de/systems');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"gridX
            Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems"


            payload = {
                "name": "gridX Headquarter",
                "solution": "HOME",
                "labels": ["beta", "sma"],
                "priorities": ["EV", "BATTERY"],
                "appliancePriorities": ["497f6eca-6276-4993-bfeb-53cbbbba6f08"],
                "tariffID": "string",
                "plan": "string",
                "operatingSince": "2017-12-23T10:15:40Z",
                "curtailmentStrategy": "SERIES",
                "location": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "countryCode": "DE",
                    "postalCode": "52062"
                },
                "metadata": {
                    "wizard": {"step": "string"},
                    "energy": {
                        "installer": "string",
                        "norminalPower": 0,
                        "curtailment": 0,
                        "heatingSystem": "string",
                        "agreedEMSTerms": True,
                        "ems": {
                            "agreedEMSTerms": True,
                            "enabledEMS": True,
                            "agreedDynamicPVControlTerms": True,
                            "enabledDynamicPVControl": True,
                            "agreedForecastBasedEMSTerms": True,
                            "enabledForecastBasedEMS": True,
                            "agreedPriorityConfigurationTerms": True,
                            "enabledPriorityConfiguration": True,
                            "agreedPowerManagementTerms": True,
                            "enabledPowerManagement": True,
                            "enabledStaticPowerManagement": True,
                            "enabledPowerImportPeakOptimization": True,
                            "powerImportPeakPerOptimizationInterval": 0.1,
                            "enabledPVSurplusChargeMode": True,
                            "powerPVSurplusThreshold": 0.1,
                            "pVSurplusActiveAt": "2020-09-21T00:00:00Z",
                            "pVSurplusInactiveAt": "2020-09-21T00:00:00Z",
                            "enabledBatteryFullGridCharge": True,
                            "enabledLessConstrainingSOCLimits": True,
                            "derAPISettings": {
                                "enabledCloudAPI": True,
                                "constraints": {
                                    "syncInterval": 0.1,
                                    "ttl": 0.1,
                                    "disabled": True
                                },
                                "flexibilities": {
                                    "syncInterval": 0.1,
                                    "ttl": 0.1,
                                    "disabled": True
                                }
                            },
                            "enabledTimeOfUseOptimization": True,
                            "disableAveragePmaxCalculation": True,
                            "excludeApplianceTypes": ["HEAT_PUMP"],
                            "evChargingReallocationTolerance": 500000
                        },
                        "smartMeterInstallationTimestamp": "2020-09-21T00:00:00Z"
                    },
                    "energySupplier": {
                        "type": "GRIDX",
                        "unitPrice": 0,
                        "installment": 0,
                        "baseFee": 0,
                        "feedInTariff": 0,
                        "expectedConsumption": 0
                    },
                    "smartMeter": {
                        "installed": True,
                        "hasInstallationDate": True
                    },
                    "electricVehicle": {
                        "manufacturer": "string",
                        "model": "string",
                        "capacity": 0,
                        "averageConsumption": 0,
                        "phasesCount": 1
                    },
                    "electricVehicleProfiles": [
                        {
                            "manufacturer": "string",
                            "model": "string",
                            "capacity": 0,
                            "averageConsumption": 0,
                            "phasesCount": 1,
                            "chargingStationApplianceID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
                        }
                    ],
                    "availableSavings": ["CAPACITY_TARIFF_OPTIMIZATION"]
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/systems")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"gridX
            Headquarter\",\"solution\":\"HOME\",\"labels\":[\"beta\",\"sma\"],\"priorities\":[\"EV\",\"BATTERY\"],\"appliancePriorities\":[\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"],\"tariffID\":\"string\",\"plan\":\"string\",\"operatingSince\":\"2017-12-23T10:15:40Z\",\"curtailmentStrategy\":\"SERIES\",\"location\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"countryCode\":\"DE\",\"postalCode\":\"52062\"},\"metadata\":{\"wizard\":{\"step\":\"string\"},\"energy\":{\"installer\":\"string\",\"norminalPower\":0,\"curtailment\":0,\"heatingSystem\":\"string\",\"agreedEMSTerms\":true,\"ems\":{\"agreedEMSTerms\":true,\"enabledEMS\":true,\"agreedDynamicPVControlTerms\":true,\"enabledDynamicPVControl\":true,\"agreedForecastBasedEMSTerms\":true,\"enabledForecastBasedEMS\":true,\"agreedPriorityConfigurationTerms\":true,\"enabledPriorityConfiguration\":true,\"agreedPowerManagementTerms\":true,\"enabledPowerManagement\":true,\"enabledStaticPowerManagement\":true,\"enabledPowerImportPeakOptimization\":true,\"powerImportPeakPerOptimizationInterval\":0.1,\"enabledPVSurplusChargeMode\":true,\"powerPVSurplusThreshold\":0.1,\"pVSurplusActiveAt\":\"2020-09-21T00:00:00Z\",\"pVSurplusInactiveAt\":\"2020-09-21T00:00:00Z\",\"enabledBatteryFullGridCharge\":true,\"enabledLessConstrainingSOCLimits\":true,\"derAPISettings\":{\"enabledCloudAPI\":true,\"constraints\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true},\"flexibilities\":{\"syncInterval\":0.1,\"ttl\":0.1,\"disabled\":true}},\"enabledTimeOfUseOptimization\":true,\"disableAveragePmaxCalculation\":true,\"excludeApplianceTypes\":[\"HEAT_PUMP\"],\"evChargingReallocationTolerance\":500000},\"smartMeterInstallationTimestamp\":\"2020-09-21T00:00:00Z\"},\"energySupplier\":{\"type\":\"GRIDX\",\"unitPrice\":0,\"installment\":0,\"baseFee\":0,\"feedInTariff\":0,\"expectedConsumption\":0},\"smartMeter\":{\"installed\":true,\"hasInstallationDate\":true},\"electricVehicle\":{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1},\"electricVehicleProfiles\":[{\"manufacturer\":\"string\",\"model\":\"string\",\"capacity\":0,\"averageConsumption\":0,\"phasesCount\":1,\"chargingStationApplianceID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}],\"availableSavings\":[\"CAPACITY_TARIFF_OPTIMIZATION\"]}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"gridX Headquarter","solution":"HOME","labels":["beta","sma"],"priorities":["EV","BATTERY"],"appliancePriorities":["497f6eca-6276-4993-bfeb-53cbbbba6f08"],"tariffID":"string","plan":"string","operatingSince":"2017-12-23T10:15:40Z","curtailmentStrategy":"SERIES","location":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","countryCode":"DE","postalCode":"52062"},"metadata":{"wizard":{"step":"string"},"energy":{"installer":"string","norminalPower":0,"curtailment":0,"heatingSystem":"string","agreedEMSTerms":true,"ems":{"agreedEMSTerms":true,"enabledEMS":true,"agreedDynamicPVControlTerms":true,"enabledDynamicPVControl":true,"agreedForecastBasedEMSTerms":true,"enabledForecastBasedEMS":true,"agreedPriorityConfigurationTerms":true,"enabledPriorityConfiguration":true,"agreedPowerManagementTerms":true,"enabledPowerManagement":true,"enabledStaticPowerManagement":true,"enabledPowerImportPeakOptimization":true,"powerImportPeakPerOptimizationInterval":0.1,"enabledPVSurplusChargeMode":true,"powerPVSurplusThreshold":0.1,"pVSurplusActiveAt":"2020-09-21T00:00:00Z","pVSurplusInactiveAt":"2020-09-21T00:00:00Z","enabledBatteryFullGridCharge":true,"enabledLessConstrainingSOCLimits":true,"derAPISettings":{"enabledCloudAPI":true,"constraints":{"syncInterval":0.1,"ttl":0.1,"disabled":true},"flexibilities":{"syncInterval":0.1,"ttl":0.1,"disabled":true}},"enabledTimeOfUseOptimization":true,"disableAveragePmaxCalculation":true,"excludeApplianceTypes":["HEAT_PUMP"],"evChargingReallocationTolerance":500000},"smartMeterInstallationTimestamp":"2020-09-21T00:00:00Z"},"energySupplier":{"type":"GRIDX","unitPrice":0,"installment":0,"baseFee":0,"feedInTariff":0,"expectedConsumption":0},"smartMeter":{"installed":true,"hasInstallationDate":true},"electricVehicle":{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1},"electricVehicleProfiles":[{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1,"chargingStationApplianceID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}],"availableSavings":["CAPACITY_TARIFF_OPTIMIZATION"]}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"gridX
            Headquarter","solution":"HOME","labels":["beta","sma"],"priorities":["EV","BATTERY"],"appliancePriorities":["497f6eca-6276-4993-bfeb-53cbbbba6f08"],"tariffID":"string","plan":"string","operatingSince":"2017-12-23T10:15:40Z","curtailmentStrategy":"SERIES","location":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","countryCode":"DE","postalCode":"52062"},"metadata":{"wizard":{"step":"string"},"energy":{"installer":"string","norminalPower":0,"curtailment":0,"heatingSystem":"string","agreedEMSTerms":true,"ems":{"agreedEMSTerms":true,"enabledEMS":true,"agreedDynamicPVControlTerms":true,"enabledDynamicPVControl":true,"agreedForecastBasedEMSTerms":true,"enabledForecastBasedEMS":true,"agreedPriorityConfigurationTerms":true,"enabledPriorityConfiguration":true,"agreedPowerManagementTerms":true,"enabledPowerManagement":true,"enabledStaticPowerManagement":true,"enabledPowerImportPeakOptimization":true,"powerImportPeakPerOptimizationInterval":0.1,"enabledPVSurplusChargeMode":true,"powerPVSurplusThreshold":0.1,"pVSurplusActiveAt":"2020-09-21T00:00:00Z","pVSurplusInactiveAt":"2020-09-21T00:00:00Z","enabledBatteryFullGridCharge":true,"enabledLessConstrainingSOCLimits":true,"derAPISettings":{"enabledCloudAPI":true,"constraints":{"syncInterval":0.1,"ttl":0.1,"disabled":true},"flexibilities":{"syncInterval":0.1,"ttl":0.1,"disabled":true}},"enabledTimeOfUseOptimization":true,"disableAveragePmaxCalculation":true,"excludeApplianceTypes":["HEAT_PUMP"],"evChargingReallocationTolerance":500000},"smartMeterInstallationTimestamp":"2020-09-21T00:00:00Z"},"energySupplier":{"type":"GRIDX","unitPrice":0,"installment":0,"baseFee":0,"feedInTariff":0,"expectedConsumption":0},"smartMeter":{"installed":true,"hasInstallationDate":true},"electricVehicle":{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1},"electricVehicleProfiles":[{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1,"chargingStationApplianceID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}],"availableSavings":["CAPACITY_TARIFF_OPTIMIZATION"]}}'
            |  \
              http POST https://api.gridx.de/systems \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"gridX Headquarter","solution":"HOME","labels":["beta","sma"],"priorities":["EV","BATTERY"],"appliancePriorities":["497f6eca-6276-4993-bfeb-53cbbbba6f08"],"tariffID":"string","plan":"string","operatingSince":"2017-12-23T10:15:40Z","curtailmentStrategy":"SERIES","location":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","countryCode":"DE","postalCode":"52062"},"metadata":{"wizard":{"step":"string"},"energy":{"installer":"string","norminalPower":0,"curtailment":0,"heatingSystem":"string","agreedEMSTerms":true,"ems":{"agreedEMSTerms":true,"enabledEMS":true,"agreedDynamicPVControlTerms":true,"enabledDynamicPVControl":true,"agreedForecastBasedEMSTerms":true,"enabledForecastBasedEMS":true,"agreedPriorityConfigurationTerms":true,"enabledPriorityConfiguration":true,"agreedPowerManagementTerms":true,"enabledPowerManagement":true,"enabledStaticPowerManagement":true,"enabledPowerImportPeakOptimization":true,"powerImportPeakPerOptimizationInterval":0.1,"enabledPVSurplusChargeMode":true,"powerPVSurplusThreshold":0.1,"pVSurplusActiveAt":"2020-09-21T00:00:00Z","pVSurplusInactiveAt":"2020-09-21T00:00:00Z","enabledBatteryFullGridCharge":true,"enabledLessConstrainingSOCLimits":true,"derAPISettings":{"enabledCloudAPI":true,"constraints":{"syncInterval":0.1,"ttl":0.1,"disabled":true},"flexibilities":{"syncInterval":0.1,"ttl":0.1,"disabled":true}},"enabledTimeOfUseOptimization":true,"disableAveragePmaxCalculation":true,"excludeApplianceTypes":["HEAT_PUMP"],"evChargingReallocationTolerance":500000},"smartMeterInstallationTimestamp":"2020-09-21T00:00:00Z"},"energySupplier":{"type":"GRIDX","unitPrice":0,"installment":0,"baseFee":0,"feedInTariff":0,"expectedConsumption":0},"smartMeter":{"installed":true,"hasInstallationDate":true},"electricVehicle":{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1},"electricVehicleProfiles":[{"manufacturer":"string","model":"string","capacity":0,"averageConsumption":0,"phasesCount":1,"chargingStationApplianceID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}],"availableSavings":["CAPACITY_TARIFF_OPTIMIZATION"]}}' \
              --output-document \
              - https://api.gridx.de/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "gridX Headquarter",
              "solution": "HOME",
              "labels": ["beta", "sma"],
              "priorities": ["EV", "BATTERY"],
              "appliancePriorities": ["497f6eca-6276-4993-bfeb-53cbbbba6f08"],
              "tariffID": "string",
              "plan": "string",
              "operatingSince": "2017-12-23T10:15:40Z",
              "curtailmentStrategy": "SERIES",
              "location": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "countryCode": "DE",
                "postalCode": "52062"
              ],
              "metadata": [
                "wizard": ["step": "string"],
                "energy": [
                  "installer": "string",
                  "norminalPower": 0,
                  "curtailment": 0,
                  "heatingSystem": "string",
                  "agreedEMSTerms": true,
                  "ems": [
                    "agreedEMSTerms": true,
                    "enabledEMS": true,
                    "agreedDynamicPVControlTerms": true,
                    "enabledDynamicPVControl": true,
                    "agreedForecastBasedEMSTerms": true,
                    "enabledForecastBasedEMS": true,
                    "agreedPriorityConfigurationTerms": true,
                    "enabledPriorityConfiguration": true,
                    "agreedPowerManagementTerms": true,
                    "enabledPowerManagement": true,
                    "enabledStaticPowerManagement": true,
                    "enabledPowerImportPeakOptimization": true,
                    "powerImportPeakPerOptimizationInterval": 0.1,
                    "enabledPVSurplusChargeMode": true,
                    "powerPVSurplusThreshold": 0.1,
                    "pVSurplusActiveAt": "2020-09-21T00:00:00Z",
                    "pVSurplusInactiveAt": "2020-09-21T00:00:00Z",
                    "enabledBatteryFullGridCharge": true,
                    "enabledLessConstrainingSOCLimits": true,
                    "derAPISettings": [
                      "enabledCloudAPI": true,
                      "constraints": [
                        "syncInterval": 0.1,
                        "ttl": 0.1,
                        "disabled": true
                      ],
                      "flexibilities": [
                        "syncInterval": 0.1,
                        "ttl": 0.1,
                        "disabled": true
                      ]
                    ],
                    "enabledTimeOfUseOptimization": true,
                    "disableAveragePmaxCalculation": true,
                    "excludeApplianceTypes": ["HEAT_PUMP"],
                    "evChargingReallocationTolerance": 500000
                  ],
                  "smartMeterInstallationTimestamp": "2020-09-21T00:00:00Z"
                ],
                "energySupplier": [
                  "type": "GRIDX",
                  "unitPrice": 0,
                  "installment": 0,
                  "baseFee": 0,
                  "feedInTariff": 0,
                  "expectedConsumption": 0
                ],
                "smartMeter": [
                  "installed": true,
                  "hasInstallationDate": true
                ],
                "electricVehicle": [
                  "manufacturer": "string",
                  "model": "string",
                  "capacity": 0,
                  "averageConsumption": 0,
                  "phasesCount": 1
                ],
                "electricVehicleProfiles": [
                  [
                    "manufacturer": "string",
                    "model": "string",
                    "capacity": 0,
                    "averageConsumption": 0,
                    "phasesCount": 1,
                    "chargingStationApplianceID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
                  ]
                ],
                "availableSavings": ["CAPACITY_TARIFF_OPTIMIZATION"]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}':
    get:
      summary: Retrieve a System
      description: Retrieves the details of an existing system.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - *ref_74
      responses:
        '200':
          description: Returned system.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_72
        '403': *ref_11
        '404': &ref_83
          description: System not found
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/systems/%7BsystemID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/systems/%7BsystemID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/systems/%7BsystemID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/systems/%7BsystemID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update a System
      description: >
        Updates the specific system by setting the values of the body
        parameters.


        Any parameters not provided will be left unchanged.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsWrite
      parameters:
        - *ref_74
      requestBody: &ref_210
        description: Modified System.
        required: true
        content:
          application/json:
            schema: &ref_374
              allOf:
                - &ref_373
                  allOf:
                    - *ref_82
                    - type: object
                      properties:
                        productOption:
                          type: object
                          required:
                            - id
                          properties:
                            id:
                              type: string
                              format: uuid
                - additionalProperties: false
            examples:
              updateName: &ref_484
                summary: Update system name
                value:
                  name: gridX Headquarter
              enableDerApi: &ref_485
                description: >
                  This example enables cloud DER API.

                  This means that the gridBox will publish both constraints and
                  flexibilities, which makes the objects available through the
                  API.
                summary: Enable DER API
                value:
                  metadata:
                    energy:
                      ems:
                        derAPISettings:
                          enabledCloudAPI: true
              enableDerApiWithoutFlexibilitiesSync: &ref_486
                description: >
                  This example enables cloud DER API without flexibilities being
                  synchronised with gridBox.

                  This means that the gridBox won't publish flexibilities and
                  only considers the constraints published to the cloud.
                summary: 'Enable DER API, do not sync flexibilities'
                value:
                  metadata:
                    energy:
                      ems:
                        derAPISettings:
                          enabledCloudAPI: true
                          flexibilities:
                            disabled: true
              assignProductOption:
                summary: Assign a product option to the system
                value:
                  productOption:
                    id: d085f746-1ae3-4a89-ab3a-a5aa61fd4bf8
      responses:
        '200':
          description: Returned system.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_72
        '403': *ref_11
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"productOption\\\":{\\\"id\\\":\\\"497f6eca-6276-4993-bfeb-53cbbbba6f08\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "productOption": {
                "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/systems/%7BsystemID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({productOption: {id:
            '497f6eca-6276-4993-bfeb-53cbbbba6f08'}}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {productOption: {id: '497f6eca-6276-4993-bfeb-53cbbbba6f08'}},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "productOption": {
                "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08"
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"productOption": @{ @"id":
            @"497f6eca-6276-4993-bfeb-53cbbbba6f08" } };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"productOption":{"id":"497f6eca-6276-4993-bfeb-53cbbbba6f08"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"productOption":{"id":"497f6eca-6276-4993-bfeb-53cbbbba6f08"}}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/systems/%7BsystemID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D"


            payload = {"productOption": {"id":
            "497f6eca-6276-4993-bfeb-53cbbbba6f08"}}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/systems/%7BsystemID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"productOption\":{\"id\":\"497f6eca-6276-4993-bfeb-53cbbbba6f08\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"productOption":{"id":"497f6eca-6276-4993-bfeb-53cbbbba6f08"}}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"productOption":{"id":"497f6eca-6276-4993-bfeb-53cbbbba6f08"}}' | 
            \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"productOption":{"id":"497f6eca-6276-4993-bfeb-53cbbbba6f08"}}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["productOption": ["id":
            "497f6eca-6276-4993-bfeb-53cbbbba6f08"]] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete a System
      description: >
        Deletes a system.


        **Important**: The system must not have any attached Gateway. Reset any
        attached Gateway first by creating a *reset job*.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsWrite
      parameters:
        - *ref_74
      responses:
        '204':
          description: System has been deleted successfully.
        '403': *ref_11
        '404': &ref_85
          description: Gateway Not found
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE", "https://api.gridx.de/systems/%7BsystemID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("DELETE", "/systems/%7BsystemID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/systems/%7BsystemID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/systems/%7BsystemID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /gateways:
    get:
      summary: List all Gateways
      description: List gateways that are accessible to the authenticated user.
      tags:
        - Gateway
      security:
        - BearerAuth:
            - GatewaysRead
      parameters:
        - *ref_18
        - *ref_17
      responses:
        '200':
          description: >
            An array of gateways of up to `per_page` gateways.


            Each entry in the array is a separate gateway. If no gateway is
            available, the resulting array will be empty.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_84
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways',
              qs: {page: 'SOME_INTEGER_VALUE', per_page: 'SOME_INTEGER_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/gateways");

            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE"
            });

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/gateways');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/gateways');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/gateways"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}':
    get:
      summary: Retrieve a Gateway
      description: Retrieves the details of an existing gateway.
      tags:
        - Gateway
      security:
        - BearerAuth:
            - GatewaysRead
      parameters:
        - *ref_75
      responses:
        '200':
          description: Returned gateway.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_375
                allOf:
                  - *ref_84
                  - properties:
                      system: *ref_72
        '400': *ref_15
        '403': *ref_11
        '404': *ref_85
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/gateways/%7BgatewayID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/gateways/%7BgatewayID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/gateways/%7BgatewayID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/gateways/%7BgatewayID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/gateways/%7BgatewayID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update a Gateway
      description: >
        Updates the specific gateway by setting the values of the body
        parameters.


        Any parameters not provided will be left unchanged.
      tags:
        - Gateway
      security:
        - BearerAuth:
            - GatewaysWrite
      parameters:
        - *ref_75
      requestBody:
        required: true
        content:
          application/json:
            schema: &ref_377
              allOf:
                - &ref_376
                  allOf:
                    - *ref_86
                    - properties:
                        name:
                          nullable: true
                - additionalProperties: false
      responses:
        '200':
          description: Returned gateway.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_84
        '400': *ref_15
        '403': *ref_11
        '404': *ref_85
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":null,\\\"debugModeUntil\\\":\\\"2019-08-24T14:15:22Z\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/gateways/%7BgatewayID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": null,
              "debugModeUntil": "2019-08-24T14:15:22Z"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/gateways/%7BgatewayID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({name: null, debugModeUntil:
            '2019-08-24T14:15:22Z'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {name: null, debugModeUntil: '2019-08-24T14:15:22Z'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": null,
              "debugModeUntil": "2019-08-24T14:15:22Z"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": ,
                                          @"debugModeUntil": @"2019-08-24T14:15:22Z" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":null,"debugModeUntil":"2019-08-24T14:15:22Z"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":null,"debugModeUntil":"2019-08-24T14:15:22Z"}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/gateways/%7BgatewayID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/gateways/%7BgatewayID%7D"


            payload = {
                "name": None,
                "debugModeUntil": "2019-08-24T14:15:22Z"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/gateways/%7BgatewayID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"name\":null,\"debugModeUntil\":\"2019-08-24T14:15:22Z\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":null,"debugModeUntil":"2019-08-24T14:15:22Z"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"name":null,"debugModeUntil":"2019-08-24T14:15:22Z"}' |  \
              http PATCH https://api.gridx.de/gateways/%7BgatewayID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":null,"debugModeUntil":"2019-08-24T14:15:22Z"}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": ,
              "debugModeUntil": "2019-08-24T14:15:22Z"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete a Gateway
      description: Deletes a Gateway.
      tags:
        - Gateway
      security:
        - BearerAuth:
            - GatewaysWrite
      parameters:
        - *ref_75
      responses:
        '204':
          description: Gateway has been deleted successfully.
        '400': *ref_15
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/gateways/%7BgatewayID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE", "https://api.gridx.de/gateways/%7BgatewayID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("DELETE", "/gateways/%7BgatewayID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/gateways/%7BgatewayID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/gateways/%7BgatewayID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/gateways/%7BgatewayID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/gateways':
    post:
      summary: Create a System's Gateway
      description: Creates a gateway.
      tags:
        - Gateway
      security:
        - BearerAuth:
            - GatewayWrite
      parameters:
        - *ref_74
      requestBody: &ref_211
        description: Gateway to be created.
        required: true
        content:
          application/json:
            schema: &ref_379
              allOf:
                - &ref_378
                  allOf:
                    - *ref_86
                    - properties:
                        startcode:
                          description: Code used to register a new gateway.
                          type: string
                          example: 39FDDF7D85BAAD2D
                          pattern: '^[A-F0-9]{16}$'
                        vendorID:
                          description: >-
                            ID of the vendor account to which the corresponding
                            system is assigned.
                          type: string
                          format: uuid
                          example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                        type: *ref_87
                      required:
                        - startcode
                - additionalProperties: false
      responses:
        '201':
          description: Created gateway.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_84
        '403': *ref_11
        '404': *ref_83
        '422':
          description: The payload for creating the gateway contains invalid data.
          content:
            application/vnd.gridx.v2+json:
              schema:
                allOf:
                  - *ref_0
                  - properties:
                      type:
                        type: string
                        enum:
                          - GENERAL
                          - STARTCODE_NOT_FOUND
                          - STARTCODE_ALREADY_REGISTERED
                    required:
                      - type
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/gateways");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/gateways\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"string\\\",\\\"debugModeUntil\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"startcode\\\":\\\"39FDDF7D85BAAD2D\\\",\\\"vendorID\\\":\\\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\\\",\\\"type\\\":\\\"VIRTUAL\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/gateways")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/gateways")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "string",
              "debugModeUntil": "2019-08-24T14:15:22Z",
              "startcode": "39FDDF7D85BAAD2D",
              "vendorID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f",
              "type": "VIRTUAL"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/gateways",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/gateways",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'string',
              debugModeUntil: '2019-08-24T14:15:22Z',
              startcode: '39FDDF7D85BAAD2D',
              vendorID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f',
              type: 'VIRTUAL'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/gateways',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'string',
                debugModeUntil: '2019-08-24T14:15:22Z',
                startcode: '39FDDF7D85BAAD2D',
                vendorID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f',
                type: 'VIRTUAL'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "string",
              "debugModeUntil": "2019-08-24T14:15:22Z",
              "startcode": "39FDDF7D85BAAD2D",
              "vendorID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f",
              "type": "VIRTUAL"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"string",
                                          @"debugModeUntil": @"2019-08-24T14:15:22Z",
                                          @"startcode": @"39FDDF7D85BAAD2D",
                                          @"vendorID": @"6dd0a658-5828-4d30-bc65-a03c6d6e425f",
                                          @"type": @"VIRTUAL" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/gateways"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/gateways",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"string","debugModeUntil":"2019-08-24T14:15:22Z","startcode":"39FDDF7D85BAAD2D","vendorID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f","type":"VIRTUAL"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"string","debugModeUntil":"2019-08-24T14:15:22Z","startcode":"39FDDF7D85BAAD2D","vendorID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f","type":"VIRTUAL"}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/gateways');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems/%7BsystemID%7D/gateways", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/gateways"


            payload = {
                "name": "string",
                "debugModeUntil": "2019-08-24T14:15:22Z",
                "startcode": "39FDDF7D85BAAD2D",
                "vendorID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f",
                "type": "VIRTUAL"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/gateways")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"name\":\"string\",\"debugModeUntil\":\"2019-08-24T14:15:22Z\",\"startcode\":\"39FDDF7D85BAAD2D\",\"vendorID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\",\"type\":\"VIRTUAL\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/gateways \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"string","debugModeUntil":"2019-08-24T14:15:22Z","startcode":"39FDDF7D85BAAD2D","vendorID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f","type":"VIRTUAL"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"name":"string","debugModeUntil":"2019-08-24T14:15:22Z","startcode":"39FDDF7D85BAAD2D","vendorID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f","type":"VIRTUAL"}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/gateways \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"string","debugModeUntil":"2019-08-24T14:15:22Z","startcode":"39FDDF7D85BAAD2D","vendorID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f","type":"VIRTUAL"}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/gateways
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "string",
              "debugModeUntil": "2019-08-24T14:15:22Z",
              "startcode": "39FDDF7D85BAAD2D",
              "vendorID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f",
              "type": "VIRTUAL"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/gateways")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/scans':
    get:
      summary: List Gateway's Scans
      description: >
        List of scans for the given gateway and the given interval.


        If no interval is specified, the entire period is considered and all
        scans are listed.
      tags:
        - Scan
      security:
        - BearerAuth:
            - ScansRead
      parameters:
        - *ref_75
        - &ref_119
          name: interval
          description: >
            Requested time interval, formatted in ISO8601.


            In this format the start and end point of the interval are formatted
            according

            to RFC3339 and separated by a slash "/".
          in: query
          required: true
          allowReserved: true
          example: '2021-12-24T18:21:00Z/2021-12-25T18:21:00Z'
          schema:
            type: string
            format: datetime
      responses:
        '200':
          description: |
            An array of scans.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_381
                  title: Scan
                  description: >-
                    Represents a group of scanners than have to run on a
                    specific gridbox.
                  type: object
                  properties:
                    id:
                      description: Unique identifier of a scan.
                      type: string
                      format: uuid
                      example: 9ee88ee2-49f4-434d-a96f-67aca96aaa0a
                    startedAt:
                      description: The time at which the scan has started.
                      type: string
                      format: date-time
                      readOnly: true
                      example: '2018-04-15T00:00:00Z'
                    finishedAt:
                      description: The time at which the scan has finished.
                      type: string
                      format: date-time
                      readOnly: true
                      example: '2018-04-15T00:00:00Z'
                    scanners:
                      description: Represents a list of scanners that have to run.
                      type: array
                      items: &ref_380
                        title: Scanner
                        description: Represents a scanner within a scan.
                        type: object
                        properties:
                          id:
                            description: Unique identifier of a scanner.
                            type: string
                            format: uuid
                            example: 7992f38a-df67-49d9-9f2f-98c63015a20c
                          name: *ref_88
                          startedAt:
                            description: The time at which the scan has started.
                            type: string
                            format: date-time
                            readOnly: true
                            example: '2018-04-15T00:00:00Z'
                          finishedAt:
                            description: The time at which the scan has finished.
                            type: string
                            format: date-time
                            readOnly: true
                            nullable: true
                            example: '2018-04-15T00:00:00Z'
                        required:
                          - id
                          - name
                          - startedAt
                          - finishedAt
                    appliances:
                      description: >-
                        Represents a list of appliances that have been detected
                        during a scan.
                      type: array
                      items: *ref_62
                  required:
                    - id
        '400': *ref_15
        '403': *ref_11
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/scans',
              qs: {interval: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/scans");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/scans');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/scans');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/gateways/%7BgatewayID%7D/scans"


            querystring = {"interval":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/scans?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/jobs':
    get:
      summary: List Gateway's Jobs
      description: |
        List jobs that belong to the given gateway.
      tags:
        - Job
      security:
        - BearerAuth:
            - JobsRead
      parameters:
        - *ref_75
      responses:
        '200':
          description: |
            An array of jobs.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_89
                  type: object
                  allOf:
                    - &ref_91
                      description: Represents an application-based job on the gridBox.
                      type: object
                      properties:
                        type: &ref_382
                          description: >
                            Represents the kind of the job. A job can be of
                            type:

                            - `UNKNOWN_TYPE`

                            - `RESET`: Indicates that the application has to be
                            reset.

                            - `SCAN`: Indicates that the application should
                            start a scan.

                            - `RESTART`: Indicates that the application should
                            restart.
                          type: string
                          enum:
                            - UNKNOWN_TYPE
                            - SCAN
                            - RESET
                            - RESTART
                          example: RESET
                        requestedAt:
                          description: Represents the time at which the job was requested.
                          type: string
                          format: date-time
                          readOnly: true
                          example: '2018-04-15T00:00:00Z'
                        state: &ref_383
                          type: string
                          description: >
                            Represents the current state of the job. It can be
                            one of:

                            * `UNKNOWN_STATE`

                            * `PENDING`: Indicates that the job waits to be
                            fetched.

                            * `RECEIVED`: Indicates that the job has reached the
                            gridbox.

                            * `STARTED`: Indicates that the job has been
                            started.

                            * `DONE`: Indicates that the job is done.

                            * `ERROR`: Indicates that the job has failed.

                            * `CANCELED`: Indicates that the job was remotely
                            cancelled.It might only have an impact if the state
                            is still pending.
                          enum:
                            - UNKNOWN_STATE
                            - PENDING
                            - RECEIVED
                            - STARTED
                            - DONE
                            - ERROR
                            - CANCELED
                          example: PENDING
                    - properties:
                        id:
                          type: string
                          format: uuid
                          readOnly: true
                          description: Unique identifier of a job.
                          example: d90fc059-b1d0-4277-a347-43609e232f4f
                        receivedAt:
                          description: >-
                            Represents the time at which the job was received by
                            the gateway.
                          type: string
                          format: date-time
                          readOnly: true
                          example: '2018-04-15T00:00:00Z'
                        startedAt:
                          description: Represents the time at which the job was started.
                          type: string
                          format: date-time
                          readOnly: true
                          example: '2018-04-15T00:00:00Z'
                        finishedAt:
                          description: Represents the time at which the job was finished.
                          type: string
                          format: date-time
                          readOnly: true
                          example: '2018-04-15T00:00:00Z'
                        executions:
                          description: Represents a set of job executions.
                          type: array
                          items: &ref_384
                            title: Job Execution
                            description: Represents an execution of a job.
                            type: object
                            properties:
                              id:
                                description: Unique identifier of a job execution.
                                type: string
                                format: uuid
                                example: 5830cd32-a194-4b9d-bea3-c2332f27167f
                              jobID:
                                description: Unique identifier of a job.
                                type: string
                                format: uuid
                              succeeded:
                                description: Indicates that the execution was successful.
                                type: boolean
                              error:
                                description: A possible error message.
                                type: string
                              startedAt:
                                description: >-
                                  Represents the time at which the execution was
                                  started at the gridbox.
                                type: string
                                format: date-time
                                readOnly: true
                                example: '2018-04-15T00:00:00Z'
                              finishedAt:
                                description: >-
                                  Represents the time at which the execution was
                                  finished.
                                type: string
                                format: date-time
                                readOnly: true
                                example: '2018-04-15T00:00:00Z'
                            required:
                              - id
                      required:
                        - id
                        - state
                        - type
                        - executions
        '400': *ref_15
        '403': *ref_11
        '404': *ref_85
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/jobs",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/jobs',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/gateways/%7BgatewayID%7D/jobs",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/jobs \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/gateways/%7BgatewayID%7D/jobs \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/jobs
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/jobs/{jobIDOrType}':
    get:
      summary: Get a Job
      description: >
        Gets a particular job that belongs to the given gateway. In this case,
        the path parameter should be a job ID.
      tags:
        - Job
      security:
        - BearerAuth:
            - JobsRead
      parameters:
        - *ref_75
        - &ref_90
          name: jobIDOrType
          description: >
            Unique identifier for a job or the type of the job. 

            In `POST` request the job **type** is used, in `GET` and `DELETE`
            requests job **ID**.
          in: path
          required: true
          schema:
            type: string
          examples:
            jobType:
              summary: Type of the job.
              value: reset
            jobID:
              summary: Unique identifier for a job.
              value: 0dce59b6-edd5-4366-a6fb-27c0ab3e8f90
      responses:
        '200':
          description: |
            A job.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_89
        '400': *ref_15
        '404': &ref_92
          description: Job or Gateway not found
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a job with a given type
      description: >
        Creates a job with the given type for the given gateway, only if a job
        with that type doesn't already exist.

        In this case, the path parameter should be a job type. Please note that
        the job type is case-sensitive.

          * `SCAN`: Once this job is triggered, the gridBox will look for connected appliances and update the list accordingly.

          * `RESET`: This type of job resets gridBox to default and removes it from previously configured system.

          * `RESTART`: Once this job is triggered, the gridBox will restart.

        *Job execution is asynchronous and does not guarantee immediate
        execution.*
      tags:
        - Job
      security:
        - BearerAuth:
            - JobsWrite
      parameters:
        - *ref_75
        - *ref_90
      responses:
        '201':
          description: |
            A job.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_385
                type: object
                allOf:
                  - *ref_91
                  - properties:
                      id:
                        type: string
                        format: uuid
                        readOnly: true
                        description: Unique identifier of a job.
                        example: d90fc059-b1d0-4277-a347-43609e232f4f
                    required:
                      - state
                      - type
        '400': *ref_15
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");

            var request = new RestRequest(Method.POST);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")
              .post(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "method": "POST",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D');

            $request->setRequestMethod('POST');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("POST",
            "/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("POST", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http POST
            https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Cancel a particular job
      description: >
        Cancels a particular job from the given gateway. In this case, the path
        parameter should be a job ID.
      tags:
        - Job
      security:
        - BearerAuth:
            - JobsWrite
      parameters:
        - *ref_75
        - *ref_90
      responses:
        '200':
          description: |
            A job.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_89
        '400': *ref_15
        '404': *ref_92
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/jobs/%7BjobIDOrType%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances':
    get:
      summary: List Gateway's Appliances
      description: >
        Lists appliances that belong to the given gateway.


        Children appliances, e.g. those of hybrid inverters, are not included by
        default.

        To include them, `listAll` parameter must be set to `true`.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - AppliancesRead
      parameters:
        - *ref_75
        - *ref_18
        - *ref_17
        - &ref_184
          name: listAll
          description: >
            Boolean value to define if all the appliances must be listed.

            If absent or set to `false` child appliances of Hybrid Inverter
            would be skipped.
          in: query
          example: true
          schema:
            type: boolean
            default: false
      responses:
        '200':
          description: >
            An array of appliances of up to `per_page` appliances.


            Each entry in the array is a separate appliance. If no appliance is
            available, the resulting array will be empty.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_62
        '403': *ref_11
        '404': *ref_85
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                listAll: 'SOME_BOOLEAN_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances");


            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "listAll": "SOME_BOOLEAN_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'listAll' => 'SOME_BOOLEAN_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'listAll' => 'SOME_BOOLEAN_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","listAll":"SOME_BOOLEAN_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&listAll=SOME_BOOLEAN_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create an Appliance
      description: >
        This endpoint can be used by third parties to create external appliances
        that are not managed by the gridBox itself.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - AppliancesWrite
      parameters:
        - *ref_75
      requestBody: &ref_212
        description: Creates an appliance.
        required: true
        content:
          application/json:
            schema: &ref_396
              allOf:
                - &ref_395
                  title: Appliance Create
                  description: >
                    Appliance represents a monitor-/controllable device such as
                    Inverters,

                    Meters and Heat Pumps.
                  readOnly: true
                  oneOf:
                    - &ref_386
                      title: Inverter Create
                      description: >
                        Inverter represents a monitor-/controllable inverter. It
                        can be of kind:

                        - `PV`/`PV_EXTERNAL`: used as photovoltaic only.

                        - `BATTERY`: used as battery only.

                        - `HYBRID`: used as both photovoltaic and battery.

                        - `UNKNOWN`: default, when the inverter kind is not
                        determined.
                      allOf:
                        - &ref_105
                          title: Base Appliance Create
                          description: >
                            BaseApplianceCreate contains fields of an appliance
                            that can be set upon creation, regardless of
                            appliance type.


                            Specific appliance types extend this schema and add
                            new fields.
                          type: object
                          required:
                            - type
                          properties:
                            inactive: *ref_93
                            name: *ref_94
                            type: *ref_95
                            network: *ref_96
                            loadSettings: *ref_97
                            sensorSettings: *ref_98
                            state: *ref_99
                            parent: *ref_100
                            serialnumber: *ref_101
                            cryptoSettings:
                              title: Crypto Settings
                              description: >-
                                Contains a list of crypto setting keys that are
                                associated with the appliance.
                              type: array
                              items: *ref_102
                            energySettings: *ref_103
                        - *ref_104
                    - &ref_387
                      title: Meter Create
                      description: |
                        Meter represents a monitor-/controllable meter.
                      allOf:
                        - *ref_105
                        - *ref_106
                        - required:
                            - auxMeter
                    - &ref_388
                      title: EV Charging Station Create
                      description: >
                        EV Charging Station represents a monitor-/controllable
                        electric vehicle charging station.
                      allOf:
                        - *ref_105
                        - *ref_107
                        - required:
                            - evChargingStation
                          properties:
                            evChargingStation:
                              type: object
                              properties:
                                type:
                                  type: string
                    - &ref_389
                      title: Heat Pump Create
                      description: |
                        Heat Pump represents a monitor-/controllable heat pump.
                      allOf:
                        - *ref_105
                        - *ref_108
                        - required:
                            - heatPump
                    - &ref_390
                      title: Heat Meter Create
                      description: >
                        Heat Meter represents a monitor-/controllable heat
                        meter.
                      allOf:
                        - *ref_105
                        - *ref_109
                    - &ref_391
                      title: Electrolyzer Create
                      description: >
                        Electrolyzer represents a monitor-/controllable
                        electrolyzer.
                      allOf:
                        - *ref_105
                        - *ref_110
                    - &ref_392
                      title: IO Device Create
                      description: >
                        IO devices represent configuration options that can be
                        applied for appliances of the fieldbus coupler type.
                      allOf:
                        - *ref_105
                        - *ref_111
                        - required:
                            - ioDevice
                    - &ref_393
                      title: Heater Create
                      description: |
                        Heater represents a monitor-/controllable heater.
                      allOf:
                        - *ref_105
                        - *ref_112
                        - required:
                            - heater
                    - &ref_394
                      title: Container Create
                      description: >
                        Container represents a container appliance, used to
                        group multiple child appliances.
                      allOf:
                        - *ref_105
                        - *ref_113
                        - required:
                            - container
                  discriminator:
                    propertyName: type
                    mapping:
                      INVERTER: '#/components/schemas/InverterCreate'
                      METER: '#/components/schemas/MeterCreate'
                      EVSTATION: '#/components/schemas/EVStationCreate'
                      HEAT_PUMP: '#/components/schemas/HeatPumpCreate'
                      HEAT_METER: '#/components/schemas/HeatMeterCreate'
                      ELECTROLYZER: '#/components/schemas/ElectrolyzerCreate'
                      IO_DEVICE: '#/components/schemas/IODeviceCreate'
                      HEATER: '#/components/schemas/HeaterCreate'
                      CONTAINER: '#/components/schemas/ContainerCreate'
                - additionalProperties: false
      responses:
        '201':
          description: The appliance has been created successfully.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_62
        '400': *ref_15
        '403': *ref_11
        '404': *ref_85
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny
            Boy Storage
            2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny
            Boy Storage
            2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances\"\n\n\tpayload := strings.NewReader(\"{\\\"inactive\\\":true,\\\"name\\\":\\\"string\\\",\\\"type\\\":\\\"INVERTER\\\",\\\"network\\\":{\\\"interface\\\":\\\"eth0\\\",\\\"address\\\":\\\"192.168.178.153\\\",\\\"port\\\":0,\\\"protocol\\\":\\\"tcp/modbus\\\"},\\\"loadSettings\\\":{\\\"disabled\\\":true},\\\"sensorSettings\\\":{\\\"sensorL1\\\":0,\\\"sensorL2\\\":0,\\\"sensorL3\\\":0},\\\"state\\\":{\\\"current\\\":\\\"SCANNED\\\",\\\"transitions\\\":[{\\\"start\\\":\\\"CONNECTING\\\",\\\"target\\\":\\\"DISCONNECTED\\\"}]},\\\"parent\\\":\\\"42e2bc1b-6741-4e2e-b138-97b4a342c999\\\",\\\"serialnumber\\\":\\\"1901000652\\\",\\\"cryptoSettings\\\":[{\\\"key\\\":\\\"string\\\"}],\\\"energySettings\\\":{\\\"minControlInterval\\\":0,\\\"socMax\\\":100,\\\"socLockMax\\\":100,\\\"socMin\\\":100,\\\"socLockMin\\\":100,\\\"socDeepDischarge\\\":100,\\\"phaseMapping\\\":[0,0,0],\\\"temperatureExtremeMax\\\":0.1,\\\"temperatureExtremeMin\\\":0.1,\\\"temperatureComfortMax\\\":0.1,\\\"temperatureComfortMin\\\":0.1,\\\"surplusThreshold\\\":0},\\\"kind\\\":\\\"UNKNOWN\\\",\\\"manufacturer\\\":\\\"SMA\\\",\\\"model\\\":\\\"Sunny Boy Storage 2.5\\\",\\\"firmware\\\":\\\"2.4.23.R\\\",\\\"inverter\\\":{\\\"maxActivePowerOutput\\\":0,\\\"type\\\":\\\"SUNGROW_SG_20_RT\\\"},\\\"nominalPowerLimit\\\":0,\\\"hybridCalcMode\\\":0,\\\"battery\\\":{\\\"maxCharge\\\":501,\\\"maxDischarge\\\":501,\\\"controllable\\\":true,\\\"dischargeLimit\\\":0,\\\"rechargeLimit\\\":0,\\\"controlSettings\\\":{\\\"value\\\":0,\\\"command\\\":\\\"none\\\"}}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny
            Boy Storage
            2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny Boy Storage 2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny Boy Storage 2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "inactive": true,
              "name": "string",
              "type": "INVERTER",
              "network": {
                "interface": "eth0",
                "address": "192.168.178.153",
                "port": 0,
                "protocol": "tcp/modbus"
              },
              "loadSettings": {
                "disabled": true
              },
              "sensorSettings": {
                "sensorL1": 0,
                "sensorL2": 0,
                "sensorL3": 0
              },
              "state": {
                "current": "SCANNED",
                "transitions": [
                  {
                    "start": "CONNECTING",
                    "target": "DISCONNECTED"
                  }
                ]
              },
              "parent": "42e2bc1b-6741-4e2e-b138-97b4a342c999",
              "serialnumber": "1901000652",
              "cryptoSettings": [
                {
                  "key": "string"
                }
              ],
              "energySettings": {
                "minControlInterval": 0,
                "socMax": 100,
                "socLockMax": 100,
                "socMin": 100,
                "socLockMin": 100,
                "socDeepDischarge": 100,
                "phaseMapping": [
                  0,
                  0,
                  0
                ],
                "temperatureExtremeMax": 0.1,
                "temperatureExtremeMin": 0.1,
                "temperatureComfortMax": 0.1,
                "temperatureComfortMin": 0.1,
                "surplusThreshold": 0
              },
              "kind": "UNKNOWN",
              "manufacturer": "SMA",
              "model": "Sunny Boy Storage 2.5",
              "firmware": "2.4.23.R",
              "inverter": {
                "maxActivePowerOutput": 0,
                "type": "SUNGROW_SG_20_RT"
              },
              "nominalPowerLimit": 0,
              "hybridCalcMode": 0,
              "battery": {
                "maxCharge": 501,
                "maxDischarge": 501,
                "controllable": true,
                "dischargeLimit": 0,
                "rechargeLimit": 0,
                "controlSettings": {
                  "value": 0,
                  "command": "none"
                }
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny Boy Storage 2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              inactive: true,
              name: 'string',
              type: 'INVERTER',
              network: {interface: 'eth0', address: '192.168.178.153', port: 0, protocol: 'tcp/modbus'},
              loadSettings: {disabled: true},
              sensorSettings: {sensorL1: 0, sensorL2: 0, sensorL3: 0},
              state: {
                current: 'SCANNED',
                transitions: [{start: 'CONNECTING', target: 'DISCONNECTED'}]
              },
              parent: '42e2bc1b-6741-4e2e-b138-97b4a342c999',
              serialnumber: '1901000652',
              cryptoSettings: [{key: 'string'}],
              energySettings: {
                minControlInterval: 0,
                socMax: 100,
                socLockMax: 100,
                socMin: 100,
                socLockMin: 100,
                socDeepDischarge: 100,
                phaseMapping: [0, 0, 0],
                temperatureExtremeMax: 0.1,
                temperatureExtremeMin: 0.1,
                temperatureComfortMax: 0.1,
                temperatureComfortMin: 0.1,
                surplusThreshold: 0
              },
              kind: 'UNKNOWN',
              manufacturer: 'SMA',
              model: 'Sunny Boy Storage 2.5',
              firmware: '2.4.23.R',
              inverter: {maxActivePowerOutput: 0, type: 'SUNGROW_SG_20_RT'},
              nominalPowerLimit: 0,
              hybridCalcMode: 0,
              battery: {
                maxCharge: 501,
                maxDischarge: 501,
                controllable: true,
                dischargeLimit: 0,
                rechargeLimit: 0,
                controlSettings: {value: 0, command: 'none'}
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                inactive: true,
                name: 'string',
                type: 'INVERTER',
                network: {interface: 'eth0', address: '192.168.178.153', port: 0, protocol: 'tcp/modbus'},
                loadSettings: {disabled: true},
                sensorSettings: {sensorL1: 0, sensorL2: 0, sensorL3: 0},
                state: {
                  current: 'SCANNED',
                  transitions: [{start: 'CONNECTING', target: 'DISCONNECTED'}]
                },
                parent: '42e2bc1b-6741-4e2e-b138-97b4a342c999',
                serialnumber: '1901000652',
                cryptoSettings: [{key: 'string'}],
                energySettings: {
                  minControlInterval: 0,
                  socMax: 100,
                  socLockMax: 100,
                  socMin: 100,
                  socLockMin: 100,
                  socDeepDischarge: 100,
                  phaseMapping: [0, 0, 0],
                  temperatureExtremeMax: 0.1,
                  temperatureExtremeMin: 0.1,
                  temperatureComfortMax: 0.1,
                  temperatureComfortMin: 0.1,
                  surplusThreshold: 0
                },
                kind: 'UNKNOWN',
                manufacturer: 'SMA',
                model: 'Sunny Boy Storage 2.5',
                firmware: '2.4.23.R',
                inverter: {maxActivePowerOutput: 0, type: 'SUNGROW_SG_20_RT'},
                nominalPowerLimit: 0,
                hybridCalcMode: 0,
                battery: {
                  maxCharge: 501,
                  maxDischarge: 501,
                  controllable: true,
                  dischargeLimit: 0,
                  rechargeLimit: 0,
                  controlSettings: {value: 0, command: 'none'}
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "inactive": true,
              "name": "string",
              "type": "INVERTER",
              "network": {
                "interface": "eth0",
                "address": "192.168.178.153",
                "port": 0,
                "protocol": "tcp/modbus"
              },
              "loadSettings": {
                "disabled": true
              },
              "sensorSettings": {
                "sensorL1": 0,
                "sensorL2": 0,
                "sensorL3": 0
              },
              "state": {
                "current": "SCANNED",
                "transitions": [
                  {
                    "start": "CONNECTING",
                    "target": "DISCONNECTED"
                  }
                ]
              },
              "parent": "42e2bc1b-6741-4e2e-b138-97b4a342c999",
              "serialnumber": "1901000652",
              "cryptoSettings": [
                {
                  "key": "string"
                }
              ],
              "energySettings": {
                "minControlInterval": 0,
                "socMax": 100,
                "socLockMax": 100,
                "socMin": 100,
                "socLockMin": 100,
                "socDeepDischarge": 100,
                "phaseMapping": [
                  0,
                  0,
                  0
                ],
                "temperatureExtremeMax": 0.1,
                "temperatureExtremeMin": 0.1,
                "temperatureComfortMax": 0.1,
                "temperatureComfortMin": 0.1,
                "surplusThreshold": 0
              },
              "kind": "UNKNOWN",
              "manufacturer": "SMA",
              "model": "Sunny Boy Storage 2.5",
              "firmware": "2.4.23.R",
              "inverter": {
                "maxActivePowerOutput": 0,
                "type": "SUNGROW_SG_20_RT"
              },
              "nominalPowerLimit": 0,
              "hybridCalcMode": 0,
              "battery": {
                "maxCharge": 501,
                "maxDischarge": 501,
                "controllable": true,
                "dischargeLimit": 0,
                "rechargeLimit": 0,
                "controlSettings": {
                  "value": 0,
                  "command": "none"
                }
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"inactive": @YES,
                                          @"name": @"string",
                                          @"type": @"INVERTER",
                                          @"network": @{ @"interface": @"eth0", @"address": @"192.168.178.153", @"port": @0, @"protocol": @"tcp/modbus" },
                                          @"loadSettings": @{ @"disabled": @YES },
                                          @"sensorSettings": @{ @"sensorL1": @0, @"sensorL2": @0, @"sensorL3": @0 },
                                          @"state": @{ @"current": @"SCANNED", @"transitions": @[ @{ @"start": @"CONNECTING", @"target": @"DISCONNECTED" } ] },
                                          @"parent": @"42e2bc1b-6741-4e2e-b138-97b4a342c999",
                                          @"serialnumber": @"1901000652",
                                          @"cryptoSettings": @[ @{ @"key": @"string" } ],
                                          @"energySettings": @{ @"minControlInterval": @0, @"socMax": @100, @"socLockMax": @100, @"socMin": @100, @"socLockMin": @100, @"socDeepDischarge": @100, @"phaseMapping": @[ @0, @0, @0 ], @"temperatureExtremeMax": @0.1, @"temperatureExtremeMin": @0.1, @"temperatureComfortMax": @0.1, @"temperatureComfortMin": @0.1, @"surplusThreshold": @0 },
                                          @"kind": @"UNKNOWN",
                                          @"manufacturer": @"SMA",
                                          @"model": @"Sunny Boy Storage 2.5",
                                          @"firmware": @"2.4.23.R",
                                          @"inverter": @{ @"maxActivePowerOutput": @0, @"type": @"SUNGROW_SG_20_RT" },
                                          @"nominalPowerLimit": @0,
                                          @"hybridCalcMode": @0,
                                          @"battery": @{ @"maxCharge": @501, @"maxDischarge": @501, @"controllable": @YES, @"dischargeLimit": @0, @"rechargeLimit": @0, @"controlSettings": @{ @"value": @0, @"command": @"none" } } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny
            Boy Storage
            2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny Boy Storage 2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"inactive":true,"name":"string","type":"INVERTER","network":{"interface":"eth0","address":"192.168.178.153","port":0,"protocol":"tcp/modbus"},"loadSettings":{"disabled":true},"sensorSettings":{"sensorL1":0,"sensorL2":0,"sensorL3":0},"state":{"current":"SCANNED","transitions":[{"start":"CONNECTING","target":"DISCONNECTED"}]},"parent":"42e2bc1b-6741-4e2e-b138-97b4a342c999","serialnumber":"1901000652","cryptoSettings":[{"key":"string"}],"energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"kind":"UNKNOWN","manufacturer":"SMA","model":"Sunny
            Boy Storage
            2.5","firmware":"2.4.23.R","inverter":{"maxActivePowerOutput":0,"type":"SUNGROW_SG_20_RT"},"nominalPowerLimit":0,"hybridCalcMode":0,"battery":{"maxCharge":501,"maxDischarge":501,"controllable":true,"dischargeLimit":0,"rechargeLimit":0,"controlSettings":{"value":0,"command":"none"}}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"inactive":true,"name":"string","type":"INVERTER","network":{"interface":"eth0","address":"192.168.178.153","port":0,"protocol":"tcp/modbus"},"loadSettings":{"disabled":true},"sensorSettings":{"sensorL1":0,"sensorL2":0,"sensorL3":0},"state":{"current":"SCANNED","transitions":[{"start":"CONNECTING","target":"DISCONNECTED"}]},"parent":"42e2bc1b-6741-4e2e-b138-97b4a342c999","serialnumber":"1901000652","cryptoSettings":[{"key":"string"}],"energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"kind":"UNKNOWN","manufacturer":"SMA","model":"Sunny
            Boy Storage
            2.5","firmware":"2.4.23.R","inverter":{"maxActivePowerOutput":0,"type":"SUNGROW_SG_20_RT"},"nominalPowerLimit":0,"hybridCalcMode":0,"battery":{"maxCharge":501,"maxDischarge":501,"controllable":true,"dischargeLimit":0,"rechargeLimit":0,"controlSettings":{"value":0,"command":"none"}}}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny
            Boy Storage
            2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/gateways/%7BgatewayID%7D/appliances",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances"


            payload = {
                "inactive": True,
                "name": "string",
                "type": "INVERTER",
                "network": {
                    "interface": "eth0",
                    "address": "192.168.178.153",
                    "port": 0,
                    "protocol": "tcp/modbus"
                },
                "loadSettings": {"disabled": True},
                "sensorSettings": {
                    "sensorL1": 0,
                    "sensorL2": 0,
                    "sensorL3": 0
                },
                "state": {
                    "current": "SCANNED",
                    "transitions": [
                        {
                            "start": "CONNECTING",
                            "target": "DISCONNECTED"
                        }
                    ]
                },
                "parent": "42e2bc1b-6741-4e2e-b138-97b4a342c999",
                "serialnumber": "1901000652",
                "cryptoSettings": [{"key": "string"}],
                "energySettings": {
                    "minControlInterval": 0,
                    "socMax": 100,
                    "socLockMax": 100,
                    "socMin": 100,
                    "socLockMin": 100,
                    "socDeepDischarge": 100,
                    "phaseMapping": [0, 0, 0],
                    "temperatureExtremeMax": 0.1,
                    "temperatureExtremeMin": 0.1,
                    "temperatureComfortMax": 0.1,
                    "temperatureComfortMin": 0.1,
                    "surplusThreshold": 0
                },
                "kind": "UNKNOWN",
                "manufacturer": "SMA",
                "model": "Sunny Boy Storage 2.5",
                "firmware": "2.4.23.R",
                "inverter": {
                    "maxActivePowerOutput": 0,
                    "type": "SUNGROW_SG_20_RT"
                },
                "nominalPowerLimit": 0,
                "hybridCalcMode": 0,
                "battery": {
                    "maxCharge": 501,
                    "maxDischarge": 501,
                    "controllable": True,
                    "dischargeLimit": 0,
                    "rechargeLimit": 0,
                    "controlSettings": {
                        "value": 0,
                        "command": "none"
                    }
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"inactive\":true,\"name\":\"string\",\"type\":\"INVERTER\",\"network\":{\"interface\":\"eth0\",\"address\":\"192.168.178.153\",\"port\":0,\"protocol\":\"tcp/modbus\"},\"loadSettings\":{\"disabled\":true},\"sensorSettings\":{\"sensorL1\":0,\"sensorL2\":0,\"sensorL3\":0},\"state\":{\"current\":\"SCANNED\",\"transitions\":[{\"start\":\"CONNECTING\",\"target\":\"DISCONNECTED\"}]},\"parent\":\"42e2bc1b-6741-4e2e-b138-97b4a342c999\",\"serialnumber\":\"1901000652\",\"cryptoSettings\":[{\"key\":\"string\"}],\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"kind\":\"UNKNOWN\",\"manufacturer\":\"SMA\",\"model\":\"Sunny
            Boy Storage
            2.5\",\"firmware\":\"2.4.23.R\",\"inverter\":{\"maxActivePowerOutput\":0,\"type\":\"SUNGROW_SG_20_RT\"},\"nominalPowerLimit\":0,\"hybridCalcMode\":0,\"battery\":{\"maxCharge\":501,\"maxDischarge\":501,\"controllable\":true,\"dischargeLimit\":0,\"rechargeLimit\":0,\"controlSettings\":{\"value\":0,\"command\":\"none\"}}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"inactive":true,"name":"string","type":"INVERTER","network":{"interface":"eth0","address":"192.168.178.153","port":0,"protocol":"tcp/modbus"},"loadSettings":{"disabled":true},"sensorSettings":{"sensorL1":0,"sensorL2":0,"sensorL3":0},"state":{"current":"SCANNED","transitions":[{"start":"CONNECTING","target":"DISCONNECTED"}]},"parent":"42e2bc1b-6741-4e2e-b138-97b4a342c999","serialnumber":"1901000652","cryptoSettings":[{"key":"string"}],"energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"kind":"UNKNOWN","manufacturer":"SMA","model":"Sunny Boy Storage 2.5","firmware":"2.4.23.R","inverter":{"maxActivePowerOutput":0,"type":"SUNGROW_SG_20_RT"},"nominalPowerLimit":0,"hybridCalcMode":0,"battery":{"maxCharge":501,"maxDischarge":501,"controllable":true,"dischargeLimit":0,"rechargeLimit":0,"controlSettings":{"value":0,"command":"none"}}}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"inactive":true,"name":"string","type":"INVERTER","network":{"interface":"eth0","address":"192.168.178.153","port":0,"protocol":"tcp/modbus"},"loadSettings":{"disabled":true},"sensorSettings":{"sensorL1":0,"sensorL2":0,"sensorL3":0},"state":{"current":"SCANNED","transitions":[{"start":"CONNECTING","target":"DISCONNECTED"}]},"parent":"42e2bc1b-6741-4e2e-b138-97b4a342c999","serialnumber":"1901000652","cryptoSettings":[{"key":"string"}],"energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"kind":"UNKNOWN","manufacturer":"SMA","model":"Sunny
            Boy Storage
            2.5","firmware":"2.4.23.R","inverter":{"maxActivePowerOutput":0,"type":"SUNGROW_SG_20_RT"},"nominalPowerLimit":0,"hybridCalcMode":0,"battery":{"maxCharge":501,"maxDischarge":501,"controllable":true,"dischargeLimit":0,"rechargeLimit":0,"controlSettings":{"value":0,"command":"none"}}}'
            |  \
              http POST https://api.gridx.de/gateways/%7BgatewayID%7D/appliances \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"inactive":true,"name":"string","type":"INVERTER","network":{"interface":"eth0","address":"192.168.178.153","port":0,"protocol":"tcp/modbus"},"loadSettings":{"disabled":true},"sensorSettings":{"sensorL1":0,"sensorL2":0,"sensorL3":0},"state":{"current":"SCANNED","transitions":[{"start":"CONNECTING","target":"DISCONNECTED"}]},"parent":"42e2bc1b-6741-4e2e-b138-97b4a342c999","serialnumber":"1901000652","cryptoSettings":[{"key":"string"}],"energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"kind":"UNKNOWN","manufacturer":"SMA","model":"Sunny Boy Storage 2.5","firmware":"2.4.23.R","inverter":{"maxActivePowerOutput":0,"type":"SUNGROW_SG_20_RT"},"nominalPowerLimit":0,"hybridCalcMode":0,"battery":{"maxCharge":501,"maxDischarge":501,"controllable":true,"dischargeLimit":0,"rechargeLimit":0,"controlSettings":{"value":0,"command":"none"}}}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "inactive": true,
              "name": "string",
              "type": "INVERTER",
              "network": [
                "interface": "eth0",
                "address": "192.168.178.153",
                "port": 0,
                "protocol": "tcp/modbus"
              ],
              "loadSettings": ["disabled": true],
              "sensorSettings": [
                "sensorL1": 0,
                "sensorL2": 0,
                "sensorL3": 0
              ],
              "state": [
                "current": "SCANNED",
                "transitions": [
                  [
                    "start": "CONNECTING",
                    "target": "DISCONNECTED"
                  ]
                ]
              ],
              "parent": "42e2bc1b-6741-4e2e-b138-97b4a342c999",
              "serialnumber": "1901000652",
              "cryptoSettings": [["key": "string"]],
              "energySettings": [
                "minControlInterval": 0,
                "socMax": 100,
                "socLockMax": 100,
                "socMin": 100,
                "socLockMin": 100,
                "socDeepDischarge": 100,
                "phaseMapping": [0, 0, 0],
                "temperatureExtremeMax": 0.1,
                "temperatureExtremeMin": 0.1,
                "temperatureComfortMax": 0.1,
                "temperatureComfortMin": 0.1,
                "surplusThreshold": 0
              ],
              "kind": "UNKNOWN",
              "manufacturer": "SMA",
              "model": "Sunny Boy Storage 2.5",
              "firmware": "2.4.23.R",
              "inverter": [
                "maxActivePowerOutput": 0,
                "type": "SUNGROW_SG_20_RT"
              ],
              "nominalPowerLimit": 0,
              "hybridCalcMode": 0,
              "battery": [
                "maxCharge": 501,
                "maxDischarge": 501,
                "controllable": true,
                "dischargeLimit": 0,
                "rechargeLimit": 0,
                "controlSettings": [
                  "value": 0,
                  "command": "none"
                ]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}':
    get:
      summary: Retrieve an Appliance
      description: Retrieves the details of an existing appliance.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - AppliancesRead
      parameters:
        - *ref_75
        - *ref_54
      responses:
        '200':
          description: Returned Appliance.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_62
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update an Appliance
      description: >
        Updates the specific appliance by setting the values of the body
        parameters. 


        Any parameters not provided will be left unchanged.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - AppliancesWrite
      parameters:
        - *ref_75
        - *ref_54
      requestBody: &ref_213
        description: Partially updates an appliance.
        required: true
        content:
          application/json:
            schema: &ref_398
              allOf:
                - &ref_397
                  title: Appliance Update
                  description: >
                    ApplianceUpdate contains fields of an appliance that can be
                    updated.
                  type: object
                  properties:
                    inactive: *ref_93
                    name: *ref_94
                    reverseFlow: *ref_114
                    room: *ref_115
                    loadSettings: *ref_97
                    kind:
                      description: >
                        Indicates the specific kind or role of the appliance.

                        Only settable for appliances of type `INVERTER` or
                        `METER`.
                      type: string
                      enum:
                        - UNKNOWN
                        - PV
                        - PV_EXTERNAL
                        - BATTERY
                        - HYBRID
                        - GRID
                        - HEAT_PUMP
                        - FUEL_CELL
                        - HEAT_PUMP_EXTERNAL
                        - EVSTATION
                        - BTTP
                        - HEATING
                        - MISC
                        - CLUSTER
                        - WIND_TURBINE
                    energySettings: *ref_103
                    cryptoSettings:
                      title: Crypto Settings
                      description: >-
                        Contains a list of crypto setting keys that are
                        associated with the appliance.
                      type: array
                      items: *ref_102
                    evLoadManagementParameters: *ref_116
                    evseID: *ref_117
                    desiredState: *ref_118
                    heatPump: *ref_52
                    ioDevice: *ref_53
                - additionalProperties: false
      responses:
        '200':
          description: Updated appliance.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_62
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"inactive\\\":true,\\\"name\\\":\\\"string\\\",\\\"reverseFlow\\\":true,\\\"room\\\":\\\"string\\\",\\\"loadSettings\\\":{\\\"disabled\\\":true},\\\"kind\\\":\\\"UNKNOWN\\\",\\\"energySettings\\\":{\\\"minControlInterval\\\":0,\\\"socMax\\\":100,\\\"socLockMax\\\":100,\\\"socMin\\\":100,\\\"socLockMin\\\":100,\\\"socDeepDischarge\\\":100,\\\"phaseMapping\\\":[0,0,0],\\\"temperatureExtremeMax\\\":0.1,\\\"temperatureExtremeMin\\\":0.1,\\\"temperatureComfortMax\\\":0.1,\\\"temperatureComfortMin\\\":0.1,\\\"surplusThreshold\\\":0},\\\"cryptoSettings\\\":[{\\\"key\\\":\\\"string\\\"}],\\\"evLoadManagementParameters\\\":{\\\"enabled\\\":true,\\\"maxPower\\\":0.1},\\\"evseID\\\":\\\"string\\\",\\\"desiredState\\\":\\\"UNKNOWN_APPLIANCE_STATE\\\",\\\"heatPump\\\":{\\\"type\\\":\\\"UNKNOWN\\\",\\\"controllable\\\":true,\\\"behindGCP\\\":true,\\\"withOwnTariff\\\":true,\\\"userControlEnabled\\\":true},\\\"ioDevice\\\":{\\\"type\\\":\\\"UNKNOWN\\\",\\\"inChannelsCount\\\":0,\\\"outChannelsCount\\\":0,\\\"inputChannels\\\":[{\\\"bitMask\\\":\\\"string\\\",\\\"bitValue\\\":\\\"string\\\",\\\"actions\\\":[{\\\"name\\\":\\\"string\\\",\\\"value\\\":0}]}],\\\"outputChannels\\\":[{\\\"bitMask\\\":\\\"string\\\",\\\"actions\\\":[{\\\"bitValue\\\":\\\"string\\\",\\\"sgReady\\\":{\\\"pMin\\\":0,\\\"pMax\\\":0,\\\"state\\\":\\\"UNKNOWN\\\",\\\"applianceID\\\":\\\"4a217362-c55e-47c7-80ab-a8320ee6c163\\\"}}]}]}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "inactive": true,
              "name": "string",
              "reverseFlow": true,
              "room": "string",
              "loadSettings": {
                "disabled": true
              },
              "kind": "UNKNOWN",
              "energySettings": {
                "minControlInterval": 0,
                "socMax": 100,
                "socLockMax": 100,
                "socMin": 100,
                "socLockMin": 100,
                "socDeepDischarge": 100,
                "phaseMapping": [
                  0,
                  0,
                  0
                ],
                "temperatureExtremeMax": 0.1,
                "temperatureExtremeMin": 0.1,
                "temperatureComfortMax": 0.1,
                "temperatureComfortMin": 0.1,
                "surplusThreshold": 0
              },
              "cryptoSettings": [
                {
                  "key": "string"
                }
              ],
              "evLoadManagementParameters": {
                "enabled": true,
                "maxPower": 0.1
              },
              "evseID": "string",
              "desiredState": "UNKNOWN_APPLIANCE_STATE",
              "heatPump": {
                "type": "UNKNOWN",
                "controllable": true,
                "behindGCP": true,
                "withOwnTariff": true,
                "userControlEnabled": true
              },
              "ioDevice": {
                "type": "UNKNOWN",
                "inChannelsCount": 0,
                "outChannelsCount": 0,
                "inputChannels": [
                  {
                    "bitMask": "string",
                    "bitValue": "string",
                    "actions": [
                      {
                        "name": "string",
                        "value": 0
                      }
                    ]
                  }
                ],
                "outputChannels": [
                  {
                    "bitMask": "string",
                    "actions": [
                      {
                        "bitValue": "string",
                        "sgReady": {
                          "pMin": 0,
                          "pMax": 0,
                          "state": "UNKNOWN",
                          "applianceID": "4a217362-c55e-47c7-80ab-a8320ee6c163"
                        }
                      }
                    ]
                  }
                ]
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              inactive: true,
              name: 'string',
              reverseFlow: true,
              room: 'string',
              loadSettings: {disabled: true},
              kind: 'UNKNOWN',
              energySettings: {
                minControlInterval: 0,
                socMax: 100,
                socLockMax: 100,
                socMin: 100,
                socLockMin: 100,
                socDeepDischarge: 100,
                phaseMapping: [0, 0, 0],
                temperatureExtremeMax: 0.1,
                temperatureExtremeMin: 0.1,
                temperatureComfortMax: 0.1,
                temperatureComfortMin: 0.1,
                surplusThreshold: 0
              },
              cryptoSettings: [{key: 'string'}],
              evLoadManagementParameters: {enabled: true, maxPower: 0.1},
              evseID: 'string',
              desiredState: 'UNKNOWN_APPLIANCE_STATE',
              heatPump: {
                type: 'UNKNOWN',
                controllable: true,
                behindGCP: true,
                withOwnTariff: true,
                userControlEnabled: true
              },
              ioDevice: {
                type: 'UNKNOWN',
                inChannelsCount: 0,
                outChannelsCount: 0,
                inputChannels: [{bitMask: 'string', bitValue: 'string', actions: [{name: 'string', value: 0}]}],
                outputChannels: [
                  {
                    bitMask: 'string',
                    actions: [
                      {
                        bitValue: 'string',
                        sgReady: {
                          pMin: 0,
                          pMax: 0,
                          state: 'UNKNOWN',
                          applianceID: '4a217362-c55e-47c7-80ab-a8320ee6c163'
                        }
                      }
                    ]
                  }
                ]
              }
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                inactive: true,
                name: 'string',
                reverseFlow: true,
                room: 'string',
                loadSettings: {disabled: true},
                kind: 'UNKNOWN',
                energySettings: {
                  minControlInterval: 0,
                  socMax: 100,
                  socLockMax: 100,
                  socMin: 100,
                  socLockMin: 100,
                  socDeepDischarge: 100,
                  phaseMapping: [0, 0, 0],
                  temperatureExtremeMax: 0.1,
                  temperatureExtremeMin: 0.1,
                  temperatureComfortMax: 0.1,
                  temperatureComfortMin: 0.1,
                  surplusThreshold: 0
                },
                cryptoSettings: [{key: 'string'}],
                evLoadManagementParameters: {enabled: true, maxPower: 0.1},
                evseID: 'string',
                desiredState: 'UNKNOWN_APPLIANCE_STATE',
                heatPump: {
                  type: 'UNKNOWN',
                  controllable: true,
                  behindGCP: true,
                  withOwnTariff: true,
                  userControlEnabled: true
                },
                ioDevice: {
                  type: 'UNKNOWN',
                  inChannelsCount: 0,
                  outChannelsCount: 0,
                  inputChannels: [{bitMask: 'string', bitValue: 'string', actions: [{name: 'string', value: 0}]}],
                  outputChannels: [
                    {
                      bitMask: 'string',
                      actions: [
                        {
                          bitValue: 'string',
                          sgReady: {
                            pMin: 0,
                            pMax: 0,
                            state: 'UNKNOWN',
                            applianceID: '4a217362-c55e-47c7-80ab-a8320ee6c163'
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "inactive": true,
              "name": "string",
              "reverseFlow": true,
              "room": "string",
              "loadSettings": {
                "disabled": true
              },
              "kind": "UNKNOWN",
              "energySettings": {
                "minControlInterval": 0,
                "socMax": 100,
                "socLockMax": 100,
                "socMin": 100,
                "socLockMin": 100,
                "socDeepDischarge": 100,
                "phaseMapping": [
                  0,
                  0,
                  0
                ],
                "temperatureExtremeMax": 0.1,
                "temperatureExtremeMin": 0.1,
                "temperatureComfortMax": 0.1,
                "temperatureComfortMin": 0.1,
                "surplusThreshold": 0
              },
              "cryptoSettings": [
                {
                  "key": "string"
                }
              ],
              "evLoadManagementParameters": {
                "enabled": true,
                "maxPower": 0.1
              },
              "evseID": "string",
              "desiredState": "UNKNOWN_APPLIANCE_STATE",
              "heatPump": {
                "type": "UNKNOWN",
                "controllable": true,
                "behindGCP": true,
                "withOwnTariff": true,
                "userControlEnabled": true
              },
              "ioDevice": {
                "type": "UNKNOWN",
                "inChannelsCount": 0,
                "outChannelsCount": 0,
                "inputChannels": [
                  {
                    "bitMask": "string",
                    "bitValue": "string",
                    "actions": [
                      {
                        "name": "string",
                        "value": 0
                      }
                    ]
                  }
                ],
                "outputChannels": [
                  {
                    "bitMask": "string",
                    "actions": [
                      {
                        "bitValue": "string",
                        "sgReady": {
                          "pMin": 0,
                          "pMax": 0,
                          "state": "UNKNOWN",
                          "applianceID": "4a217362-c55e-47c7-80ab-a8320ee6c163"
                        }
                      }
                    ]
                  }
                ]
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"inactive": @YES,
                                          @"name": @"string",
                                          @"reverseFlow": @YES,
                                          @"room": @"string",
                                          @"loadSettings": @{ @"disabled": @YES },
                                          @"kind": @"UNKNOWN",
                                          @"energySettings": @{ @"minControlInterval": @0, @"socMax": @100, @"socLockMax": @100, @"socMin": @100, @"socLockMin": @100, @"socDeepDischarge": @100, @"phaseMapping": @[ @0, @0, @0 ], @"temperatureExtremeMax": @0.1, @"temperatureExtremeMin": @0.1, @"temperatureComfortMax": @0.1, @"temperatureComfortMin": @0.1, @"surplusThreshold": @0 },
                                          @"cryptoSettings": @[ @{ @"key": @"string" } ],
                                          @"evLoadManagementParameters": @{ @"enabled": @YES, @"maxPower": @0.1 },
                                          @"evseID": @"string",
                                          @"desiredState": @"UNKNOWN_APPLIANCE_STATE",
                                          @"heatPump": @{ @"type": @"UNKNOWN", @"controllable": @YES, @"behindGCP": @YES, @"withOwnTariff": @YES, @"userControlEnabled": @YES },
                                          @"ioDevice": @{ @"type": @"UNKNOWN", @"inChannelsCount": @0, @"outChannelsCount": @0, @"inputChannels": @[ @{ @"bitMask": @"string", @"bitValue": @"string", @"actions": @[ @{ @"name": @"string", @"value": @0 } ] } ], @"outputChannels": @[ @{ @"bitMask": @"string", @"actions": @[ @{ @"bitValue": @"string", @"sgReady": @{ @"pMin": @0, @"pMax": @0, @"state": @"UNKNOWN", @"applianceID": @"4a217362-c55e-47c7-80ab-a8320ee6c163" } } ] } ] } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"inactive":true,"name":"string","reverseFlow":true,"room":"string","loadSettings":{"disabled":true},"kind":"UNKNOWN","energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"cryptoSettings":[{"key":"string"}],"evLoadManagementParameters":{"enabled":true,"maxPower":0.1},"evseID":"string","desiredState":"UNKNOWN_APPLIANCE_STATE","heatPump":{"type":"UNKNOWN","controllable":true,"behindGCP":true,"withOwnTariff":true,"userControlEnabled":true},"ioDevice":{"type":"UNKNOWN","inChannelsCount":0,"outChannelsCount":0,"inputChannels":[{"bitMask":"string","bitValue":"string","actions":[{"name":"string","value":0}]}],"outputChannels":[{"bitMask":"string","actions":[{"bitValue":"string","sgReady":{"pMin":0,"pMax":0,"state":"UNKNOWN","applianceID":"4a217362-c55e-47c7-80ab-a8320ee6c163"}}]}]}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"inactive":true,"name":"string","reverseFlow":true,"room":"string","loadSettings":{"disabled":true},"kind":"UNKNOWN","energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"cryptoSettings":[{"key":"string"}],"evLoadManagementParameters":{"enabled":true,"maxPower":0.1},"evseID":"string","desiredState":"UNKNOWN_APPLIANCE_STATE","heatPump":{"type":"UNKNOWN","controllable":true,"behindGCP":true,"withOwnTariff":true,"userControlEnabled":true},"ioDevice":{"type":"UNKNOWN","inChannelsCount":0,"outChannelsCount":0,"inputChannels":[{"bitMask":"string","bitValue":"string","actions":[{"name":"string","value":0}]}],"outputChannels":[{"bitMask":"string","actions":[{"bitValue":"string","sgReady":{"pMin":0,"pMax":0,"state":"UNKNOWN","applianceID":"4a217362-c55e-47c7-80ab-a8320ee6c163"}}]}]}}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"


            payload = {
                "inactive": True,
                "name": "string",
                "reverseFlow": True,
                "room": "string",
                "loadSettings": {"disabled": True},
                "kind": "UNKNOWN",
                "energySettings": {
                    "minControlInterval": 0,
                    "socMax": 100,
                    "socLockMax": 100,
                    "socMin": 100,
                    "socLockMin": 100,
                    "socDeepDischarge": 100,
                    "phaseMapping": [0, 0, 0],
                    "temperatureExtremeMax": 0.1,
                    "temperatureExtremeMin": 0.1,
                    "temperatureComfortMax": 0.1,
                    "temperatureComfortMin": 0.1,
                    "surplusThreshold": 0
                },
                "cryptoSettings": [{"key": "string"}],
                "evLoadManagementParameters": {
                    "enabled": True,
                    "maxPower": 0.1
                },
                "evseID": "string",
                "desiredState": "UNKNOWN_APPLIANCE_STATE",
                "heatPump": {
                    "type": "UNKNOWN",
                    "controllable": True,
                    "behindGCP": True,
                    "withOwnTariff": True,
                    "userControlEnabled": True
                },
                "ioDevice": {
                    "type": "UNKNOWN",
                    "inChannelsCount": 0,
                    "outChannelsCount": 0,
                    "inputChannels": [
                        {
                            "bitMask": "string",
                            "bitValue": "string",
                            "actions": [
                                {
                                    "name": "string",
                                    "value": 0
                                }
                            ]
                        }
                    ],
                    "outputChannels": [
                        {
                            "bitMask": "string",
                            "actions": [
                                {
                                    "bitValue": "string",
                                    "sgReady": {
                                        "pMin": 0,
                                        "pMax": 0,
                                        "state": "UNKNOWN",
                                        "applianceID": "4a217362-c55e-47c7-80ab-a8320ee6c163"
                                    }
                                }
                            ]
                        }
                    ]
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"inactive\":true,\"name\":\"string\",\"reverseFlow\":true,\"room\":\"string\",\"loadSettings\":{\"disabled\":true},\"kind\":\"UNKNOWN\",\"energySettings\":{\"minControlInterval\":0,\"socMax\":100,\"socLockMax\":100,\"socMin\":100,\"socLockMin\":100,\"socDeepDischarge\":100,\"phaseMapping\":[0,0,0],\"temperatureExtremeMax\":0.1,\"temperatureExtremeMin\":0.1,\"temperatureComfortMax\":0.1,\"temperatureComfortMin\":0.1,\"surplusThreshold\":0},\"cryptoSettings\":[{\"key\":\"string\"}],\"evLoadManagementParameters\":{\"enabled\":true,\"maxPower\":0.1},\"evseID\":\"string\",\"desiredState\":\"UNKNOWN_APPLIANCE_STATE\",\"heatPump\":{\"type\":\"UNKNOWN\",\"controllable\":true,\"behindGCP\":true,\"withOwnTariff\":true,\"userControlEnabled\":true},\"ioDevice\":{\"type\":\"UNKNOWN\",\"inChannelsCount\":0,\"outChannelsCount\":0,\"inputChannels\":[{\"bitMask\":\"string\",\"bitValue\":\"string\",\"actions\":[{\"name\":\"string\",\"value\":0}]}],\"outputChannels\":[{\"bitMask\":\"string\",\"actions\":[{\"bitValue\":\"string\",\"sgReady\":{\"pMin\":0,\"pMax\":0,\"state\":\"UNKNOWN\",\"applianceID\":\"4a217362-c55e-47c7-80ab-a8320ee6c163\"}}]}]}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"inactive":true,"name":"string","reverseFlow":true,"room":"string","loadSettings":{"disabled":true},"kind":"UNKNOWN","energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"cryptoSettings":[{"key":"string"}],"evLoadManagementParameters":{"enabled":true,"maxPower":0.1},"evseID":"string","desiredState":"UNKNOWN_APPLIANCE_STATE","heatPump":{"type":"UNKNOWN","controllable":true,"behindGCP":true,"withOwnTariff":true,"userControlEnabled":true},"ioDevice":{"type":"UNKNOWN","inChannelsCount":0,"outChannelsCount":0,"inputChannels":[{"bitMask":"string","bitValue":"string","actions":[{"name":"string","value":0}]}],"outputChannels":[{"bitMask":"string","actions":[{"bitValue":"string","sgReady":{"pMin":0,"pMax":0,"state":"UNKNOWN","applianceID":"4a217362-c55e-47c7-80ab-a8320ee6c163"}}]}]}}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"inactive":true,"name":"string","reverseFlow":true,"room":"string","loadSettings":{"disabled":true},"kind":"UNKNOWN","energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"cryptoSettings":[{"key":"string"}],"evLoadManagementParameters":{"enabled":true,"maxPower":0.1},"evseID":"string","desiredState":"UNKNOWN_APPLIANCE_STATE","heatPump":{"type":"UNKNOWN","controllable":true,"behindGCP":true,"withOwnTariff":true,"userControlEnabled":true},"ioDevice":{"type":"UNKNOWN","inChannelsCount":0,"outChannelsCount":0,"inputChannels":[{"bitMask":"string","bitValue":"string","actions":[{"name":"string","value":0}]}],"outputChannels":[{"bitMask":"string","actions":[{"bitValue":"string","sgReady":{"pMin":0,"pMax":0,"state":"UNKNOWN","applianceID":"4a217362-c55e-47c7-80ab-a8320ee6c163"}}]}]}}'
            |  \
              http PATCH https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"inactive":true,"name":"string","reverseFlow":true,"room":"string","loadSettings":{"disabled":true},"kind":"UNKNOWN","energySettings":{"minControlInterval":0,"socMax":100,"socLockMax":100,"socMin":100,"socLockMin":100,"socDeepDischarge":100,"phaseMapping":[0,0,0],"temperatureExtremeMax":0.1,"temperatureExtremeMin":0.1,"temperatureComfortMax":0.1,"temperatureComfortMin":0.1,"surplusThreshold":0},"cryptoSettings":[{"key":"string"}],"evLoadManagementParameters":{"enabled":true,"maxPower":0.1},"evseID":"string","desiredState":"UNKNOWN_APPLIANCE_STATE","heatPump":{"type":"UNKNOWN","controllable":true,"behindGCP":true,"withOwnTariff":true,"userControlEnabled":true},"ioDevice":{"type":"UNKNOWN","inChannelsCount":0,"outChannelsCount":0,"inputChannels":[{"bitMask":"string","bitValue":"string","actions":[{"name":"string","value":0}]}],"outputChannels":[{"bitMask":"string","actions":[{"bitValue":"string","sgReady":{"pMin":0,"pMax":0,"state":"UNKNOWN","applianceID":"4a217362-c55e-47c7-80ab-a8320ee6c163"}}]}]}}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "inactive": true,
              "name": "string",
              "reverseFlow": true,
              "room": "string",
              "loadSettings": ["disabled": true],
              "kind": "UNKNOWN",
              "energySettings": [
                "minControlInterval": 0,
                "socMax": 100,
                "socLockMax": 100,
                "socMin": 100,
                "socLockMin": 100,
                "socDeepDischarge": 100,
                "phaseMapping": [0, 0, 0],
                "temperatureExtremeMax": 0.1,
                "temperatureExtremeMin": 0.1,
                "temperatureComfortMax": 0.1,
                "temperatureComfortMin": 0.1,
                "surplusThreshold": 0
              ],
              "cryptoSettings": [["key": "string"]],
              "evLoadManagementParameters": [
                "enabled": true,
                "maxPower": 0.1
              ],
              "evseID": "string",
              "desiredState": "UNKNOWN_APPLIANCE_STATE",
              "heatPump": [
                "type": "UNKNOWN",
                "controllable": true,
                "behindGCP": true,
                "withOwnTariff": true,
                "userControlEnabled": true
              ],
              "ioDevice": [
                "type": "UNKNOWN",
                "inChannelsCount": 0,
                "outChannelsCount": 0,
                "inputChannels": [
                  [
                    "bitMask": "string",
                    "bitValue": "string",
                    "actions": [
                      [
                        "name": "string",
                        "value": 0
                      ]
                    ]
                  ]
                ],
                "outputChannels": [
                  [
                    "bitMask": "string",
                    "actions": [
                      [
                        "bitValue": "string",
                        "sgReady": [
                          "pMin": 0,
                          "pMax": 0,
                          "state": "UNKNOWN",
                          "applianceID": "4a217362-c55e-47c7-80ab-a8320ee6c163"
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete an Appliance
      description: Deletes an appliances.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - AppliancesWrite
      parameters:
        - *ref_75
        - *ref_54
      responses:
        '204':
          description: Appliance has been deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}/status':
    get:
      summary: Retrieve appliance hardware statuses
      description: >
        Returns appliance hardware statuses for the given interval.


        Only returns multiple statuses when state changes during the given
        interval. If, for example, the state stayed the same for the whole
        interval,

        only one status will be returned.


        Works only for **inverters** currently.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - AppliancesRead
      parameters:
        - *ref_75
        - *ref_54
        - *ref_119
      responses:
        '200':
          description: Returned hardware status.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_399
                title: Hardware Status array
                type: object
                description: >
                  HardwareStatusData provides information about the status of
                  hardware and holds an array of HardwareStatus. 
                properties:
                  data:
                    type: array
                    items: *ref_120
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status',
              qs: {interval: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status"


            querystring = {"interval":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/status?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}/ev/configuration':
    get:
      summary: Retrieve an EV configuration
      description: Returns an EV charging station's configuration.
      tags:
        - EV Configuration
      security:
        - BearerAuth:
            - AppliancesEVConfigurationRead
      parameters:
        - *ref_75
        - *ref_54
      responses:
        '200':
          description: Returned EV configuration.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_122
                type: object
                readOnly: true
                allOf:
                  - &ref_121
                    title: EV Charging Station Configuration
                    description: >
                      Configure the charge mode and other settings considered by
                      the EMS and applied to the EV charging station.
                    type: object
                    properties:
                      issueTimestamp:
                        type: string
                        format: date-time
                        deprecated: true
                        description: >
                          Specifies when the configuration was send or received
                          the last time by the EMS.


                          **Deprecated** - No longer updated, always returns the
                          current date.
                      chargingEnabled:
                        type: boolean
                        nullable: true
                        description: Specifies whether charging is allowed.
                      chargingRemoteControllable:
                        type: boolean
                        nullable: true
                        description: >-
                          Specifies whether charging may be controlled via
                          network connection.
                      lockEnabled:
                        type: boolean
                        nullable: true
                        description: Specifies whether the plug is locked.
                      minRequestedSoc:
                        type: number
                        nullable: true
                        minimum: 0
                        maximum: 100
                        format: double
                        description: >
                          The minimum SoC the EV shall have and keep to
                          guarantee the range for the next usage.


                          This is set by the user and needed for
                          `DEPARTURE_TIME_EV` and `MIN_EV` charge modes.

                          If this value is set, the `userTotalCapacity` needs to
                          be set, too.

                          Value is between 0.0 - 100.0 in %.
                        example: 30
                      departureTimestamp:
                        type: string
                        format: date-time
                        nullable: true
                        description: >
                          The departure time of the EV for the
                          `DEPARTURE_TIME_EV` charge mode.


                          Only the time of the day is considered, not the exact
                          date. 

                          If the time of day is in the past it is interpreted as
                          tomorrow and if it in the future it is today.
                      estimatedDepartureTimestamp:
                        type: string
                        format: date-time
                        description: >
                          The estimated timestamp when the desired SoC is
                          reached.


                          Optimally, the timestamp is close to the user's wanted
                          `departureTimestamp`.

                          The estimated timestamp is calculated by the EMS and
                          takes into account the current SoC of the EV and the
                          fact that the EV power can be curtailed by the DLM.
                      userSoc:
                        type: number
                        format: double
                        nullable: true
                        minimum: 0
                        maximum: 100
                        description: >
                          The State of Charge (SoC) level read and set by the
                          user for the connected EV.


                          This is needed in cases where the SoC cannot be
                          determined automatically.

                          Value is between 0.0 - 100.0 in %.
                        example: 50
                      userTotalCapacity:
                        type: number
                        format: double
                        nullable: true
                        description: >
                          The size of the EV's battery in Wh.


                          If this cannot be determined directly from the
                          hardware, then the user enters it during the
                          onboarding process.

                          The value is needed to calculate the energy that needs
                          to be charged to fulfill the `minRequestedSoc`.
                        minimum: 0
                        example: 82000
                      chargeMode:
                        type: string
                        description: |
                          Defines how the EV shall be charged.
                            * `FORCED_EV`: EV will be charged with full power until 100% SoC. This is the default behaviour, also if there is no configuration set. It does not require any additional fields to be set. Also commonly referred to as "Quick Charge".
                            * `MIN_EV`: EV will be charged with full power until the specified `minRequestedSoc` (must be provided). Also commonly referred to as "Safety Charge".
                            * `DEPARTURE_TIME_EV`: EV will be charged until `departureTimestamp` to the `minRequestedSoc`. This means that initially it charges with surplus energy, but if it is not enough it will charge with full power to meet the requested `departureTimestamp`. Also commonly referred to as "Program Charge".
                            * `SURPLUS_EV`: EV will only be charged with surplus energy regardless of SoC level. It does not require any additional fields to be set. Also commonly referred to as "Solar Charge".
                        enum:
                          - FORCED_EV
                          - MIN_EV
                          - DEPARTURE_TIME_EV
                          - SURPLUS_EV
                      maxPowerCalculated:
                        type: number
                        format: double
                        nullable: true
                        description: >
                          The maximum potential total charge power in Watt is
                          calculated by the gridBox in usual setups.


                          The total power is defined as sum of all phases'
                          power.

                          It considers the maximum power supported by the EV and
                          that the power can be curtailed by the DLM.
                        minimum: 0
                        example: 8000
                      maxChargePower:
                        type: number
                        format: double
                        nullable: true
                        description: >
                          The maximum total power that the EV should be charged
                          with in Watt.


                          The total power is defined as sum of all phases'
                          power.

                          EV charging power will not exceed the specified value.
                        minimum: 0
                        example: 8000
                      minChargePower:
                        type: number
                        format: double
                        nullable: true
                        description: >
                          The minimum total power that the EV should be charged
                          with in Watt.


                          The total power is defined as sum of all phases'
                          power.

                          EV will only be charged if the total power is above
                          the specified value.
                        minimum: 0
                        example: 2070
                      minChargePowerPerPhase:
                        type: number
                        format: double
                        description: >
                          The minimum power that the EV should be charged with
                          in Watt for one phase.


                          EV will only be charged if **one** of the phases'
                          power is above the specified value.
                        minimum: 0
                        example: 1840
                      evProfileID:
                        description: >-
                          Represents the ID of the EV profile that is going to
                          be used in the next charging session.
                        type: string
                        format: uuid
                        example: 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                  - required:
                      - applianceID
                      - createdAt
                      - updatedAt
                      - chargingEnabled
                      - chargingRemoteControllable
                      - lockEnabled
                      - minRequestedSoc
                      - departureTimestamp
                      - userSoc
                      - userTotalCapacity
                      - maxPowerCalculated
                      - maxChargePower
                      - minChargePower
                    properties:
                      applianceID:
                        type: string
                        format: uuid
                        description: >
                          ID of the EV charging station this configuration
                          belongs to. 
                      createdAt:
                        type: string
                        format: date-time
                        description: Specifies when the configuration was created.
                      updatedAt:
                        type: string
                        format: date-time
                        description: >-
                          Specifies when the configuration was updated the last
                          time.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create an EV Configuration
      description: >
        Creates an EV charging station's configuration if no configuration is
        present.
      tags:
        - EV Configuration
      security:
        - BearerAuth:
            - AppliancesEVConfigurationWrite
      parameters:
        - *ref_75
        - *ref_54
      requestBody:
        description: EV configuration to be created.
        required: true
        content:
          application/json:
            schema: &ref_401
              allOf:
                - &ref_400
                  type: object
                  allOf:
                    - *ref_121
                - additionalProperties: false
      responses:
        '201':
          description: EV charging station configuration created.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_122
        '400': *ref_15
        '403': *ref_11
        '404': *ref_85
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration\"\n\n\tpayload := strings.NewReader(\"{\\\"issueTimestamp\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"chargingEnabled\\\":true,\\\"chargingRemoteControllable\\\":true,\\\"lockEnabled\\\":true,\\\"minRequestedSoc\\\":30,\\\"departureTimestamp\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"estimatedDepartureTimestamp\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"userSoc\\\":50,\\\"userTotalCapacity\\\":82000,\\\"chargeMode\\\":\\\"FORCED_EV\\\",\\\"maxPowerCalculated\\\":8000,\\\"maxChargePower\\\":8000,\\\"minChargePower\\\":2070,\\\"minChargePowerPerPhase\\\":1840,\\\"evProfileID\\\":\\\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "issueTimestamp": "2019-08-24T14:15:22Z",
              "chargingEnabled": true,
              "chargingRemoteControllable": true,
              "lockEnabled": true,
              "minRequestedSoc": 30,
              "departureTimestamp": "2019-08-24T14:15:22Z",
              "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
              "userSoc": 50,
              "userTotalCapacity": 82000,
              "chargeMode": "FORCED_EV",
              "maxPowerCalculated": 8000,
              "maxChargePower": 8000,
              "minChargePower": 2070,
              "minChargePowerPerPhase": 1840,
              "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              issueTimestamp: '2019-08-24T14:15:22Z',
              chargingEnabled: true,
              chargingRemoteControllable: true,
              lockEnabled: true,
              minRequestedSoc: 30,
              departureTimestamp: '2019-08-24T14:15:22Z',
              estimatedDepartureTimestamp: '2019-08-24T14:15:22Z',
              userSoc: 50,
              userTotalCapacity: 82000,
              chargeMode: 'FORCED_EV',
              maxPowerCalculated: 8000,
              maxChargePower: 8000,
              minChargePower: 2070,
              minChargePowerPerPhase: 1840,
              evProfileID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                issueTimestamp: '2019-08-24T14:15:22Z',
                chargingEnabled: true,
                chargingRemoteControllable: true,
                lockEnabled: true,
                minRequestedSoc: 30,
                departureTimestamp: '2019-08-24T14:15:22Z',
                estimatedDepartureTimestamp: '2019-08-24T14:15:22Z',
                userSoc: 50,
                userTotalCapacity: 82000,
                chargeMode: 'FORCED_EV',
                maxPowerCalculated: 8000,
                maxChargePower: 8000,
                minChargePower: 2070,
                minChargePowerPerPhase: 1840,
                evProfileID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "issueTimestamp": "2019-08-24T14:15:22Z",
              "chargingEnabled": true,
              "chargingRemoteControllable": true,
              "lockEnabled": true,
              "minRequestedSoc": 30,
              "departureTimestamp": "2019-08-24T14:15:22Z",
              "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
              "userSoc": 50,
              "userTotalCapacity": 82000,
              "chargeMode": "FORCED_EV",
              "maxPowerCalculated": 8000,
              "maxChargePower": 8000,
              "minChargePower": 2070,
              "minChargePowerPerPhase": 1840,
              "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"issueTimestamp":
            @"2019-08-24T14:15:22Z",
                                          @"chargingEnabled": @YES,
                                          @"chargingRemoteControllable": @YES,
                                          @"lockEnabled": @YES,
                                          @"minRequestedSoc": @30,
                                          @"departureTimestamp": @"2019-08-24T14:15:22Z",
                                          @"estimatedDepartureTimestamp": @"2019-08-24T14:15:22Z",
                                          @"userSoc": @50,
                                          @"userTotalCapacity": @82000,
                                          @"chargeMode": @"FORCED_EV",
                                          @"maxPowerCalculated": @8000,
                                          @"maxChargePower": @8000,
                                          @"minChargePower": @2070,
                                          @"minChargePowerPerPhase": @1840,
                                          @"evProfileID": @"6dd0a658-5828-4d30-bc65-a03c6d6e425f" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"


            payload = {
                "issueTimestamp": "2019-08-24T14:15:22Z",
                "chargingEnabled": True,
                "chargingRemoteControllable": True,
                "lockEnabled": True,
                "minRequestedSoc": 30,
                "departureTimestamp": "2019-08-24T14:15:22Z",
                "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
                "userSoc": 50,
                "userTotalCapacity": 82000,
                "chargeMode": "FORCED_EV",
                "maxPowerCalculated": 8000,
                "maxChargePower": 8000,
                "minChargePower": 2070,
                "minChargePowerPerPhase": 1840,
                "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}'
            |  \
              http POST https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "issueTimestamp": "2019-08-24T14:15:22Z",
              "chargingEnabled": true,
              "chargingRemoteControllable": true,
              "lockEnabled": true,
              "minRequestedSoc": 30,
              "departureTimestamp": "2019-08-24T14:15:22Z",
              "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
              "userSoc": 50,
              "userTotalCapacity": 82000,
              "chargeMode": "FORCED_EV",
              "maxPowerCalculated": 8000,
              "maxChargePower": 8000,
              "minChargePower": 2070,
              "minChargePowerPerPhase": 1840,
              "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update an EV configuration
      description: >-
        Updates the specified appliance's EV charging station configuration by
        setting the body parameters.
      tags:
        - EV Configuration
      security:
        - BearerAuth:
            - AppliancesEVConfigurationWrite
      parameters:
        - *ref_75
        - *ref_54
      requestBody:
        description: Modified EV configuration.
        required: true
        content:
          application/json:
            schema: &ref_402
              type: object
              allOf:
                - *ref_121
      responses:
        '200':
          description: Updated Charging Station configuration.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_122
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration\"\n\n\tpayload := strings.NewReader(\"{\\\"issueTimestamp\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"chargingEnabled\\\":true,\\\"chargingRemoteControllable\\\":true,\\\"lockEnabled\\\":true,\\\"minRequestedSoc\\\":30,\\\"departureTimestamp\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"estimatedDepartureTimestamp\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"userSoc\\\":50,\\\"userTotalCapacity\\\":82000,\\\"chargeMode\\\":\\\"FORCED_EV\\\",\\\"maxPowerCalculated\\\":8000,\\\"maxChargePower\\\":8000,\\\"minChargePower\\\":2070,\\\"minChargePowerPerPhase\\\":1840,\\\"evProfileID\\\":\\\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "issueTimestamp": "2019-08-24T14:15:22Z",
              "chargingEnabled": true,
              "chargingRemoteControllable": true,
              "lockEnabled": true,
              "minRequestedSoc": 30,
              "departureTimestamp": "2019-08-24T14:15:22Z",
              "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
              "userSoc": 50,
              "userTotalCapacity": 82000,
              "chargeMode": "FORCED_EV",
              "maxPowerCalculated": 8000,
              "maxChargePower": 8000,
              "minChargePower": 2070,
              "minChargePowerPerPhase": 1840,
              "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              issueTimestamp: '2019-08-24T14:15:22Z',
              chargingEnabled: true,
              chargingRemoteControllable: true,
              lockEnabled: true,
              minRequestedSoc: 30,
              departureTimestamp: '2019-08-24T14:15:22Z',
              estimatedDepartureTimestamp: '2019-08-24T14:15:22Z',
              userSoc: 50,
              userTotalCapacity: 82000,
              chargeMode: 'FORCED_EV',
              maxPowerCalculated: 8000,
              maxChargePower: 8000,
              minChargePower: 2070,
              minChargePowerPerPhase: 1840,
              evProfileID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                issueTimestamp: '2019-08-24T14:15:22Z',
                chargingEnabled: true,
                chargingRemoteControllable: true,
                lockEnabled: true,
                minRequestedSoc: 30,
                departureTimestamp: '2019-08-24T14:15:22Z',
                estimatedDepartureTimestamp: '2019-08-24T14:15:22Z',
                userSoc: 50,
                userTotalCapacity: 82000,
                chargeMode: 'FORCED_EV',
                maxPowerCalculated: 8000,
                maxChargePower: 8000,
                minChargePower: 2070,
                minChargePowerPerPhase: 1840,
                evProfileID: '6dd0a658-5828-4d30-bc65-a03c6d6e425f'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "issueTimestamp": "2019-08-24T14:15:22Z",
              "chargingEnabled": true,
              "chargingRemoteControllable": true,
              "lockEnabled": true,
              "minRequestedSoc": 30,
              "departureTimestamp": "2019-08-24T14:15:22Z",
              "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
              "userSoc": 50,
              "userTotalCapacity": 82000,
              "chargeMode": "FORCED_EV",
              "maxPowerCalculated": 8000,
              "maxChargePower": 8000,
              "minChargePower": 2070,
              "minChargePowerPerPhase": 1840,
              "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"issueTimestamp":
            @"2019-08-24T14:15:22Z",
                                          @"chargingEnabled": @YES,
                                          @"chargingRemoteControllable": @YES,
                                          @"lockEnabled": @YES,
                                          @"minRequestedSoc": @30,
                                          @"departureTimestamp": @"2019-08-24T14:15:22Z",
                                          @"estimatedDepartureTimestamp": @"2019-08-24T14:15:22Z",
                                          @"userSoc": @50,
                                          @"userTotalCapacity": @82000,
                                          @"chargeMode": @"FORCED_EV",
                                          @"maxPowerCalculated": @8000,
                                          @"maxChargePower": @8000,
                                          @"minChargePower": @2070,
                                          @"minChargePowerPerPhase": @1840,
                                          @"evProfileID": @"6dd0a658-5828-4d30-bc65-a03c6d6e425f" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"


            payload = {
                "issueTimestamp": "2019-08-24T14:15:22Z",
                "chargingEnabled": True,
                "chargingRemoteControllable": True,
                "lockEnabled": True,
                "minRequestedSoc": 30,
                "departureTimestamp": "2019-08-24T14:15:22Z",
                "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
                "userSoc": 50,
                "userTotalCapacity": 82000,
                "chargeMode": "FORCED_EV",
                "maxPowerCalculated": 8000,
                "maxChargePower": 8000,
                "minChargePower": 2070,
                "minChargePowerPerPhase": 1840,
                "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"issueTimestamp\":\"2019-08-24T14:15:22Z\",\"chargingEnabled\":true,\"chargingRemoteControllable\":true,\"lockEnabled\":true,\"minRequestedSoc\":30,\"departureTimestamp\":\"2019-08-24T14:15:22Z\",\"estimatedDepartureTimestamp\":\"2019-08-24T14:15:22Z\",\"userSoc\":50,\"userTotalCapacity\":82000,\"chargeMode\":\"FORCED_EV\",\"maxPowerCalculated\":8000,\"maxChargePower\":8000,\"minChargePower\":2070,\"minChargePowerPerPhase\":1840,\"evProfileID\":\"6dd0a658-5828-4d30-bc65-a03c6d6e425f\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}'
            |  \
              http PATCH https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"issueTimestamp":"2019-08-24T14:15:22Z","chargingEnabled":true,"chargingRemoteControllable":true,"lockEnabled":true,"minRequestedSoc":30,"departureTimestamp":"2019-08-24T14:15:22Z","estimatedDepartureTimestamp":"2019-08-24T14:15:22Z","userSoc":50,"userTotalCapacity":82000,"chargeMode":"FORCED_EV","maxPowerCalculated":8000,"maxChargePower":8000,"minChargePower":2070,"minChargePowerPerPhase":1840,"evProfileID":"6dd0a658-5828-4d30-bc65-a03c6d6e425f"}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "issueTimestamp": "2019-08-24T14:15:22Z",
              "chargingEnabled": true,
              "chargingRemoteControllable": true,
              "lockEnabled": true,
              "minRequestedSoc": 30,
              "departureTimestamp": "2019-08-24T14:15:22Z",
              "estimatedDepartureTimestamp": "2019-08-24T14:15:22Z",
              "userSoc": 50,
              "userTotalCapacity": 82000,
              "chargeMode": "FORCED_EV",
              "maxPowerCalculated": 8000,
              "maxChargePower": 8000,
              "minChargePower": 2070,
              "minChargePowerPerPhase": 1840,
              "evProfileID": "6dd0a658-5828-4d30-bc65-a03c6d6e425f"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete an EV configuration
      description: Deletes an EV charging Station configuration.
      tags:
        - EV Configuration
      security:
        - BearerAuth:
            - AppliancesEVConfigurationWrite
      parameters:
        - *ref_75
        - *ref_54
      responses:
        '204':
          description: EV configuration has been deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/ev/configuration")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}/battery/settings':
    get:
      summary: Retrieve Battery Control Settings
      description: Returns battery control Settings
      deprecated: true
      tags:
        - Battery Control Command
      security:
        - BearerAuth:
            - AppliancesBatteryControlSettingsRead
      parameters:
        - *ref_75
        - *ref_54
      responses:
        '200':
          description: Returned battery control Settings.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_123
                title: Battery Control Settings
                description: >
                  Represents settings for a battery, indicating whether it is
                  set to

                  charge or discharge.
                type: object
                properties:
                  value:
                    type: integer
                    format: int64
                    description: represents the charge/discharge power in mW
                  command:
                    type: integer
                    format: int64
                    description: >-
                      represents the current control command
                      (charge/discharge/none)
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create Battery Control Settings
      deprecated: true
      tags:
        - Battery Control Command
      security:
        - BearerAuth:
            - AppliancesBatteryControlSettingsWrite
      parameters:
        - *ref_75
        - *ref_54
      requestBody:
        description: Battery Control Settings to be created.
        required: true
        content:
          application/json:
            schema: &ref_124
              allOf:
                - *ref_123
                - additionalProperties: false
      responses:
        '201':
          description: Created battery control settings.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_123
        '400': *ref_15
        '403': *ref_11
        '404': *ref_85
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"value\":0,\"command\":0}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"value\":0,\"command\":0}", ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"value\\\":0,\\\"command\\\":0}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"value\":0,\"command\":0}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"value\":0,\"command\":0}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0,\"command\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "value": 0,
              "command": 0
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0,\"command\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({value: 0, command: 0}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {value: 0, command: 0},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "value": 0,
              "command": 0
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"value": @0,
                                          @"command": @0 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"value\":0,\"command\":0}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"value\":0,\"command\":0}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"value":0,"command":0}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"value":0,"command":0}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"value\":0,\"command\":0}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"


            payload = {
                "value": 0,
                "command": 0
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"value\":0,\"command\":0}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"value":0,"command":0}'
        - lang: Shell + Httpie
          source: |-
            echo '{"value":0,"command":0}' |  \
              http POST https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"value":0,"command":0}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "value": 0,
              "command": 0
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update Battery Control Settings
      deprecated: true
      description: >-
        Updates the specific appliance's battery control settings by setting the
        values of the body parameter.
      tags:
        - Battery Control Command
      security:
        - BearerAuth:
            - AppliancesBatteryControlSettingsWrite
      parameters:
        - *ref_75
        - *ref_54
      requestBody:
        description: Modified battery control settings.
        required: true
        content:
          application/json:
            schema: *ref_124
      responses:
        '200':
          description: Updated battery control settings.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_123
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"value\":0,\"command\":0}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"value\":0,\"command\":0}", ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"value\\\":0,\\\"command\\\":0}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"value\":0,\"command\":0}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"value\":0,\"command\":0}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0,\"command\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "value": 0,
              "command": 0
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0,\"command\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({value: 0, command: 0}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {value: 0, command: 0},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "value": 0,
              "command": 0
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"value": @0,
                                          @"command": @0 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"value\":0,\"command\":0}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"value\":0,\"command\":0}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"value":0,"command":0}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"value":0,"command":0}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"value\":0,\"command\":0}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"


            payload = {
                "value": 0,
                "command": 0
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"value\":0,\"command\":0}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"value":0,"command":0}'
        - lang: Shell + Httpie
          source: |-
            echo '{"value":0,"command":0}' |  \
              http PATCH https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"value":0,"command":0}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "value": 0,
              "command": 0
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Battery Control Settings
      deprecated: true
      description: Deletes appliance's battery control settings.
      tags:
        - Battery Control Command
      security:
        - BearerAuth:
            - AppliancesBatteryControlSettingsWrite
      parameters:
        - *ref_75
        - *ref_54
      responses:
        '204':
          description: Battery Control Settings has been deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/battery/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/ev-profiles':
    get:
      summary: List available EV profiles
      description: Lists EV profiles that belong the the specified system.
      tags:
        - EV Profile
      security:
        - BearerAuth:
            - EVProfilesRead
      parameters:
        - *ref_74
      responses:
        '200':
          description: Available EV profiles.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_126
                  allOf:
                    - &ref_125
                      title: ElectricVehicleProfile
                      description: Represents data related to an EV Profile.
                      type: object
                      properties:
                        name:
                          type: string
                          description: Name of the EV profile.
                          example: My profile
                        manufacturer:
                          type: string
                          description: The manufacturer of the EV.
                          example: Tesla
                        model:
                          type: string
                          description: The model of the EV (manufacturer-dependent).
                          example: Model-3
                        color:
                          type: string
                          description: The color of the EV.
                          example: red
                        capacity:
                          type: number
                          description: Battery capacity of the EV in Wh.
                          example: 12000
                        averageConsumption:
                          type: number
                          description: >-
                            The average consumption of the EV provided in
                            Wh/100km.
                          example: 30000
                        phasesCount:
                          type: number
                          format: int64
                          description: >-
                            The number of phases used for charging the EV (range
                            1-3).
                          example: 1
                        minChargePower:
                          description: >
                            The minimum total power that the EV should be
                            charged with in Watt.   


                            If the EV Profile is assigned to a charging station,
                            this configuration will be applied, 

                            otherwise, the [EV Charging Station
                            Configuration](https://developer.gridx.ai/reference/get_gateways-gatewayid-appliances-applianceid-ev-configuration)
                            will be used.
                          type: number
                          format: double
                          example: 8000
                        userSoc:
                          description: >
                            The State of Charge (SoC) level read and set by the
                            user for the connected EV.


                            This is needed in cases where the SoC cannot be
                            determined automatically.

                            Value is between 0.0 - 100.0 in %.

                            If the EV Profile is assigned to a charging station,
                            this configuration will be applied,

                            otherwise, the [EV Charging Station
                            Configuration](https://developer.gridx.ai/reference/get_gateways-gatewayid-appliances-applianceid-ev-configuration)
                            will be used.
                          type: number
                          format: double
                          minimum: 0
                          maximum: 100
                          example: 50
                        image:
                          description: >-
                            Image to be used when displaying the EV profile in
                            base64 encoding. Format must be `jpeg` or `png`.
                          type: string
                          example: >-
                            data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
                        minChargePowerPerPhase:
                          type: number
                          description: >-
                            Defines the minimum charge power in W for one phase
                            set by the user.
                          example: 2070
                        minRequestedSoc:
                          type: number
                          description: >-
                            The minimum state of charge the EV shall have and
                            keep to guarantee the range for the next usage. This
                            is set by the user. The value ranges from 0.0 -
                            100.0 in %.
                          example: 70
                    - properties:
                        id:
                          type: string
                          format: uuid
                          description: Unique identifier of an EV profile.
                          example: 51c0c70f-dfcc-4520-b535-0ecc44c75e12
                        systemID:
                          description: >-
                            Unique identifier of the system that this EV profile
                            belongs to.
                          type: string
                          format: uuid
                          example: 938b84d9-17e9-44e5-b422-4fb95ea3550b
                        createdAt:
                          type: string
                          format: date-time
                          readOnly: true
                          description: >-
                            Date when the EV profile was created in UTC using
                            the RFC3339 format.
                          example: '2022-11-10T23:20:50Z'
                        updatedAt:
                          type: string
                          format: date-time
                          readOnly: true
                          description: >-
                            Date when the EV profile was updated the last time
                            in UTC using the RFC3339 format.
                          example: '2022-11-12T23:20:50Z'
                        chargingStationApplianceIDs:
                          readOnly: true
                          title: ChargingStationApplianceIDs
                          description: >
                            ChargingStationApplianceIDs represents the charging
                            station appliances the EV is assigned to.
                          type: array
                          items:
                            type: string
                            format: uuid
                          example:
                            - 6dd0a658-5828-4d30-bc65-a03c6d6e425f
                            - e3bb9553-78a6-4f4f-98d5-5c5f9012251d
                      required:
                        - id
                        - systemID
                        - createdAt
                        - updatedAt
        '403': *ref_11
        '404': &ref_127
          description: Entity Not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/ev-profiles",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/ev-profiles",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a new EV profile
      description: Creates an EV profile.
      tags:
        - EV Profile
      security:
        - BearerAuth:
            - EVProfilesWrite
      parameters:
        - *ref_74
      requestBody:
        description: EV profile to be created.
        required: true
        content:
          application/json:
            schema: &ref_403
              allOf:
                - *ref_125
                - properties:
                    id:
                      type: string
                      format: uuid
                      description: Unique identifier of an EV profile.
                      example: 51c0c70f-dfcc-4520-b535-0ecc44c75e12
      responses:
        '201':
          description: Created EV profile.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_126
        '403': *ref_11
        '404': *ref_127
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"My profile\\\",\\\"manufacturer\\\":\\\"Tesla\\\",\\\"model\\\":\\\"Model-3\\\",\\\"color\\\":\\\"red\\\",\\\"capacity\\\":12000,\\\"averageConsumption\\\":30000,\\\"phasesCount\\\":1,\\\"minChargePower\\\":8000,\\\"userSoc\\\":50,\\\"image\\\":\\\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\",\\\"minChargePowerPerPhase\\\":2070,\\\"minRequestedSoc\\\":70,\\\"id\\\":\\\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "My profile",
              "manufacturer": "Tesla",
              "model": "Model-3",
              "color": "red",
              "capacity": 12000,
              "averageConsumption": 30000,
              "phasesCount": 1,
              "minChargePower": 8000,
              "userSoc": 50,
              "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              "minChargePowerPerPhase": 2070,
              "minRequestedSoc": 70,
              "id": "51c0c70f-dfcc-4520-b535-0ecc44c75e12"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/ev-profiles",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'My profile',
              manufacturer: 'Tesla',
              model: 'Model-3',
              color: 'red',
              capacity: 12000,
              averageConsumption: 30000,
              phasesCount: 1,
              minChargePower: 8000,
              userSoc: 50,
              image: 'data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
              minChargePowerPerPhase: 2070,
              minRequestedSoc: 70,
              id: '51c0c70f-dfcc-4520-b535-0ecc44c75e12'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'My profile',
                manufacturer: 'Tesla',
                model: 'Model-3',
                color: 'red',
                capacity: 12000,
                averageConsumption: 30000,
                phasesCount: 1,
                minChargePower: 8000,
                userSoc: 50,
                image: 'data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
                minChargePowerPerPhase: 2070,
                minRequestedSoc: 70,
                id: '51c0c70f-dfcc-4520-b535-0ecc44c75e12'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "My profile",
              "manufacturer": "Tesla",
              "model": "Model-3",
              "color": "red",
              "capacity": 12000,
              "averageConsumption": 30000,
              "phasesCount": 1,
              "minChargePower": 8000,
              "userSoc": 50,
              "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              "minChargePowerPerPhase": 2070,
              "minRequestedSoc": 70,
              "id": "51c0c70f-dfcc-4520-b535-0ecc44c75e12"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"My profile",
                                          @"manufacturer": @"Tesla",
                                          @"model": @"Model-3",
                                          @"color": @"red",
                                          @"capacity": @12000,
                                          @"averageConsumption": @30000,
                                          @"phasesCount": @1,
                                          @"minChargePower": @8000,
                                          @"userSoc": @50,
                                          @"image": @"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                                          @"minChargePowerPerPhase": @2070,
                                          @"minRequestedSoc": @70,
                                          @"id": @"51c0c70f-dfcc-4520-b535-0ecc44c75e12" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"My
            profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70,"id":"51c0c70f-dfcc-4520-b535-0ecc44c75e12"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"My
            profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70,"id":"51c0c70f-dfcc-4520-b535-0ecc44c75e12"}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems/%7BsystemID%7D/ev-profiles", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles"


            payload = {
                "name": "My profile",
                "manufacturer": "Tesla",
                "model": "Model-3",
                "color": "red",
                "capacity": 12000,
                "averageConsumption": 30000,
                "phasesCount": 1,
                "minChargePower": 8000,
                "userSoc": 50,
                "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                "minChargePowerPerPhase": 2070,
                "minRequestedSoc": 70,
                "id": "51c0c70f-dfcc-4520-b535-0ecc44c75e12"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70,\"id\":\"51c0c70f-dfcc-4520-b535-0ecc44c75e12\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"My profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70,"id":"51c0c70f-dfcc-4520-b535-0ecc44c75e12"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"My
            profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70,"id":"51c0c70f-dfcc-4520-b535-0ecc44c75e12"}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"My profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70,"id":"51c0c70f-dfcc-4520-b535-0ecc44c75e12"}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "My profile",
              "manufacturer": "Tesla",
              "model": "Model-3",
              "color": "red",
              "capacity": 12000,
              "averageConsumption": 30000,
              "phasesCount": 1,
              "minChargePower": 8000,
              "userSoc": 50,
              "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              "minChargePowerPerPhase": 2070,
              "minRequestedSoc": 70,
              "id": "51c0c70f-dfcc-4520-b535-0ecc44c75e12"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/ev-profiles/{evProfileID}':
    get:
      summary: Retrieve an EV profile
      description: Retrieve an EV profile that belong the the specified system.
      tags:
        - EV Profile
      security:
        - BearerAuth:
            - EVProfilesRead
      parameters:
        - *ref_74
        - &ref_128
          name: evProfileID
          description: Unique identifier for an EV profile.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: d4498841-1404-46f6-8086-7cc8bbdf98d3
      responses:
        '200':
          description: EV profile.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_126
        '403': *ref_11
        '404': *ref_127
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update an EV profile
      description: Update an EV profile that belong the the specified system.
      tags:
        - EV Profile
      security:
        - BearerAuth:
            - EVProfilesWrite
      parameters:
        - *ref_74
        - *ref_128
      requestBody:
        description: EV profile to be updated.
        required: true
        content:
          application/json:
            schema: &ref_404
              allOf:
                - *ref_125
      responses:
        '200':
          description: Returned updated EV profile.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_126
        '403': *ref_11
        '404': *ref_127
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"My profile\\\",\\\"manufacturer\\\":\\\"Tesla\\\",\\\"model\\\":\\\"Model-3\\\",\\\"color\\\":\\\"red\\\",\\\"capacity\\\":12000,\\\"averageConsumption\\\":30000,\\\"phasesCount\\\":1,\\\"minChargePower\\\":8000,\\\"userSoc\\\":50,\\\"image\\\":\\\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\",\\\"minChargePowerPerPhase\\\":2070,\\\"minRequestedSoc\\\":70}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "My profile",
              "manufacturer": "Tesla",
              "model": "Model-3",
              "color": "red",
              "capacity": 12000,
              "averageConsumption": 30000,
              "phasesCount": 1,
              "minChargePower": 8000,
              "userSoc": 50,
              "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              "minChargePowerPerPhase": 2070,
              "minRequestedSoc": 70
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'My profile',
              manufacturer: 'Tesla',
              model: 'Model-3',
              color: 'red',
              capacity: 12000,
              averageConsumption: 30000,
              phasesCount: 1,
              minChargePower: 8000,
              userSoc: 50,
              image: 'data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
              minChargePowerPerPhase: 2070,
              minRequestedSoc: 70
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'My profile',
                manufacturer: 'Tesla',
                model: 'Model-3',
                color: 'red',
                capacity: 12000,
                averageConsumption: 30000,
                phasesCount: 1,
                minChargePower: 8000,
                userSoc: 50,
                image: 'data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
                minChargePowerPerPhase: 2070,
                minRequestedSoc: 70
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "My profile",
              "manufacturer": "Tesla",
              "model": "Model-3",
              "color": "red",
              "capacity": 12000,
              "averageConsumption": 30000,
              "phasesCount": 1,
              "minChargePower": 8000,
              "userSoc": 50,
              "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              "minChargePowerPerPhase": 2070,
              "minRequestedSoc": 70
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"My profile",
                                          @"manufacturer": @"Tesla",
                                          @"model": @"Model-3",
                                          @"color": @"red",
                                          @"capacity": @12000,
                                          @"averageConsumption": @30000,
                                          @"phasesCount": @1,
                                          @"minChargePower": @8000,
                                          @"userSoc": @50,
                                          @"image": @"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                                          @"minChargePowerPerPhase": @2070,
                                          @"minRequestedSoc": @70 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"My profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"My
            profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"My
            profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"


            payload = {
                "name": "My profile",
                "manufacturer": "Tesla",
                "model": "Model-3",
                "color": "red",
                "capacity": 12000,
                "averageConsumption": 30000,
                "phasesCount": 1,
                "minChargePower": 8000,
                "userSoc": 50,
                "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                "minChargePowerPerPhase": 2070,
                "minRequestedSoc": 70
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"My
            profile\",\"manufacturer\":\"Tesla\",\"model\":\"Model-3\",\"color\":\"red\",\"capacity\":12000,\"averageConsumption\":30000,\"phasesCount\":1,\"minChargePower\":8000,\"userSoc\":50,\"image\":\"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\",\"minChargePowerPerPhase\":2070,\"minRequestedSoc\":70}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"My profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"My
            profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70}'
            |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"My profile","manufacturer":"Tesla","model":"Model-3","color":"red","capacity":12000,"averageConsumption":30000,"phasesCount":1,"minChargePower":8000,"userSoc":50,"image":"data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==","minChargePowerPerPhase":2070,"minRequestedSoc":70}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "My profile",
              "manufacturer": "Tesla",
              "model": "Model-3",
              "color": "red",
              "capacity": 12000,
              "averageConsumption": 30000,
              "phasesCount": 1,
              "minChargePower": 8000,
              "userSoc": 50,
              "image": "data:image/jpeg;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              "minChargePowerPerPhase": 2070,
              "minRequestedSoc": 70
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete an EV profile
      description: Deletes an EV profile that belongs to the specified system.
      tags:
        - EV Profile
      security:
        - BearerAuth:
            - EVProfilesWrite
      parameters:
        - *ref_74
        - *ref_128
      responses:
        '204':
          description: EV profile deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/ev-profiles/%7BevProfileID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/evcharging-schedules':
    get:
      summary: List a System's EV charging schedules.
      description: >
        Lists EV charging schedules that belong to the specified system.


        It only contains the currently active schedules and schedules to be
        active in the

        next 24 hours.
      tags:
        - EV Charging Schedule
      security:
        - BearerAuth:
            - SchedulesRead
      parameters:
        - *ref_74
      responses:
        '200':
          description: Returned currently active and upcoming EV charging schedules.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items:
                  allOf:
                    - *ref_129
        '403': *ref_11
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/evcharging-schedules",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/evcharging-schedules",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create an EV charging schedule
      description: Creates a system's EV charging schedule.
      tags:
        - EV Charging Schedule
      security:
        - BearerAuth:
            - SchedulesWrite
      parameters:
        - *ref_74
      requestBody:
        description: EV charging schedule to be created.
        required: true
        content:
          application/json:
            schema: &ref_406
              allOf:
                - &ref_405
                  type: object
                  allOf:
                    - *ref_130
                    - required:
                        - from
                        - to
                        - limit
                - additionalProperties: false
      responses:
        '201':
          description: Created EV charging schedule.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_129
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules\"\n\n\tpayload := strings.NewReader(\"{\\\"from\\\":\\\"2021-11-04T00:00:00Z\\\",\\\"to\\\":\\\"2021-11-04T00:30:00Z\\\",\\\"limit\\\":75000}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "from": "2021-11-04T00:00:00Z",
              "to": "2021-11-04T00:30:00Z",
              "limit": 75000
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/evcharging-schedules",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({from: '2021-11-04T00:00:00Z', to:
            '2021-11-04T00:30:00Z', limit: 75000}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {from: '2021-11-04T00:00:00Z', to: '2021-11-04T00:30:00Z', limit: 75000},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "from": "2021-11-04T00:00:00Z",
              "to": "2021-11-04T00:30:00Z",
              "limit": 75000
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"from": @"2021-11-04T00:00:00Z",
                                          @"to": @"2021-11-04T00:30:00Z",
                                          @"limit": @75000 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems/%7BsystemID%7D/evcharging-schedules",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules"


            payload = {
                "from": "2021-11-04T00:00:00Z",
                "to": "2021-11-04T00:30:00Z",
                "limit": 75000
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "from": "2021-11-04T00:00:00Z",
              "to": "2021-11-04T00:30:00Z",
              "limit": 75000
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/evcharging-schedules/{scheduleID}':
    get:
      summary: Retrieve an EV charging schedule
      description: Retrieves the details of an existing EV charging station schedule.
      tags:
        - EV Charging Schedule
      security:
        - BearerAuth:
            - SchedulesRead
      parameters:
        - *ref_74
        - &ref_131
          name: scheduleID
          description: |
            Unique identifier for a schedule.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: ec4d0c89-a604-49ac-82f0-427f9cb42204
      responses:
        '200':
          description: Returned EV charging schedule
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_129
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update an EV charging schedule
      description: >-
        Updates the specified systems EV charging schedule by setting the body
        parameters.
      tags:
        - EV Charging Schedule
      security:
        - BearerAuth:
            - SchedulesWrite
      parameters:
        - *ref_74
        - *ref_131
      requestBody:
        description: Modified EV charging schedule.
        required: true
        content:
          application/json:
            schema: &ref_408
              allOf:
                - &ref_407
                  type: object
                  allOf:
                    - *ref_130
      responses:
        '200':
          description: Updated EV charging schedule.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_129
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"from\\\":\\\"2021-11-04T00:00:00Z\\\",\\\"to\\\":\\\"2021-11-04T00:30:00Z\\\",\\\"limit\\\":75000}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "from": "2021-11-04T00:00:00Z",
              "to": "2021-11-04T00:30:00Z",
              "limit": 75000
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({from: '2021-11-04T00:00:00Z', to:
            '2021-11-04T00:30:00Z', limit: 75000}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {from: '2021-11-04T00:00:00Z', to: '2021-11-04T00:30:00Z', limit: 75000},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "from": "2021-11-04T00:00:00Z",
              "to": "2021-11-04T00:30:00Z",
              "limit": 75000
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"from": @"2021-11-04T00:00:00Z",
                                          @"to": @"2021-11-04T00:30:00Z",
                                          @"limit": @75000 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"


            payload = {
                "from": "2021-11-04T00:00:00Z",
                "to": "2021-11-04T00:30:00Z",
                "limit": 75000
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"from\":\"2021-11-04T00:00:00Z\",\"to\":\"2021-11-04T00:30:00Z\",\"limit\":75000}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}'
            |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"from":"2021-11-04T00:00:00Z","to":"2021-11-04T00:30:00Z","limit":75000}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "from": "2021-11-04T00:00:00Z",
              "to": "2021-11-04T00:30:00Z",
              "limit": 75000
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete an EV charging schedule
      description: Deletes an EV charging schedule.
      tags:
        - EV Charging Schedule
      security:
        - BearerAuth:
            - SchedulesWrite
      parameters:
        - *ref_74
        - *ref_131
      responses:
        '204':
          description: EV charging schedule has been deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/evcharging-schedules/%7BscheduleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/power-limit-schedules':
    get:
      summary: List a Systems power limit schedules.
      description: |
        List all power limit schedules of the system.
      tags:
        - Power Limit Schedule
      parameters:
        - *ref_74
        - *ref_18
        - *ref_17
      responses:
        '200':
          description: Power limit schedules ordered by `from` and `to` in ascending order.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_133
                  allOf:
                    - &ref_132
                      title: Power Limit Schedule
                      description: >
                        A Power Limit Schedule is a schedule that defines
                        recurring import power limits, 

                        which should be applied to the grid meter.


                        The schedule is recurring inside the interval bounds
                        defined by `from` and `to`.


                        There can be only one active timeframe for every point
                        in time.

                        Schedules can overlap, but they must not have
                        overlapping timeframes. 
                      type: object
                      properties:
                        title:
                          type: string
                          description: >-
                            Name of this schedule. Must be unique for this
                            system.
                        from:
                          type: string
                          format: date-time
                          description: From when the schedule applies (inclusive).
                        to:
                          type: string
                          format: date-time
                          description: Until when the schedule applies (exclusive).
                        timezone:
                          type: string
                          description: >
                            Fully qualified identifier of the timezone ([IANA
                            timezone database
                            identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones))
                            this schedule should be applied in.

                            Used to determine time of day of the timeframes.
                        timeframes:
                          description: >
                            List of timeframes containing which import limit
                            should be applied at which time of the day.


                            They must not overlap in this schedule and also not
                            with timeframes of other schedules of this system.
                          type: array
                          items:
                            type: object
                            required:
                              - from
                              - to
                              - maxPower
                            properties:
                              from:
                                description: >
                                  Time of day from when the limit of this
                                  timeframe should be applied (inclusive).
                                type: string
                                example: '00:00'
                              to:
                                description: >
                                  Time of day until when the limit of this
                                  timeframe should be applied (exclusive).
                                type: string
                                example: '14:00'
                              maxPower:
                                description: >-
                                  Max import power in Watt to apply to the grid
                                  meter during this timeframe.
                                type: integer
                                format: int64
                                minimum: 0
                                example: 100000
                        recurrence:
                          type: object
                          description: >
                            Recurrence rules for this schedule.


                            Inspired by
                            [RFC5545](https://www.rfc-editor.org/rfc/rfc5545#section-3.3.10)
                            and supporting a small subset of it.
                          required:
                            - frequency
                          properties:
                            frequency:
                              description: Type of recurrence rule.
                              type: string
                              enum:
                                - DAILY
                            byDayOfWeek:
                              description: >
                                Specifies a list of weekdays this rule should
                                apply to.

                                Only valid for `frequency=DAILY`.


                                Omitting it is the same as selecting all days.
                              type: array
                              items:
                                type: string
                                enum:
                                  - SU
                                  - MO
                                  - TU
                                  - WE
                                  - TH
                                  - FR
                                  - SA
                    - required:
                        - id
                        - title
                        - from
                        - to
                        - timezone
                        - timeframes
                        - recurrence
                        - status
                        - createdAt
                        - updatedAt
                      properties:
                        id:
                          type: string
                          format: uuid
                          description: Unique ID of this schedule.
                        timeframes:
                          minItems: 1
                        status:
                          description: >
                            Status of the schedule.


                            - `ACTIVE`: A timeframe of this schedule is
                            currently being applied.

                            - `OUTDATED`: No more timeframes from this schedule
                            will be applied.

                            - `UPCOMING`: A timeframe of this schedule will be
                            applied in the future.
                          type: string
                          enum:
                            - ACTIVE
                            - OUTDATED
                            - UPCOMING
                        createdAt:
                          description: When the Power Limit Schedule was created.
                          type: string
                          format: date-time
                        updatedAt:
                          description: When the Power Limit Schedule was last updated.
                          type: string
                          format: date-time
        '400': *ref_3
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE");

            var request = new RestRequest(Method.GET);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")
              .get()
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              "headers": {}
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules',
              qs: {page: 'SOME_INTEGER_VALUE', per_page: 'SOME_INTEGER_VALUE'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules");


            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE"
            in


            Client.call `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE'
            ]));


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            conn.request("GET",
            "/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE"}


            response = requests.request("GET", url, params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a power limit schedule
      description: Creates a power limit schedule for this system.
      tags:
        - Power Limit Schedule
      parameters:
        - *ref_74
      requestBody:
        description: Power limit schedule to be created.
        required: true
        content:
          application/json:
            schema: &ref_410
              allOf:
                - &ref_409
                  allOf:
                    - *ref_132
                    - required:
                        - title
                        - from
                        - to
                        - timeframes
                        - recurrence
                      properties:
                        timezone:
                          default: Europe/Berlin
                        timeframes:
                          minItems: 1
                - additionalProperties: false
            examples:
              dailyRepetition: &ref_482
                summary: Daily repeating
                value:
                  title: Daily repeating
                  from: '2024-01-01T00:00:00+02:00'
                  to: '2025-01-01T00:00:00+02:00'
                  timeframes:
                    - from: '00:00'
                      to: '18:00'
                      maxPower: 100000
                    - from: '18:00'
                      to: '00:00'
                      maxPower: 150000
                  recurrence:
                    frequency: DAILY
              weekends: &ref_483
                summary: Weekends
                value:
                  title: Weekends
                  from: '2024-01-01T00:00:00+02:00'
                  to: '2025-01-01T00:00:00+02:00'
                  timeframes:
                    - from: '00:00'
                      to: '00:00'
                      maxPower: 100000
                  recurrence:
                    frequency: DAILY
                    byDayOfWeek:
                      - SA
                      - SU
      responses:
        '201':
          description: Created power limit schedule.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_133
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddParameter("application/json",
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules\"\n\n\tpayload := strings.NewReader(\"{\\\"title\\\":\\\"string\\\",\\\"from\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"to\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"timezone\\\":\\\"Europe/Berlin\\\",\\\"timeframes\\\":[{\\\"from\\\":\\\"00:00\\\",\\\"to\\\":\\\"14:00\\\",\\\"maxPower\\\":100000}],\\\"recurrence\\\":{\\\"frequency\\\":\\\"DAILY\\\",\\\"byDayOfWeek\\\":[\\\"SU\\\"]}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules")
              .post(body)
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules")
              .header("content-type", "application/json")
              .body("{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules",
              "method": "POST",
              "headers": {
                "content-type": "application/json"
              },
              "processData": false,
              "data": "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "title": "string",
              "from": "2019-08-24T14:15:22Z",
              "to": "2019-08-24T14:15:22Z",
              "timezone": "Europe/Berlin",
              "timeframes": [
                {
                  "from": "00:00",
                  "to": "14:00",
                  "maxPower": 100000
                }
              ],
              "recurrence": {
                "frequency": "DAILY",
                "byDayOfWeek": [
                  "SU"
                ]
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules");

            xhr.setRequestHeader("content-type", "application/json");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules",
              "method": "POST",
              "headers": {
                "content-type": "application/json"
              },
              "processData": false,
              "data": "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/power-limit-schedules",
              "headers": {
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              title: 'string',
              from: '2019-08-24T14:15:22Z',
              to: '2019-08-24T14:15:22Z',
              timezone: 'Europe/Berlin',
              timeframes: [{from: '00:00', to: '14:00', maxPower: 100000}],
              recurrence: {frequency: 'DAILY', byDayOfWeek: ['SU']}
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules',
              headers: {'content-type': 'application/json'},
              body: {
                title: 'string',
                from: '2019-08-24T14:15:22Z',
                to: '2019-08-24T14:15:22Z',
                timezone: 'Europe/Berlin',
                timeframes: [{from: '00:00', to: '14:00', maxPower: 100000}],
                recurrence: {frequency: 'DAILY', byDayOfWeek: ['SU']}
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules");


            req.headers({
              "content-type": "application/json"
            });


            req.type("json");

            req.send({
              "title": "string",
              "from": "2019-08-24T14:15:22Z",
              "to": "2019-08-24T14:15:22Z",
              "timezone": "Europe/Berlin",
              "timeframes": [
                {
                  "from": "00:00",
                  "to": "14:00",
                  "maxPower": 100000
                }
              ],
              "recurrence": {
                "frequency": "DAILY",
                "byDayOfWeek": [
                  "SU"
                ]
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json" };

            NSDictionary *parameters = @{ @"title": @"string",
                                          @"from": @"2019-08-24T14:15:22Z",
                                          @"to": @"2019-08-24T14:15:22Z",
                                          @"timezone": @"Europe/Berlin",
                                          @"timeframes": @[ @{ @"from": @"00:00", @"to": @"14:00", @"maxPower": @100000 } ],
                                          @"recurrence": @{ @"frequency": @"DAILY", @"byDayOfWeek": @[ @"SU" ] } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules"
            in

            let headers = Header.add (Header.init ()) "content-type"
            "application/json" in

            let body = Cohttp_lwt_body.of_string
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}",
              CURLOPT_HTTPHEADER => [
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json'
            ]);


            $request->setBody('{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"Europe/Berlin","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"Europe/Berlin","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"


            headers = { 'content-type': "application/json" }


            conn.request("POST",
            "/systems/%7BsystemID%7D/power-limit-schedules", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules"


            payload = {
                "title": "string",
                "from": "2019-08-24T14:15:22Z",
                "to": "2019-08-24T14:15:22Z",
                "timezone": "Europe/Berlin",
                "timeframes": [
                    {
                        "from": "00:00",
                        "to": "14:00",
                        "maxPower": 100000
                    }
                ],
                "recurrence": {
                    "frequency": "DAILY",
                    "byDayOfWeek": ["SU"]
                }
            }

            headers = {"content-type": "application/json"}


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request.body =
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"Europe/Berlin\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules \
              --header 'content-type: application/json' \
              --data '{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"Europe/Berlin","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"Europe/Berlin","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --body-data '{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"Europe/Berlin","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["content-type": "application/json"]

            let parameters = [
              "title": "string",
              "from": "2019-08-24T14:15:22Z",
              "to": "2019-08-24T14:15:22Z",
              "timezone": "Europe/Berlin",
              "timeframes": [
                [
                  "from": "00:00",
                  "to": "14:00",
                  "maxPower": 100000
                ]
              ],
              "recurrence": [
                "frequency": "DAILY",
                "byDayOfWeek": ["SU"]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/power-limit-schedules/{scheduleID}':
    get:
      summary: Retrieve a power limit schedule
      description: Retrieves the details of an existing power limit schedule.
      tags:
        - Power Limit Schedule
      parameters:
        - *ref_74
        - *ref_131
      responses:
        '200':
          description: Returned power limit schedule.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_133
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");

            var request = new RestRequest(Method.GET);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")
              .get()
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "headers": {}
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D'
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"
            in


            Client.call `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D');

            $request->setMethod(HTTP_METH_GET);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D');

            $request->setRequestMethod('GET');

            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            conn.request("GET",
            "/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"


            response = requests.request("GET", url)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update a power limit schedule
      description: Updates the specified power limit schedule.
      tags:
        - Power Limit Schedule
      parameters:
        - *ref_74
        - *ref_131
      requestBody:
        description: Partially modified power limit schedule.
        required: true
        content:
          application/json:
            schema: &ref_412
              allOf:
                - &ref_411
                  allOf:
                    - *ref_132
                - additionalProperties: false
      responses:
        '200':
          description: Updated power limit schedule.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_133
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddParameter("application/json",
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"title\\\":\\\"string\\\",\\\"from\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"to\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"timezone\\\":\\\"string\\\",\\\"timeframes\\\":[{\\\"from\\\":\\\"00:00\\\",\\\"to\\\":\\\"14:00\\\",\\\"maxPower\\\":100000}],\\\"recurrence\\\":{\\\"frequency\\\":\\\"DAILY\\\",\\\"byDayOfWeek\\\":[\\\"SU\\\"]}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")
              .header("content-type", "application/json")
              .body("{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json"
              },
              "processData": false,
              "data": "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "title": "string",
              "from": "2019-08-24T14:15:22Z",
              "to": "2019-08-24T14:15:22Z",
              "timezone": "string",
              "timeframes": [
                {
                  "from": "00:00",
                  "to": "14:00",
                  "maxPower": 100000
                }
              ],
              "recurrence": {
                "frequency": "DAILY",
                "byDayOfWeek": [
                  "SU"
                ]
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");

            xhr.setRequestHeader("content-type", "application/json");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json"
              },
              "processData": false,
              "data": "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "headers": {
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              title: 'string',
              from: '2019-08-24T14:15:22Z',
              to: '2019-08-24T14:15:22Z',
              timezone: 'string',
              timeframes: [{from: '00:00', to: '14:00', maxPower: 100000}],
              recurrence: {frequency: 'DAILY', byDayOfWeek: ['SU']}
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D',
              headers: {'content-type': 'application/json'},
              body: {
                title: 'string',
                from: '2019-08-24T14:15:22Z',
                to: '2019-08-24T14:15:22Z',
                timezone: 'string',
                timeframes: [{from: '00:00', to: '14:00', maxPower: 100000}],
                recurrence: {frequency: 'DAILY', byDayOfWeek: ['SU']}
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            req.headers({
              "content-type": "application/json"
            });


            req.type("json");

            req.send({
              "title": "string",
              "from": "2019-08-24T14:15:22Z",
              "to": "2019-08-24T14:15:22Z",
              "timezone": "string",
              "timeframes": [
                {
                  "from": "00:00",
                  "to": "14:00",
                  "maxPower": 100000
                }
              ],
              "recurrence": {
                "frequency": "DAILY",
                "byDayOfWeek": [
                  "SU"
                ]
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json" };

            NSDictionary *parameters = @{ @"title": @"string",
                                          @"from": @"2019-08-24T14:15:22Z",
                                          @"to": @"2019-08-24T14:15:22Z",
                                          @"timezone": @"string",
                                          @"timeframes": @[ @{ @"from": @"00:00", @"to": @"14:00", @"maxPower": @100000 } ],
                                          @"recurrence": @{ @"frequency": @"DAILY", @"byDayOfWeek": @[ @"SU" ] } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"
            in

            let headers = Header.add (Header.init ()) "content-type"
            "application/json" in

            let body = Cohttp_lwt_body.of_string
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}",
              CURLOPT_HTTPHEADER => [
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json'
            ]);


            $request->setBody('{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"string","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"string","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"


            headers = { 'content-type': "application/json" }


            conn.request("PATCH",
            "/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"


            payload = {
                "title": "string",
                "from": "2019-08-24T14:15:22Z",
                "to": "2019-08-24T14:15:22Z",
                "timezone": "string",
                "timeframes": [
                    {
                        "from": "00:00",
                        "to": "14:00",
                        "maxPower": 100000
                    }
                ],
                "recurrence": {
                    "frequency": "DAILY",
                    "byDayOfWeek": ["SU"]
                }
            }

            headers = {"content-type": "application/json"}


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request.body =
            "{\"title\":\"string\",\"from\":\"2019-08-24T14:15:22Z\",\"to\":\"2019-08-24T14:15:22Z\",\"timezone\":\"string\",\"timeframes\":[{\"from\":\"00:00\",\"to\":\"14:00\",\"maxPower\":100000}],\"recurrence\":{\"frequency\":\"DAILY\",\"byDayOfWeek\":[\"SU\"]}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D \
              --header 'content-type: application/json' \
              --data '{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"string","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"string","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}'
            |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --body-data '{"title":"string","from":"2019-08-24T14:15:22Z","to":"2019-08-24T14:15:22Z","timezone":"string","timeframes":[{"from":"00:00","to":"14:00","maxPower":100000}],"recurrence":{"frequency":"DAILY","byDayOfWeek":["SU"]}}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["content-type": "application/json"]

            let parameters = [
              "title": "string",
              "from": "2019-08-24T14:15:22Z",
              "to": "2019-08-24T14:15:22Z",
              "timezone": "string",
              "timeframes": [
                [
                  "from": "00:00",
                  "to": "14:00",
                  "maxPower": 100000
                ]
              ],
              "recurrence": [
                "frequency": "DAILY",
                "byDayOfWeek": ["SU"]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete a power limit schedule
      description: Deletes a power limit schedule.
      tags:
        - Power Limit Schedule
      parameters:
        - *ref_74
        - *ref_131
      responses:
        '204':
          description: Power limit schedule has been deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");

            var request = new RestRequest(Method.DELETE);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")
              .delete(null)
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "method": "DELETE",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "method": "DELETE",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              "headers": {}
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D'
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D");


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"
            in


            Client.call `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D');

            $request->setRequestMethod('DELETE');

            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            conn.request("DELETE",
            "/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D"


            response = requests.request("DELETE", url)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules/%7BscheduleID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/power-limit-schedules-intervals':
    get:
      summary: List applied power limits intervals
      description: >
        Returns a list of scheduled power limit intervals.


        Intervals in the past are fixed and will never change. 

        Intervals in the future can change if the underlying schedule is
        changed.
      tags:
        - Power Limit Schedule
      parameters:
        - *ref_74
        - *ref_119
      responses:
        '200':
          description: Applied power limits intervals.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_413
                description: >
                  Ascending ordered list of intervals in which a scheduled power
                  limit was applied.
                type: object
                required:
                  - from
                  - to
                  - intervals
                properties:
                  from:
                    description: >
                      From when the first interval of this object applied
                      (inclusive).

                      Equal to requested `interval` start, if there are no
                      intervals.
                    type: string
                    format: date-time
                  to:
                    description: >
                      Until when the last interval of this object applied
                      (exclusive).

                      Equal to requested `interval` start, if there are no
                      intervals.
                    type: string
                    format: date-time
                  intervals:
                    type: array
                    items:
                      type: object
                      required:
                        - from
                        - to
                        - maxPower
                      properties:
                        from:
                          description: From when the interval applied (inclusive).
                          type: string
                          format: date-time
                        to:
                          description: Until when the interval applied (exclusive).
                          type: string
                          format: date-time
                        maxPower:
                          description: >-
                            Max import power in Watt applied during the
                            interval.
                          type: integer
                          minimum: 0
                          format: int64
        '400': *ref_3
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE")
              .get()
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {}
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE",
              "headers": {}
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals',
              qs: {interval: 'SOME_STRING_VALUE'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE"
            in


            Client.call `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            conn.request("GET",
            "/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE")


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals"


            querystring = {"interval":"SOME_STRING_VALUE"}


            response = requests.request("GET", url, params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/power-limit-schedules-intervals?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/capacity-tariff':
    get:
      summary: Get the capacity tariff information.
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffRead
      parameters:
        - *ref_74
      responses:
        '200': &ref_134
          description: Capacity tariff returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_136
                title: Capacity Tariff
                description: >-
                  Represents the set tariff information for a defined power
                  import peak limit.
                type: object
                required:
                  - userLimit
                  - userLimitEnabled
                  - price
                  - effectiveLimit
                properties:
                  userLimit:
                    type: number
                    description: Limit set by the user in W.
                  userLimitEnabled:
                    type: boolean
                    description: >-
                      Enables or disables the limit set by the user. Fallback is
                      the suggested limit. Default is disabled.
                  userLimitUpdatedAt:
                    type: string
                    format: date-time
                    readOnly: true
                  price:
                    type: number
                    description: >-
                      Price for the given capacity tariff (set by the user) in
                      €/kW.
                  recommendedLimit:
                    type: number
                    description: >
                      Limit set by the energy provider as a suggestion for the
                      user in W.

                      If the limit is deleted, it's not part of the capacity
                      tariff response.
                    readOnly: true
                  recommendedLimitUpdatedAt:
                    type: string
                    format: date-time
                    readOnly: true
                  peakPower:
                    type: number
                    description: >
                      Maximum peak power. If it exceeds both the user and the
                      recommended limit it is set as `effectiveLimit`.

                      If the value is deleted, it's not part of the capacity
                      tariff response.
                    readOnly: true
                  peakPowerUpdatedAt:
                    type: string
                    format: date-time
                    readOnly: true
                  effectiveLimit:
                    type: number
                    description: >-
                      Defines which limit is used by the energy management
                      system (either user or recommended).
                    readOnly: true
                  enabled:
                    type: boolean
                    description: >
                      Enables or disables the capacity tariff.

                      If enabled, energy management system uses the
                      `effectiveLimit` as an upper bound on a 15 minute average
                      base.
                    default: true
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/capacity-tariff",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: 'Create the user limit, price and enable or disable the limit.'
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffWrite
      parameters:
        - *ref_74
      requestBody: &ref_135
        description: 'Set user capacity limit, price and enable or disable the limit.'
        required: true
        content:
          application/json:
            schema: &ref_361
              allOf:
                - &ref_360
                  title: User Limit Request Body
                  description: 'Set the user limit, price and enable or disable the limit.'
                  type: object
                  properties:
                    userLimit:
                      type: number
                      description: Limit set by the user in W.
                    userLimitEnabled:
                      type: boolean
                      description: >-
                        Enables or disables the limit set by the user. Fallback
                        is the suggested limit.
                    price:
                      type: number
                      description: >-
                        Price for the given capacity tariff (set by the user) in
                        €/kW.
                    enabled:
                      type: boolean
                      description: >
                        Enables or disables the capacity tariff.

                        If enabled, energy management system uses the
                        `effectiveLimit` as an upper bound on a 15 minute
                        average base.
                      example: true
                - additionalProperties: false
      responses:
        '201': *ref_134
        '400': *ref_3
        '403': *ref_11
        '404': *ref_55
        '409': &ref_143
          description: Resource already exists
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_414
                readOnly: true
                allOf:
                  - *ref_0
                  - title: ClientError - Conflict
                    description: >
                      Conflict indicates that the client is attempting to create
                      a resource that already exists.
                    type: object
                    example:
                      message: Resource already exists
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff\"\n\n\tpayload := strings.NewReader(\"{\\\"userLimit\\\":0,\\\"userLimitEnabled\\\":true,\\\"price\\\":0,\\\"enabled\\\":true}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "userLimit": 0,
              "userLimitEnabled": true,
              "price": 0,
              "enabled": true
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({userLimit: 0, userLimitEnabled: true,
            price: 0, enabled: true}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {userLimit: 0, userLimitEnabled: true, price: 0, enabled: true},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "userLimit": 0,
              "userLimitEnabled": true,
              "price": 0,
              "enabled": true
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"userLimit": @0,
                                          @"userLimitEnabled": @YES,
                                          @"price": @0,
                                          @"enabled": @YES };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems/%7BsystemID%7D/capacity-tariff",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"


            payload = {
                "userLimit": 0,
                "userLimitEnabled": True,
                "price": 0,
                "enabled": True
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "userLimit": 0,
              "userLimitEnabled": true,
              "price": 0,
              "enabled": true
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: 'Update the user limit, price and enable or disable the limit.'
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffWrite
      parameters:
        - *ref_74
      requestBody: *ref_135
      responses:
        '200': *ref_134
        '400': *ref_3
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff\"\n\n\tpayload := strings.NewReader(\"{\\\"userLimit\\\":0,\\\"userLimitEnabled\\\":true,\\\"price\\\":0,\\\"enabled\\\":true}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "userLimit": 0,
              "userLimitEnabled": true,
              "price": 0,
              "enabled": true
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({userLimit: 0, userLimitEnabled: true,
            price: 0, enabled: true}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {userLimit: 0, userLimitEnabled: true, price: 0, enabled: true},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "userLimit": 0,
              "userLimitEnabled": true,
              "price": 0,
              "enabled": true
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"userLimit": @0,
                                          @"userLimitEnabled": @YES,
                                          @"price": @0,
                                          @"enabled": @YES };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/systems/%7BsystemID%7D/capacity-tariff",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"


            payload = {
                "userLimit": 0,
                "userLimitEnabled": True,
                "price": 0,
                "enabled": True
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"userLimit\":0,\"userLimitEnabled\":true,\"price\":0,\"enabled\":true}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}'
            |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"userLimit":0,"userLimitEnabled":true,"price":0,"enabled":true}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "userLimit": 0,
              "userLimitEnabled": true,
              "price": 0,
              "enabled": true
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Deletes the Capacity Tariff.
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffWrite
      parameters:
        - *ref_74
      responses:
        '204':
          description: Capacity Tariff has been deleted successfully.
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE", "/systems/%7BsystemID%7D/capacity-tariff",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/capacity-tariff/recommendation':
    post:
      summary: Create the recommended capacity tariff limit.
      description: >-
        When updating the recommended limit it is effectively if the userLimit
        is disabled.
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffRecommendationWrite
      parameters:
        - *ref_74
      requestBody: &ref_207
        description: Set recommended capacity limit.
        required: true
        content:
          application/json:
            schema: &ref_363
              allOf:
                - &ref_362
                  title: Recommended Limit Request Body
                  description: Sets the suggested limit.
                  type: object
                  properties:
                    value:
                      type: number
                      description: >-
                        Limit set by the energy provider as a suggestion for the
                        user in W.
                - additionalProperties: false
      responses:
        '201': *ref_134
        '400': *ref_3
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"value\":0}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"value\":0}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation\"\n\n\tpayload := strings.NewReader(\"{\\\"value\\\":0}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"value\":0}");
            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"value\":0}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "value": 0
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({value: 0}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {value: 0},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "value": 0
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"value": @0 };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"value\":0}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"value\":0}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"value":0}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"value":0}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"value\":0}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/systems/%7BsystemID%7D/capacity-tariff/recommendation", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation"


            payload = {"value": 0}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"value\":0}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"value":0}'
        - lang: Shell + Httpie
          source: |-
            echo '{"value":0}' |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"value":0}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["value": 0] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete capacity tariff recommendation
      description: Removes the recommended value from the capacity tariff.
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffRecommendationWrite
      parameters:
        - *ref_74
      responses:
        '200': &ref_255
          description: Recommended value deleted successfully.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_136
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/systems/%7BsystemID%7D/capacity-tariff/recommendation",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/recommendation")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/capacity-tariff/peak-power':
    post:
      summary: Set the capacity tariff peak-power.
      description: >-
        When setting the peak-power it becomes the new `effectiveLimit` if it is
        higher than the user and recommended limit.
      tags:
        - Capacity Tariff
      security:
        - BearerAuth:
            - CapacityTariffPeakPowerWrite
      parameters:
        - *ref_74
      requestBody: &ref_208
        description: Set detected peak power.
        required: true
        content:
          application/json:
            schema: &ref_365
              allOf:
                - &ref_364
                  title: Peak Power
                  description: Sets the peak power.
                  type: object
                  properties:
                    value:
                      type: number
                      description: Peak power set by the EMS in W.
                - additionalProperties: false
      responses:
        '201': *ref_134
        '400': *ref_3
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"value\":0}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"value\":0}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power\"\n\n\tpayload := strings.NewReader(\"{\\\"value\\\":0}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"value\":0}");
            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"value\":0}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "value": 0
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"value\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({value: 0}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {value: 0},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "value": 0
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"value": @0 };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"value\":0}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"value\":0}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"value":0}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"value":0}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"value\":0}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/systems/%7BsystemID%7D/capacity-tariff/peak-power", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power"


            payload = {"value": 0}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"value\":0}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"value":0}'
        - lang: Shell + Httpie
          source: |-
            echo '{"value":0}' |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"value":0}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["value": 0] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete capacity tariff peak-power
      description: >-
        After deleting the peak-power limit, the new `effectiveLimit` would be
        the user's (if enabled) or the recommended limit.
      tags:
        - Capacity Tariff
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200': &ref_256
          description: Peak-power deleted successfully.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_136
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/systems/%7BsystemID%7D/capacity-tariff/peak-power",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/capacity-tariff/peak-power")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/savings/{saving}':
    get:
      summary: Retrieve saving of a system
      description: >
        Retrieves a specific saving of a system obtained through various
        optimizations.


        Which savings are available for a system is specified in the systems
        metadata. Requesting unavailable savings will always return a value of
        0.


        The saving is **cached** and can be refreshed by specifying the
        corresponding URL parameter.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemsRead
      parameters:
        - *ref_74
        - &ref_185
          name: saving
          in: path
          required: true
          description: Kind of saving.
          example: CAPACITY_TARIFF_OPTIMIZATION
          schema: *ref_137
        - name: refresh
          description: >
            If specified the saving will be calculated and the cached value
            updated instead of just returning cached value.

            Be aware that calculating savings can take some time.
          in: query
          schema:
            type: boolean
            default: false
          required: false
          example: false
      responses:
        '200':
          description: Saving of specified type for the system.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_416
                description: Saving due to various optimizations.
                type: object
                allOf:
                  - &ref_415
                    description: Represents monetary value in a specific currency.
                    type: object
                    properties:
                      value:
                        type: number
                        example: 138.43
                      currency:
                        type: string
                        description: Currency code (ISO 4217)
                        example: EUR
                  - properties:
                      updatedAt:
                        description: >-
                          The datetime when the saving was calculated the last
                          time.
                        type: string
                        example: '2023-05-12T23:20:50Z'
                        format: date-time
                    required:
                      - value
                      - currency
                      - updatedAt
        '400': *ref_3
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D',
              qs: {refresh: 'SOME_BOOLEAN_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D");


            req.query({
              "refresh": "SOME_BOOLEAN_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'refresh' => 'SOME_BOOLEAN_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'refresh' => 'SOME_BOOLEAN_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D"


            querystring = {"refresh":"SOME_BOOLEAN_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/savings/%7Bsaving%7D?refresh=SOME_BOOLEAN_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/tariff':
    get:
      summary: Retrieve the tariff v2 of a system
      description: |
        Retrieves the tariff v2 of the system. 
      tags:
        - TariffV2
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200':
          description: Tariff of the system. Empty if there is none.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_142
                type: object
                allOf:
                  - &ref_140
                    title: Energy TariffV2
                    type: object
                    description: >
                      Represents an energy tariff.

                      The tariff contains settings which specify where to take
                      prices from and how the end prices will be calculated.


                      If `feedinType` or `offtakeType` is `MARKET_DATA`,
                      `marketDataSettings` is required.

                      If `feedinType` or `offtakeType` is `STATIC`
                      `staticPeriods` is required.


                      For **external tariffs**, `feedinType` and `offtakeType`
                      **both** have to be set to `EXTERNAL`.

                      External tariffs are tariffs where the prices are sent
                      directly via API and not calculated.

                      The price periods are sent with the
                      `/systems/{systemID}/tariff/prices` endpoint.
                    properties:
                      name:
                        type: string
                        description: 'Name of the energy tariff, to be chosen freely.'
                        example: E.ON Strom
                        nullable: true
                      currency:
                        type: string
                        description: Currency code (ISO 4217).
                        example: EUR
                      feedinType:
                        type: string
                        description: Type of feed-in tariff.
                        example: STATIC
                        enum:
                          - MARKET_DATA
                          - STATIC
                          - EXTERNAL
                      offtakeType:
                        type: string
                        description: Type of off-take tariff.
                        example: MARKET_DATA
                        enum:
                          - MARKET_DATA
                          - STATIC
                          - EXTERNAL
                      staticPeriods:
                        description: >
                          Weekly recurring periods with static prices. Used for
                          example for completely static, day/night and weekend
                          tariffs.


                          Static periods have to form a closed loop. The loop
                          must cover the whole week:

                          A period has to end at the start of the next period.
                          The end of the last period has to be the start of the
                          first period.
                        type: array
                        items: &ref_417
                          title: TariffV2 Static period
                          description: >
                            Contains the tariff periods for a tariff with either
                            OfftakeType or FeedinType `STATIC`. 


                            The period is active between `from` and `to`. `from`
                            is included in the interval, `to` is excluded.
                          type: object
                          properties:
                            from: &ref_138
                              title: TariffV2 static period time
                              description: >-
                                Contains the information when a static period of
                                a TariffV2 starts or ends.

                                Described by the weekday and the seconds of this
                                day.
                              type: object
                              properties:
                                weekday:
                                  description: 'The weekdays index (Sunday=0, ...)'
                                  type: integer
                                  minimum: 0
                                  maximum: 6
                                  example: 0
                                secondsOfDay:
                                  description: >-
                                    The second of the weekday until the period
                                    is valid/which the period is valid from
                                  type: integer
                                  minimum: 0
                                  maximum: 86399
                                  example: 0
                              required:
                                - weekday
                                - secondsOfDay
                            to: *ref_138
                            feedinPrice:
                              description: >-
                                Price per kWh fed into the grid in the currency
                                of the tariff.
                              type: number
                              example: 0.09
                              default: 0
                            offtakePrice:
                              description: >-
                                Price per kWh consumed from the grid in the
                                currency of the tariff.
                              type: number
                              example: 0.4
                              default: 0
                          required:
                            - from
                            - to
                      marketDataSettings: &ref_139
                        title: Market Data Settings
                        type: object
                        description: Settings specific to market-data-based tariffs.
                        properties:
                          feedinOffset:
                            type: number
                            description: >-
                              Sets the fee per kWh on top of market prices for
                              feed-in tariffs.
                            example: 2.5
                          offtakeOffset:
                            type: number
                            description: >-
                              Sets the fee per kWh on top of market prices for
                              off-take tariffs.
                            example: 2.5
                          providerFee:
                            type: number
                            description: 'Additional fee per kWh on top, after applying VAT.'
                            example: 10
                          vat:
                            type: number
                            description: >-
                              The VAT is the value-added tax rate expressed as a
                              decimal number.
                            example: 0.12
                  - properties:
                      systemID:
                        type: string
                        description: ID of the system the tariff is assigned to
                        format: uuid
                        example: 3a07b17f-da57-4d61-b9e4-17c4fcd861c4
                        readOnly: true
                      createdAt:
                        type: string
                        description: >-
                          Time at which the tariff was created using the RFC3339
                          format.
                        example: '2021-10-10T23:20:50Z'
                        format: date-time
                        readOnly: true
                      updatedAt:
                        type: string
                        description: >-
                          Time at which the tariff was updated using the RFC3339
                          format.
                        example: '2021-10-10T23:20:50Z'
                        format: date-time
                        readOnly: true
                      currency:
                        default: EUR
                      marketDataSettings: &ref_141
                        allOf:
                          - *ref_139
                          - required:
                              - feedinOffset
                              - offtakeOffset
                              - providerFee
                              - vat
                    required:
                      - name
                      - feedinType
                      - offtakeType
                      - systemID
                      - createdAt
                      - updatedAt
                      - currency
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/tariff");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/tariff\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/tariff")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/tariff")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/tariff",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/tariff',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/tariff",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/tariff"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/tariff")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/systems/%7BsystemID%7D/tariff \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Set the tariff v2 of a system
      description: >
        Sets the tariff v2 of the system. 


        See the response bodies description which fields have to be set for
        which `feedinType`/`offtakeType`.
      tags:
        - TariffV2
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      requestBody:
        required: true
        content:
          application/json:
            schema: &ref_419
              allOf:
                - &ref_418
                  type: object
                  allOf:
                    - *ref_140
                    - type: object
                      properties:
                        marketDataSettings: *ref_141
                      required:
                        - feedinType
                        - offtakeType
                - additionalProperties: false
      responses:
        '201':
          description: The newly-set tariff v2.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_142
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '409': *ref_143
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/tariff");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/tariff\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"E.ON Strom\\\",\\\"currency\\\":\\\"EUR\\\",\\\"feedinType\\\":\\\"STATIC\\\",\\\"offtakeType\\\":\\\"MARKET_DATA\\\",\\\"staticPeriods\\\":[{\\\"from\\\":{\\\"weekday\\\":0,\\\"secondsOfDay\\\":0},\\\"to\\\":{\\\"weekday\\\":0,\\\"secondsOfDay\\\":0},\\\"feedinPrice\\\":0.09,\\\"offtakePrice\\\":0.4}],\\\"marketDataSettings\\\":{\\\"feedinOffset\\\":2.5,\\\"offtakeOffset\\\":2.5,\\\"providerFee\\\":10,\\\"vat\\\":0.12}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/tariff")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/tariff")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "E.ON Strom",
              "currency": "EUR",
              "feedinType": "STATIC",
              "offtakeType": "MARKET_DATA",
              "staticPeriods": [
                {
                  "from": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "to": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4
                }
              ],
              "marketDataSettings": {
                "feedinOffset": 2.5,
                "offtakeOffset": 2.5,
                "providerFee": 10,
                "vat": 0.12
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/tariff",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'E.ON Strom',
              currency: 'EUR',
              feedinType: 'STATIC',
              offtakeType: 'MARKET_DATA',
              staticPeriods: [
                {
                  from: {weekday: 0, secondsOfDay: 0},
                  to: {weekday: 0, secondsOfDay: 0},
                  feedinPrice: 0.09,
                  offtakePrice: 0.4
                }
              ],
              marketDataSettings: {feedinOffset: 2.5, offtakeOffset: 2.5, providerFee: 10, vat: 0.12}
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/tariff',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'E.ON Strom',
                currency: 'EUR',
                feedinType: 'STATIC',
                offtakeType: 'MARKET_DATA',
                staticPeriods: [
                  {
                    from: {weekday: 0, secondsOfDay: 0},
                    to: {weekday: 0, secondsOfDay: 0},
                    feedinPrice: 0.09,
                    offtakePrice: 0.4
                  }
                ],
                marketDataSettings: {feedinOffset: 2.5, offtakeOffset: 2.5, providerFee: 10, vat: 0.12}
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "E.ON Strom",
              "currency": "EUR",
              "feedinType": "STATIC",
              "offtakeType": "MARKET_DATA",
              "staticPeriods": [
                {
                  "from": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "to": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4
                }
              ],
              "marketDataSettings": {
                "feedinOffset": 2.5,
                "offtakeOffset": 2.5,
                "providerFee": 10,
                "vat": 0.12
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"E.ON Strom",
                                          @"currency": @"EUR",
                                          @"feedinType": @"STATIC",
                                          @"offtakeType": @"MARKET_DATA",
                                          @"staticPeriods": @[ @{ @"from": @{ @"weekday": @0, @"secondsOfDay": @0 }, @"to": @{ @"weekday": @0, @"secondsOfDay": @0 }, @"feedinPrice": @0.09, @"offtakePrice": @0.4 } ],
                                          @"marketDataSettings": @{ @"feedinOffset": @2.5, @"offtakeOffset": @2.5, @"providerFee": @10, @"vat": @0.12 } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"E.ON
            Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"E.ON
            Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems/%7BsystemID%7D/tariff", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/tariff"


            payload = {
                "name": "E.ON Strom",
                "currency": "EUR",
                "feedinType": "STATIC",
                "offtakeType": "MARKET_DATA",
                "staticPeriods": [
                    {
                        "from": {
                            "weekday": 0,
                            "secondsOfDay": 0
                        },
                        "to": {
                            "weekday": 0,
                            "secondsOfDay": 0
                        },
                        "feedinPrice": 0.09,
                        "offtakePrice": 0.4
                    }
                ],
                "marketDataSettings": {
                    "feedinOffset": 2.5,
                    "offtakeOffset": 2.5,
                    "providerFee": 10,
                    "vat": 0.12
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/tariff")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"E.ON Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"E.ON
            Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/tariff \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"E.ON Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "E.ON Strom",
              "currency": "EUR",
              "feedinType": "STATIC",
              "offtakeType": "MARKET_DATA",
              "staticPeriods": [
                [
                  "from": [
                    "weekday": 0,
                    "secondsOfDay": 0
                  ],
                  "to": [
                    "weekday": 0,
                    "secondsOfDay": 0
                  ],
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4
                ]
              ],
              "marketDataSettings": [
                "feedinOffset": 2.5,
                "offtakeOffset": 2.5,
                "providerFee": 10,
                "vat": 0.12
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update the tariff v2 of a system
      description: >
        Updates the tariff v2 of the system.


        See the response bodies description which fields have to be set for
        which `feedinType`/`offtakeType`.
      tags:
        - TariffV2
      security:
        - BearerAuth:
            - TariffWrite
      parameters:
        - *ref_74
      requestBody:
        required: true
        content:
          application/json:
            schema: &ref_421
              allOf:
                - &ref_420
                  type: object
                  allOf:
                    - *ref_140
                - additionalProperties: false
      responses:
        '200':
          description: The updated TariffV2.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_142
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/tariff");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/tariff\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"E.ON Strom\\\",\\\"currency\\\":\\\"EUR\\\",\\\"feedinType\\\":\\\"STATIC\\\",\\\"offtakeType\\\":\\\"MARKET_DATA\\\",\\\"staticPeriods\\\":[{\\\"from\\\":{\\\"weekday\\\":0,\\\"secondsOfDay\\\":0},\\\"to\\\":{\\\"weekday\\\":0,\\\"secondsOfDay\\\":0},\\\"feedinPrice\\\":0.09,\\\"offtakePrice\\\":0.4}],\\\"marketDataSettings\\\":{\\\"feedinOffset\\\":2.5,\\\"offtakeOffset\\\":2.5,\\\"providerFee\\\":10,\\\"vat\\\":0.12}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/tariff")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/tariff")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "E.ON Strom",
              "currency": "EUR",
              "feedinType": "STATIC",
              "offtakeType": "MARKET_DATA",
              "staticPeriods": [
                {
                  "from": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "to": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4
                }
              ],
              "marketDataSettings": {
                "feedinOffset": 2.5,
                "offtakeOffset": 2.5,
                "providerFee": 10,
                "vat": 0.12
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/tariff",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'E.ON Strom',
              currency: 'EUR',
              feedinType: 'STATIC',
              offtakeType: 'MARKET_DATA',
              staticPeriods: [
                {
                  from: {weekday: 0, secondsOfDay: 0},
                  to: {weekday: 0, secondsOfDay: 0},
                  feedinPrice: 0.09,
                  offtakePrice: 0.4
                }
              ],
              marketDataSettings: {feedinOffset: 2.5, offtakeOffset: 2.5, providerFee: 10, vat: 0.12}
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/tariff',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'E.ON Strom',
                currency: 'EUR',
                feedinType: 'STATIC',
                offtakeType: 'MARKET_DATA',
                staticPeriods: [
                  {
                    from: {weekday: 0, secondsOfDay: 0},
                    to: {weekday: 0, secondsOfDay: 0},
                    feedinPrice: 0.09,
                    offtakePrice: 0.4
                  }
                ],
                marketDataSettings: {feedinOffset: 2.5, offtakeOffset: 2.5, providerFee: 10, vat: 0.12}
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "E.ON Strom",
              "currency": "EUR",
              "feedinType": "STATIC",
              "offtakeType": "MARKET_DATA",
              "staticPeriods": [
                {
                  "from": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "to": {
                    "weekday": 0,
                    "secondsOfDay": 0
                  },
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4
                }
              ],
              "marketDataSettings": {
                "feedinOffset": 2.5,
                "offtakeOffset": 2.5,
                "providerFee": 10,
                "vat": 0.12
              }
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"E.ON Strom",
                                          @"currency": @"EUR",
                                          @"feedinType": @"STATIC",
                                          @"offtakeType": @"MARKET_DATA",
                                          @"staticPeriods": @[ @{ @"from": @{ @"weekday": @0, @"secondsOfDay": @0 }, @"to": @{ @"weekday": @0, @"secondsOfDay": @0 }, @"feedinPrice": @0.09, @"offtakePrice": @0.4 } ],
                                          @"marketDataSettings": @{ @"feedinOffset": @2.5, @"offtakeOffset": @2.5, @"providerFee": @10, @"vat": @0.12 } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/tariff"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/tariff",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"E.ON Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"E.ON
            Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"E.ON
            Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/systems/%7BsystemID%7D/tariff", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/tariff"


            payload = {
                "name": "E.ON Strom",
                "currency": "EUR",
                "feedinType": "STATIC",
                "offtakeType": "MARKET_DATA",
                "staticPeriods": [
                    {
                        "from": {
                            "weekday": 0,
                            "secondsOfDay": 0
                        },
                        "to": {
                            "weekday": 0,
                            "secondsOfDay": 0
                        },
                        "feedinPrice": 0.09,
                        "offtakePrice": 0.4
                    }
                ],
                "marketDataSettings": {
                    "feedinOffset": 2.5,
                    "offtakeOffset": 2.5,
                    "providerFee": 10,
                    "vat": 0.12
                }
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/tariff")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"E.ON
            Strom\",\"currency\":\"EUR\",\"feedinType\":\"STATIC\",\"offtakeType\":\"MARKET_DATA\",\"staticPeriods\":[{\"from\":{\"weekday\":0,\"secondsOfDay\":0},\"to\":{\"weekday\":0,\"secondsOfDay\":0},\"feedinPrice\":0.09,\"offtakePrice\":0.4}],\"marketDataSettings\":{\"feedinOffset\":2.5,\"offtakeOffset\":2.5,\"providerFee\":10,\"vat\":0.12}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/tariff \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"E.ON Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"E.ON
            Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}'
            |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/tariff \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"E.ON Strom","currency":"EUR","feedinType":"STATIC","offtakeType":"MARKET_DATA","staticPeriods":[{"from":{"weekday":0,"secondsOfDay":0},"to":{"weekday":0,"secondsOfDay":0},"feedinPrice":0.09,"offtakePrice":0.4}],"marketDataSettings":{"feedinOffset":2.5,"offtakeOffset":2.5,"providerFee":10,"vat":0.12}}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/tariff
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "E.ON Strom",
              "currency": "EUR",
              "feedinType": "STATIC",
              "offtakeType": "MARKET_DATA",
              "staticPeriods": [
                [
                  "from": [
                    "weekday": 0,
                    "secondsOfDay": 0
                  ],
                  "to": [
                    "weekday": 0,
                    "secondsOfDay": 0
                  ],
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4
                ]
              ],
              "marketDataSettings": [
                "feedinOffset": 2.5,
                "offtakeOffset": 2.5,
                "providerFee": 10,
                "vat": 0.12
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/tariff/prices':
    get:
      summary: Retrieve the tariff end prices of a system
      description: >
        Retrieves the end-price tariff for the system in the specified
        resolution (15-minute by default if not specified).

        The end-price is the price the customer is billed for (for market data
        tariffs for example after offset, VAT and provider fee are applied).


        Depending on the tariff settings, the tariff data might have been
        directly posted through the API, originate from market data 

        or is extrapolated from static data.


        If the resolution of the underlying data doesn't correspond to the
        requested resolution the data will be up- or down-sampled.

        For example the market prices used by market data tariffs have a 1 hour
        resolution. If you request 15min resolution you will

        get 4 equal periods per hour. If you request daily resolution, the
        average prices of 24 hourly periods will be returned per period.  


        If there are missing price periods over the requested interval (which
        may happen for `EXTERNAL` tariffs), the end-price tariff will start
        after the last period gap, aligned with the requested resolution.

        That is, if the requested interval for a given day is from 00:00 to
        12:00 and no prices were sent from at 02:15 to 03:45, the first period
        returned will be from 03:45 to 04:00 for a 15-min resolution or from
        04:00 to 05:00 for an hourly resolution.


        Once calculated the prices won't change anymore for the requested
        period.

        Even if the tariff is reconfigured the returned price will stay the
        same.

        This is due to the fact that historical prices can not be changed
        anymore. 

        Changes in the tariff will only have an effect in the future.


        The returned currency is determined by the currency of the underlying
        tariff if not specified otherwise.
      tags:
        - TariffV2
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
        - name: interval
          in: query
          description: >
            Requested time interval for fetching end-price tariff in the RFC3339
            format.

            If the available tariff data does not cover the full interval, the
            largest available subset will still be returned.

            If the lower bound of the interval is not a multiple of the
            resolution, it will be truncated.

            If the upper bound of the interval is not a multiple of the
            resolution, it will be rounded up.
          required: true
          example: '2020-09-21T00:00:00Z/2022-09-23T00:00:00Z'
          schema:
            type: string
            format: datetime
        - name: resolution
          in: query
          description: |
            Resolution of the end-price tariff periods as ISO8601 duration.
            If not specified it will be a 15-min resolution.

            Possible resolutions are:
            - PT15M - 15 minutes
            - PT1H - 1 hour
            - P1D - 1 day
          required: false
          example: PT1H
          schema:
            type: string
            format: iso8601
        - name: currency
          in: query
          description: >
            Currency in which the end prices should be returned.


            If the underlying data isn't already in the requested currency, the
            prices will be converted.

            This uses exchange rates with a daily resolution.
          example: EUR
          required: false
          schema:
            type: string
      responses:
        '200':
          description: >
            End-price tariff of the system for the interval requested.

            If the system has no tariff and therefore no end prices can be
            calculated the returned periods will be empty.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_146
                allOf:
                  - &ref_145
                    title: End-price Tariff V2
                    description: >
                      Represent a tariff v2 with end price periods.

                      End prices are prices with applied offset, VAT and
                      provider fee.

                      In contrast to normal "TariffV2" EndpriceTariffV2 always
                      is for a particular interval

                      and contains all periods for this interval.
                    type: object
                    properties:
                      currency:
                        type: string
                        description: Currency code (ISO 4217)
                        example: EUR
                      periods:
                        description: >
                          List of periods containing end prices over
                          non-overlapping periods. 

                          The periods are sorted chronologically.
                        type: array
                        items: &ref_144
                          title: End-price Tariff V2 Period
                          type: object
                          description: >
                            Represents a period of a TariffV2 with end prices.

                            End prices are prices with applied offset, VAT and
                            provider fee.
                          properties:
                            from:
                              type: string
                              format: date-time
                              example: '2018-04-01T00:10:00Z'
                              description: >
                                Time at which the period starts in the RFC3339
                                format.
                            to:
                              type: string
                              format: date-time
                              example: '2018-04-01T00:10:00Z'
                              description: >
                                Time at which the period ends in the RFC3339
                                format.
                            feedinPrice:
                              type: number
                              format: double
                              example: 0.09
                              description: >-
                                Price including offset, VAT and provider fee per
                                kWh for fed in energy in the period [from, to).
                            offtakePrice:
                              type: number
                              format: double
                              example: 0.4
                              description: >-
                                Price including offset, VAT and provider fee per
                                kWh for consumed energy in the period [from,
                                to).
                            marketPrice:
                              type: number
                              nullable: true
                              format: double
                              example: 0.15
                              description: >
                                Raw market price (Day-Ahead EPEX Spot price with
                                60min resolution) per kWh at the time of this
                                period in the bidding zone of the system.

                                Returned regardless if underlying tariff has a
                                market data type or not (if available).


                                For static tariffs (both offtake & feedin
                                =STATIC) this can be `null`, when there is no
                                market price for the requested period.
                          required:
                            - from
                            - to
                            - feedinPrice
                            - offtakePrice
                  - type: object
                    properties:
                      name:
                        type: string
                        description: Name of the underlying TariffV2.
                        nullable: true
                      from:
                        type: string
                        format: date-time
                        example: '2018-04-01T00:10:00Z'
                        description: >
                          Time at which the contained periods starts in the
                          RFC3339 format.
                      to:
                        type: string
                        format: date-time
                        example: '2018-04-01T00:10:00Z'
                        description: >
                          Time at which the contained period ends in the RFC3339
                          format.
                      periods:
                        items: &ref_422
                          allOf:
                            - *ref_144
                            - type: object
                              required:
                                - marketPrice
                    required:
                      - name
                      - currency
                      - from
                      - to
                      - periods
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices',
              qs: {
                interval: 'SOME_STRING_VALUE',
                resolution: 'SOME_STRING_VALUE',
                currency: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices");


            req.query({
              "interval": "SOME_STRING_VALUE",
              "resolution": "SOME_STRING_VALUE",
              "currency": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE',
              'resolution' => 'SOME_STRING_VALUE',
              'currency' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE',
              'resolution' => 'SOME_STRING_VALUE',
              'currency' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices"


            querystring =
            {"interval":"SOME_STRING_VALUE","resolution":"SOME_STRING_VALUE","currency":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE&currency=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Set tariff end prices of a system
      description: >
        Sets the tariff end prices for **external tariffs**.


        The sent price periods have a few restrictions:

        - They must have a 15 minute resolution.

        - They must not have gaps for current and future prices (gaps in the
        past are allowed).


        The prices can be sent in all supported currencies and will be converted
        by the `GET /tariff/prices` endpoint accordingly.


        You don't have to send your prices in all the currencies you want to
        support.

        Internally they always will be converted to Euro, therefore sending the
        same price periods in different currencies will overwrite

        the previously sent price periods. 
      tags:
        - TariffV2
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      requestBody:
        required: true
        content:
          application/json:
            schema: &ref_424
              allOf:
                - &ref_423
                  allOf:
                    - *ref_145
                    - type: object
                      properties:
                        currency:
                          description: |
                            Currency code (ISO 4217)
                            If not set, the currency of the tariff is used.
                        periods:
                          minItems: 1
                      required:
                        - periods
                - additionalProperties: false
      responses:
        '201':
          description: |
            Price periods successfully inserted.

            Returns an end-price tariff with all inserted price periods.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_146
        '400': *ref_15
        '422': *ref_3
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices\"\n\n\tpayload := strings.NewReader(\"{\\\"currency\\\":null,\\\"periods\\\":[{\\\"from\\\":\\\"2018-04-01T00:10:00Z\\\",\\\"to\\\":\\\"2018-04-01T00:10:00Z\\\",\\\"feedinPrice\\\":0.09,\\\"offtakePrice\\\":0.4,\\\"marketPrice\\\":0.15}]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "currency": null,
              "periods": [
                {
                  "from": "2018-04-01T00:10:00Z",
                  "to": "2018-04-01T00:10:00Z",
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4,
                  "marketPrice": 0.15
                }
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/tariff/prices",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              currency: null,
              periods: [
                {
                  from: '2018-04-01T00:10:00Z',
                  to: '2018-04-01T00:10:00Z',
                  feedinPrice: 0.09,
                  offtakePrice: 0.4,
                  marketPrice: 0.15
                }
              ]
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                currency: null,
                periods: [
                  {
                    from: '2018-04-01T00:10:00Z',
                    to: '2018-04-01T00:10:00Z',
                    feedinPrice: 0.09,
                    offtakePrice: 0.4,
                    marketPrice: 0.15
                  }
                ]
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "currency": null,
              "periods": [
                {
                  "from": "2018-04-01T00:10:00Z",
                  "to": "2018-04-01T00:10:00Z",
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4,
                  "marketPrice": 0.15
                }
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"currency": ,
                                          @"periods": @[ @{ @"from": @"2018-04-01T00:10:00Z", @"to": @"2018-04-01T00:10:00Z", @"feedinPrice": @0.09, @"offtakePrice": @0.4, @"marketPrice": @0.15 } ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"currency":null,"periods":[{"from":"2018-04-01T00:10:00Z","to":"2018-04-01T00:10:00Z","feedinPrice":0.09,"offtakePrice":0.4,"marketPrice":0.15}]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"currency":null,"periods":[{"from":"2018-04-01T00:10:00Z","to":"2018-04-01T00:10:00Z","feedinPrice":0.09,"offtakePrice":0.4,"marketPrice":0.15}]}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/systems/%7BsystemID%7D/tariff/prices",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices"


            payload = {
                "currency": None,
                "periods": [
                    {
                        "from": "2018-04-01T00:10:00Z",
                        "to": "2018-04-01T00:10:00Z",
                        "feedinPrice": 0.09,
                        "offtakePrice": 0.4,
                        "marketPrice": 0.15
                    }
                ]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"currency\":null,\"periods\":[{\"from\":\"2018-04-01T00:10:00Z\",\"to\":\"2018-04-01T00:10:00Z\",\"feedinPrice\":0.09,\"offtakePrice\":0.4,\"marketPrice\":0.15}]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"currency":null,"periods":[{"from":"2018-04-01T00:10:00Z","to":"2018-04-01T00:10:00Z","feedinPrice":0.09,"offtakePrice":0.4,"marketPrice":0.15}]}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"currency":null,"periods":[{"from":"2018-04-01T00:10:00Z","to":"2018-04-01T00:10:00Z","feedinPrice":0.09,"offtakePrice":0.4,"marketPrice":0.15}]}'
            |  \
              http POST https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"currency":null,"periods":[{"from":"2018-04-01T00:10:00Z","to":"2018-04-01T00:10:00Z","feedinPrice":0.09,"offtakePrice":0.4,"marketPrice":0.15}]}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "currency": ,
              "periods": [
                [
                  "from": "2018-04-01T00:10:00Z",
                  "to": "2018-04-01T00:10:00Z",
                  "feedinPrice": 0.09,
                  "offtakePrice": 0.4,
                  "marketPrice": 0.15
                ]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/tariff/prices")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/decisions':
    get:
      summary: Get time of use optimization decisions of a system.
      description: >
        Get optimization decisions and associated metrics for a system with
        `system_id`,

        within given time interval. Note that decisions may not always cover the
        complete time interval.

        Only decisions with `start_at` in the past are returned.

        The maximum time interval that can be requested is 48 hours.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
        - *ref_119
      responses:
        '200':
          description: Array of optimization decisions and associated metrics.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_428
                type: object
                properties:
                  decisions:
                    type: array
                    items: &ref_426
                      type: object
                      properties:
                        from:
                          type: string
                          format: date-time
                        to:
                          type: string
                          format: date-time
                        case_name:
                          type: string
                          enum:
                            - BATTERY_SELF_CONSUMPTION
                            - BATTERY_NO_DISCHARGE
                            - BATTERY_CHARGE_FROM_GRID
                            - BATTERY_DISCHARGE_TO_GRID
                            - BATTERY_NO_CHARGE
                            - BATTERY_LIMIT_CHARGE
                            - BATTERY_LIMIT_DISCHARGE
                            - BATTERY_UNDEFINED_DECISION
                            - EV_NO_DECISION
                            - EV_CHARGE_FROM_GRID
                            - EV_NO_CHARGE
                            - EV_LIMIT_CHARGE
                            - EV_LIMIT_DISCHARGE
                            - EV_UNDEFINED_DECISION
                            - HEATPUMP_RECOMMEND_ON
                            - HEATPUMP_AUTO
                          example: BATTERY_CHARGE_FROM_GRID
                          description: >
                            Identifies underlying the decision case that this
                            decision is based on.

                            The following cases are implemented:

                            1. `BATTERY_SELF_CONSUMPTION`: No time-of-use
                            decision applied for the battery. In this case, the
                            default

                            self-consumption maximization logic applies to the
                            battery.

                            2. `BATTERY_NO_DISCHARGE`: Do not discharge the
                            battery, even if there is demand and no PV surplus.

                            Demand is served with power from the grid, instead
                            of discharging the battery.

                            3. `BATTERY_CHARGE_FROM_GRID`: Charge the battery
                            with power for the grid, instead of only

                            charging the PV surplus. The battery is forced to
                            charge with maximum charging power.

                            4. `BATTERY_DISCHARGE_TO_GRID`: Discharge the
                            battery into the grid, instead of only discharging
                            to serve demand. 

                            Discharge of the battery may coincide with PV
                            surplus, to benefit from high grid export prices
                            charging the PV 

                            surplus. The battery is forced to discharge with
                            maximum power.

                            5. `BATTERY_NO_CHARGE`: Do not charge the battery,
                            even if there is PV surplus. PV surplus is injected

                            into the grid, instead of charging the battery.

                            6. `BATTERY_LIMIT_CHARGE`: Limit the charging power
                            of the battery, even if there is additional PV
                            surplus.

                            7. `BATTERY_LIMIT_DISCHARGE`: Limit the discharging
                            power of the battery, even if there is additional
                            demand.

                            8. `BATTERY_UNDEFINED_DECISION`: Decision applied to
                            the battery, but the decision cannot be mapped to
                            any

                            other decision case. This case is used as a fallback
                            for newly implemented decision cases.

                            self-consumption maximization logic applies to the
                            battery.

                            9. `EV_NO_DECISION`: No time-of-use decision applied
                            for the EV. In this case, the default

                            charge logic applies to the EV, depending on the
                            charge mode.

                            10. `EV_CHARGE_FROM_GRID`: Charge the EV with power
                            for the grid, instead of only

                            charging the PV surplus. The EV is forced to charge
                            with maximum charging power.

                            11. `EV_NO_CHARGE`: Do not charge the EV, even if
                            there is PV surplus.

                            12. `EV_LIMIT_CHARGE`: Limit the charging power of
                            the EV.

                            13. `EV_LIMIT_DISCHARGE`: Limit the discharging
                            power of the EV.

                            14. `EV_UNDEFINED_DECISION`: Decision applied to the
                            EV, but the decision cannot be mapped to any

                            other decision case. This case is used as a fallback
                            for newly implemented decision cases.

                            15. `HEATPUMP_RECOMMEND_ON`: Recommending the heat
                            pump to switch on.

                            16. `HEATPUMP_AUTO`: The heat pump is set to run in
                            its energy-efficient normal mode.
                        insight: &ref_425
                          type: object
                          properties:
                            motives:
                              type: array
                              items:
                                type: string
                                enum:
                                  - BATTERY_CHARGE_TO_COVER_LOAD
                                  - BATTERY_CHARGE_TO_DISCHARGE_TO_GRID
                                  - BATTERY_CHARGE_SURPLUS_TO_COVER_LOAD
                                  - BATTERY_CHARGE_SURPLUS_TO_DISCHARGE_TO_GRID
                                  - BATTERY_KEEP_TO_COVER_LOAD
                                  - BATTERY_KEEP_TO_DISCHARGE_TO_GRID
                                  - BATTERY_DISCHARGE_TO_GRID
                                  - EV_CHARGE_IN_LOW_PRICES
                                  - EV_CHARGE_TO_SATISFY_DESIRED_SOC
                                  - >-
                                    EV_KEEP_TO_EXPORT_SURPLUS_AND_CHARGE_FROM_GRID_LATER
                                  - HEAT_PUMP_RECOMMEND_ON_MOTIVE
                              example:
                                - BATTERY_CHARGE_TO_COVER_LOAD
                              description: >
                                Identifies the motivation behind a ToU decision.
                                The following insights are implemented:

                                1. `BATTERY_CHARGE_TO_COVER_LOAD`: Charge the
                                battery in low `import_price` to cover load at
                                higher import prices (>
                                `break_even_import_price`) between `start_time`
                                and `end_time`.

                                2. `BATTERY_CHARGE_TO_DISCHARGE_TO_GRID`: Charge
                                the battery in low `import_price` to discharge
                                to grid at higher export prices (>
                                `break_even_export_price`) between `start_time`
                                and `end_time`.

                                3. `BATTERY_CHARGE_SURPLUS_TO_COVER_LOAD`:
                                Charge the battery from surplus to cover load
                                later at higher import prices.

                                4.
                                `BATTERY_CHARGE_SURPLUS_TO_DISCHARGE_TO_GRID`:
                                Charge the battery from surplus to discharge to
                                grid at higher export prices.

                                5. `BATTERY_KEEP_TO_COVER_LOAD`: Delay battery
                                discharge to cover load at higher import prices
                                (> `break_even_import_price`) between
                                `start_time` and `end_time`.

                                6. `BATTERY_KEEP_TO_DISCHARGE_TO_GRID`: Delay
                                battery discharge to the grid at higher export
                                prices (> `break_even_export_price`) between
                                `start_time` and `end_time`.

                                7. `BATTERY_DISCHARGE_TO_GRID`: Discharge the
                                battery into the grid to benefit from high
                                export prices.

                                8. `EV_CHARGE_IN_LOW_PRICES`: Charge the EV
                                earlier in low `import_price`. The desired SoC
                                expected to be met at `end_time`.

                                9. `EV_CHARGE_TO_SATISFY_DESIRED_SOC`: Force
                                Charge the EV from grid to ensure that the
                                desired SoC at pre-defined departure time
                                (regardless of prices).

                                10.
                                `EV_KEEP_TO_EXPORT_SURPLUS_AND_CHARGE_FROM_GRID_LATER`:
                                Prevent EV charge to allow PV surplus export at
                                high export prices, and charge EV from grid
                                later at lower import prices.

                                11. `HEAT_PUMP_RECOMMEND_ON_MOTIVE`: Request
                                increased heat pump operation, to avoid
                                potential higher price periods or to use PV
                                surplus.
                            importPrice:
                              type: number
                              example: 0.1
                              description: >
                                Current import price at which the decision is
                                taken.
                            breakEvenImportPrice:
                              type: number
                              example: 0.1
                              description: >
                                Refers to the minimum import price at which
                                using the stored energy later becomes more
                                profitable than importing from grid, while
                                accounting for battery efficiency losses.
                            averageImportPrice:
                              type: number
                              example: 0.1
                              description: >
                                Average import price at which the stored energy
                                was utilized.
                            exportPrice:
                              type: number
                              example: 0.1
                              description: >
                                Current export price at which the decision is
                                taken.
                            breakEvenExportPrice:
                              type: number
                              example: 0.1
                              description: >
                                Refers to the minimum export price at which
                                selling the stored energy to grid later becomes
                                profitable, while accounting for battery
                                efficiency losses.
                            averageExportPrice:
                              type: number
                              example: 0.1
                              description: >
                                Average export price at which the stored energy
                                was utilized.
                            from:
                              type: string
                              format: date-time
                              example: '2020-09-21T00:00:00Z'
                              description: >
                                Refers to the start time of an upcoming event
                                justifying the current decision (e.g., start of
                                battery discharge to cover load / to grid).
                            to:
                              type: string
                              format: date-time
                              example: '2020-09-21T01:00:00Z'
                              description: >
                                Refers to the end time of an upcoming event
                                justifying the current decision (e.g., end of
                                battery discharge to cover load / to grid).
                        isPriceBasedOptimization:
                          type: boolean
                          description: >-
                            Indicates if the decision is based on price. In most
                            cases, decisions not based on price correspond to
                            the "default" decision for a particular appliance
                            type.
                      required:
                        - from
                        - to
                        - case_name
                        - isPriceBasedOptimization
                  metrics: &ref_427
                    type: object
                    properties:
                      percent_decision_taken:
                        type: number
                        format: double
                        example: 75
                        description: >
                          Percentage of the taken decisions as a share of the
                          total possible decisions during this time interval.
                          Taken decisions are all decisions excluding
                          "no-decision" cases.
                    required:
                      - percent_decision_taken
                required:
                  - decisions
                  - metrics
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions',
              qs: {interval: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions"


            querystring = {"interval":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/decisions?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/settings':
    get:
      summary: Get time of use optimization settings of a system.
      description: Get time of use optimization settings of a system.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200': &ref_149
          description: Ok
          content:
            application/vnd.gridx.v2+json:
              schema:
                allOf:
                  - &ref_148
                    description: Settings for the Time-of-Use (ToU) optimization feature.
                    type: object
                    properties:
                      enabled:
                        description: >
                          If `true`, Time-of-Use (ToU) optimization is enabled
                          for this system.
                        type: boolean
                        example: false
                      enabledBatteryChargeFromGrid:
                        description: >
                          If `true`, the Time-of-Use (ToU) optimization is
                          allowed to trigger charging of the battery while

                          simultaneously importing electricity from the grid.
                          Default: `true`
                        example: true
                        type: boolean
                      enabledDischargeFlexibilityToGrid:
                        description: >
                          If `true`, the Time-of-Use optimization is allowed to
                          trigger discharging of electricity from any

                          flexibility (battery and EVCS, when EVCS discharge is
                          supported) into the grid. Default: `false`
                        example: false
                        type: boolean
                  - required:
                      - enabled
                      - enabledBatteryChargeFromGrid
                      - enabledDischargeFlexibilityToGrid
        '204':
          description: No time of use setting information found for the given systemID
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/settings",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/timeofuse/settings",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    put:
      summary: Set time of use optimization settings for a system.
      description: Set time of use optimization settings for a system.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      requestBody: &ref_214
        required: true
        content:
          application/json:
            schema: &ref_430
              allOf:
                - &ref_429
                  allOf:
                    - *ref_148
                    - properties:
                        enabledBatteryChargeFromGrid:
                          default: true
                        enabledDischargeFlexibilityToGrid:
                          default: false
                      required:
                        - enabled
                - additionalProperties: false
      responses:
        '200': *ref_149
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"enabled\\\":false,\\\"enabledBatteryChargeFromGrid\\\":true,\\\"enabledDischargeFlexibilityToGrid\\\":false}\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")
              .put(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "enabled": false,
              "enabledBatteryChargeFromGrid": true,
              "enabledDischargeFlexibilityToGrid": false
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              "method": "PUT",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/settings",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              enabled: false,
              enabledBatteryChargeFromGrid: true,
              enabledDischargeFlexibilityToGrid: false
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                enabled: false,
                enabledBatteryChargeFromGrid: true,
                enabledDischargeFlexibilityToGrid: false
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "enabled": false,
              "enabledBatteryChargeFromGrid": true,
              "enabledDischargeFlexibilityToGrid": false
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"enabled": @NO,
                                          @"enabledBatteryChargeFromGrid": @YES,
                                          @"enabledDischargeFlexibilityToGrid": @NO };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"
            in


            Client.call ~headers ~body `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_POSTFIELDS => "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings');

            $request->setRequestMethod('PUT');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PUT", "/systems/%7BsystemID%7D/timeofuse/settings",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings"


            payload = {
                "enabled": False,
                "enabledBatteryChargeFromGrid": True,
                "enabledDischargeFlexibilityToGrid": False
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PUT", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}'
            |  \
              http PUT https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "enabled": false,
              "enabledBatteryChargeFromGrid": true,
              "enabledDischargeFlexibilityToGrid": false
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update time of use optimization settings for a system.
      description: Update time of use optimization settings for a system.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      requestBody: &ref_215
        required: true
        content:
          application/json:
            schema: &ref_431
              allOf:
                - *ref_148
                - additionalProperties: false
      responses:
        '200': *ref_149
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"enabled\\\":false,\\\"enabledBatteryChargeFromGrid\\\":true,\\\"enabledDischargeFlexibilityToGrid\\\":false}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "enabled": false,
              "enabledBatteryChargeFromGrid": true,
              "enabledDischargeFlexibilityToGrid": false
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/settings",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              enabled: false,
              enabledBatteryChargeFromGrid: true,
              enabledDischargeFlexibilityToGrid: false
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                enabled: false,
                enabledBatteryChargeFromGrid: true,
                enabledDischargeFlexibilityToGrid: false
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "enabled": false,
              "enabledBatteryChargeFromGrid": true,
              "enabledDischargeFlexibilityToGrid": false
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"enabled": @NO,
                                          @"enabledBatteryChargeFromGrid": @YES,
                                          @"enabledDischargeFlexibilityToGrid": @NO };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/systems/%7BsystemID%7D/timeofuse/settings",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings"


            payload = {
                "enabled": False,
                "enabledBatteryChargeFromGrid": True,
                "enabledDischargeFlexibilityToGrid": False
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"enabled\":false,\"enabledBatteryChargeFromGrid\":true,\"enabledDischargeFlexibilityToGrid\":false}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}'
            |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"enabled":false,"enabledBatteryChargeFromGrid":true,"enabledDischargeFlexibilityToGrid":false}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "enabled": false,
              "enabledBatteryChargeFromGrid": true,
              "enabledDischargeFlexibilityToGrid": false
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/settings")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/forecasts/meter':
    get:
      summary: Get the Time-of-Use forecasts for the grid connection point.
      description: >
        The Time-of-Use (ToU) optimization runs on a given resolution of 15
        minutes.

        For each time segment, i.e. `[10:00, 10:15]` it publishes a series of
        forecasts for

        the grid connection point associated with a system with `systemID`.


        This endpoint requires to specify a time window called `interval` for
        which the forecasts are returned.

        For example `[2021-01-01T02:07:14Z, 2021-01-02T02:07:14Z]`.

        If no interval is provided it is assumed to be `[00:00:00 today,
        00:00:00 in two days]`.

        The maximum size of this interval is 48h.


        This endpoint returns the forecasts **in the selected time window**.

        Please note that the forecasts might not cover the whole time window.

        In this case the largest possible subset is returned.

        If no forecast is available, an empty list is returned.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
        - &ref_150
          name: interval
          in: query
          required: false
          schema:
            type: string
            format: datetime
            example: '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
          description: >
            A time interval [start_timestamp, end_timestamp] encoded as a unique
            string start_timestamp/end_timestamp.

            Each timestamp should be specified in the RFC3339 format.

            The maximum time interval that can be requested is 48 hours.

            IMPORTANT: it has to be fully URL encoded (also known as
            Percent-encoding), including the `/`.
      responses:
        '200':
          description: |
            Successful request. Retrieved forecasts for the given parameters.
          content:
            application/json:
              schema: &ref_366
                type: object
                properties:
                  from:
                    type: string
                    format: date-time
                    example: '2020-09-21T00:00:00Z'
                    description: >
                      Timestamp in RFC3339 format that marks the beginning of
                      the validity period for the forecast.
                  to:
                    type: string
                    format: date-time
                    example: '2020-09-21T22:10:00Z'
                    description: >
                      Timestamp in RFC3339 format that marks the end of the
                      validity period for the forecast.
                  periods:
                    type: array
                    items: &ref_367
                      type: object
                      properties:
                        from:
                          type: string
                          format: date-time
                          example: '2020-09-21T00:00:00Z'
                          description: >
                            Timestamp in RFC3339 format that marks the beginning
                            of the period.
                        to:
                          type: string
                          format: date-time
                          example: '2020-09-21T00:15:00Z'
                          description: >
                            Timestamp in RFC3339 format that marks the end of
                            the period.
                        importActivePower:
                          type: number
                          description: |
                            The forecasted import active power in Watts.
                        exportActivePower:
                          type: number
                          description: |
                            The forecasted export active power in Watts.
                  lastUpdated:
                    type: string
                    format: date-time
                    example: '2020-09-21T00:00:00Z'
                    description: |
                      Last time when the forecast was updated.
        '400': *ref_15
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter',
              qs: {interval: '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter");


            req.query({
              "interval": "2018-04-01T15:00:00Z/2018-04-25T00:00:00Z"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter"


            querystring =
            {"interval":"2018-04-01T15:00:00Z/2018-04-25T00:00:00Z"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/forecasts/meter/last-updated':
    get:
      summary: >-
        Get the last updated timestamp for the Time-of-Use forecasts for the
        grid connection point.
      description: >
        The Time-of-Use (ToU) optimization runs on a given resolution of 15
        minutes.

        For each time segment, i.e. `[10:00, 10:15]` it publishes a series of
        forecasts for

        the grid connection point associated with a system with `systemID`.


        This endpoint requires to specify a time window called `interval` for
        which the forecasts are returned.

        For example `[2021-01-01T02:07:14Z, 2021-01-02T02:07:14Z]`.

        If no interval is provided it is assumed to be `[00:00:00 today,
        00:00:00 in two days]`.

        The maximum size of this interval is 48h.


        This endpoint returns the last timestamp RFC3339 format when the
        forecasts **in the selected time window**

        were updated.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
        - *ref_150
      responses:
        '200':
          description: >
            Successful request. Retrieved last update time for the given
            parameters.
          content:
            application/json:
              schema:
                type: object
                properties:
                  lastUpdated:
                    type: string
                    format: date-time
                    example: '2020-09-21T00:00:00Z'
                    description: |
                      Last time when the prediction where updated.
        '400': *ref_15
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated',
              qs: {interval: '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated");


            req.query({
              "interval": "2018-04-01T15:00:00Z/2018-04-25T00:00:00Z"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated"


            querystring =
            {"interval":"2018-04-01T15:00:00Z/2018-04-25T00:00:00Z"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/forecasts/meter/last-updated?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/status':
    get:
      summary: Get the historical status of the Time-of-Use service.
      description: >-
        The Time-of-Use (ToU) optimization runs on a given resolution of 15
        minutes.

        For each time segment, i.e. `[10:00, 10:15]` it publishes an operational
        status

        associated with a system with `systemID`.


        This endpoint requires to specify a time window called `interval` for
        which the status data are returned.

        For example `[2021-01-01T02:07:14Z, 2021-01-02T02:07:14Z]`.

        If no interval is provided it is assumed to be `[now - 48h, now]`.

        The maximum size of this interval is 48h.

        Please note that the statuses might not cover the whole time window.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
        - *ref_150
      responses:
        '200':
          description: >
            Successful request. Retrieved historical status for given
            parameters.
          content:
            application/json:
              schema: &ref_368
                type: object
                properties:
                  from:
                    type: string
                    format: date-time
                    example: '2020-09-21T00:00:00Z'
                    description: >
                      Timestamp in RFC3339 format that marks the beginning of
                      the validity period for the status history.
                  to:
                    type: string
                    format: date-time
                    example: '2020-09-21T22:10:00Z'
                    description: >
                      Timestamp in RFC3339 format that marks the end of the
                      validity period for the status history.
                  periods: &ref_369
                    type: array
                    items: &ref_151
                      type: object
                      properties:
                        from:
                          type: string
                          format: date-time
                          example: '2020-09-21T00:00:00Z'
                          description: >
                            Timestamp in RFC3339 format that marks the beginning
                            of the period.
                        to:
                          type: string
                          format: date-time
                          example: '2020-09-21T00:15:00Z'
                          description: >
                            Timestamp in RFC3339 format that marks the end of
                            the period.
                        status: &ref_370
                          type: string
                          enum:
                            - ONLINE
                            - SUBOPTIMAL
                            - OFFLINE
                            - DISABLED
                            - INITIALIZING
                          example: ONLINE
                          description: >
                            Operational status of Time-of-Use for a specific
                            run.


                            * `ONLINE` - Time-of-Use optimization is running
                            successfully.

                            * `SUBOPTIMAL` - Time-of-Use optimization is running
                            suboptimally.

                            * `OFFLINE` - Time-of-Use optimization failed.

                            * `DISABLED` - Time-of-Use optimization is disabled
                            for the system.

                            * `INITIALIZING` - Time-of-Use optimization is
                            initializing, it may take up to 48h.
                        error_code: &ref_432
                          type: string
                          enum:
                            - STATIC_PRICES
                            - MISSING_PRICES
                            - INCOMPLETE_PRICES
                            - MISSING_GRID_METER
                            - MULTIPLE_BATTERIES
                            - MULTIPLE_EVCS
                            - MULTIPLE_HEAT_PUMPS
                            - MISSING_CONTROLLABLE_APPLIANCE
                            - OFFLINE_APPLIANCE
                            - INTERNAL_ERROR
                          example: INTERNAL_ERROR
                          description: >
                            Most recent error causing a failure of Time-of-Use
                            specific run.

                            * `STATIC_PRICES` - Time-of-Use failing due to
                            import and export prices are constant.

                            * `MISSING_PRICES` - Time-of-Use failing due to
                            missing import and export prices.

                            * `INCOMPLETE_PRICES` - Time-of-Use failing due to
                            incomplete import and export prices.

                            * `MISSING_GRID_METER` - Time-of-Use failing due to
                            missing grid meter.

                            * `MULTIPLE_BATTERIES` - Time-of-Use failing due to
                            multiple batteries within a system.

                            * `MULTIPLE_EVCS` - Time-of-Use failing due to
                            multiple EV charging stations within a system.

                            * `MULTIPLE_HEAT_PUMPS` - Time-of-Use failing due to
                            multiple heat pumps within a system.

                            * `MISSING_CONTROLLABLE_APPLIANCE` - Time-of-Use
                            failing due to missing controllable device (battery,
                            EV or heat pump).

                            * `OFFLINE_APPLIANCE` - Time-of-Use failing due to
                            an offline appliance.

                            * `INTERNAL_ERROR` - Time-of-Use failing due to an
                            unknown, internal issue.
                        warnings: &ref_433
                          type: array
                          items:
                            type: string
                            enum:
                              - MISSING_EV_CONFIG
                              - MISSING_EV_PROFILE
                              - UNSUPPORTED_CHARGE_MODE_QUICK
                              - UNSUPPORTED_CHARGE_MODE_SURPLUS
                              - UNSUPPORTED_CHARGE_MODE_SAFETY
                              - UNSUPPORTED_CHARGE_MODE_UNKNOWN
                          example:
                            - MISSING_EV_CONFIG
                          description: >
                            All the relevant warnings that occurred during a
                            Time-of-Use specific run.


                            * `MISSING_EV_CONFIG` - Time-of-Use not working
                            optimally due to missing EV configuration.

                            * `MISSING_EV_PROFILE` - Time-of-Use not working
                            optimally due to missing EV profile.

                            * `UNSUPPORTED_CHARGE_MODE_QUICK` - Time-of-Use not
                            working optimally due to EV set to Quick Charge
                            Mode, which is not supported.

                            * `UNSUPPORTED_CHARGE_MODE_SURPLUS` - Time-of-Use
                            not working optimally due to EV set to Surplus
                            Charge Mode, which is not supported.

                            * `UNSUPPORTED_CHARGE_MODE_SAFETY` - Time-of-Use not
                            working optimally due to EV set to Safety Charge
                            Mode, which is not supported.

                            * `UNSUPPORTED_CHARGE_MODE_UNKNOWN` - Time-of-Use
                            not working optimally due to EV set to unknown
                            charge mode.
        '400': *ref_15
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status',
              qs: {interval: '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status");


            req.query({
              "interval": "2018-04-01T15:00:00Z/2018-04-25T00:00:00Z"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => '2018-04-01T15:00:00Z/2018-04-25T00:00:00Z'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status"


            querystring =
            {"interval":"2018-04-01T15:00:00Z/2018-04-25T00:00:00Z"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status?interval=2018-04-01T15%3A00%3A00Z%2F2018-04-25T00%3A00%3A00Z")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/status/current':
    get:
      summary: Get the last known status of the Time-of-Use service.
      description: >-
        The Time-of-Use (ToU) optimization runs on a given resolution of 15
        minutes.

        For each time segment, i.e. `[10:00, 10:15]` it publishes an operational
        status for

        associated with a system with `systemID`.


        This endpoint provides the last known, or current, status of the
        Time-of-Use runs.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200':
          description: |
            Successful request. Retrieved status for the given parameters.
          content:
            application/json:
              schema:
                type: object
                properties:
                  status: *ref_151
        '404': *ref_83
        '422': *ref_3
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/status/current",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/timeofuse/status/current", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/status/current")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/timeofuse/readiness':
    get:
      summary: Evaluate whether the system is ready for enabling Time-of-Use.
      description: >-
        A series of operational prerequisites are required before enabling
        Time-of-Use (ToU) for a system.

        The checks are done in order to evaluate the system's "readiness" for
        ToU.

        In principal, checks pertaining to appliances used, price data used, as
        well as some system metadata are performed.
      tags:
        - TimeOfUse
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200':
          description: >
            Successful request. Retrieved ToU readiness for the given
            parameters.
          content:
            application/json:
              schema: &ref_435
                type: object
                properties:
                  isTouReady:
                    type: boolean
                    example: false
                    description: |
                      Truth value whether system is ready for ToU.
                  reasons:
                    type: array
                    description: >
                      List of reasons detailing the cause(s) of the truth value
                      of ToU Readiness
                    items: &ref_434
                      type: string
                      enum:
                        - UNKNOWN_REASON
                        - UNSUPPORTED_SETUP_NO_APPLIANCES_FOUND
                        - UNSUPPORTED_SETUP_MULTIPLE_BATTERIES
                        - UNSUPPORTED_SETUP_MULTIPLE_EVCS
                        - UNSUPPORTED_SETUP_MULTIPLE_GRID_METERS
                        - UNSUPPORTED_SETUP_MULTIPLE_HEAT_PUMPS
                        - UNSUPPORTED_SETUP_NO_GRID_METER
                        - UNSUPPORTED_SETUP_NO_CONTROLLABLE_APPLIANCE
                        - UNSUPPORTED_SETUP_UNKNOWN_APPLIANCE
                        - UNSUPPORTED_APPLIANCE_PV_INVERTER
                        - UNSUPPORTED_APPLIANCE_BATTERY_INVERTER
                        - UNSUPPORTED_APPLIANCE_EVCS
                        - UNSUPPORTED_APPLIANCE_HEAT_PUMP
                        - SYSTEM_LOCATION_MISSING
                        - TARIFF_PRICES_NOT_SET
                        - TARIFF_PRICES_NOT_DYNAMIC
                        - TARIFF_PRICES_BIDDING_ZONE_NOT_SET
                      example: UNSUPPORTED_SETUP_NO_APPLIANCES_FOUND
                      description: |
                        Justification for ToU Readiness truth value.
                required:
                  - isTouReady
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/timeofuse/readiness",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/timeofuse/readiness",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/timeofuse/readiness")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/grid-signals':
    get:
      summary: Get system grid signal capabilities.
      description: >
        Gets information about the system's capabilities to deal with grid
        signals. 
      tags:
        - GridSignals
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200':
          description: Ok
          content:
            application/json:
              schema: &ref_152
                type: object
                description: |
                  Information about the grid signal capabilities of the system.
                properties:
                  is14aCompliant:
                    description: >
                      Whether the system is compliant with §14a EnWG. Only for
                      German market.
                    type: boolean
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/grid-signals\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/grid-signals",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/grid-signals',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/grid-signals"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/grid-signals');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/grid-signals');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/grid-signals",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/grid-signals \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/systems/%7BsystemID%7D/grid-signals \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/grid-signals
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update system grid signal capabilities.
      description: >
        Updates information about the system's capabilities to deal with grid
        signals. 
      tags:
        - GridSignals
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      requestBody: &ref_216
        description: Modified System.
        required: true
        content:
          application/json:
            schema: &ref_437
              allOf:
                - &ref_436
                  allOf:
                    - *ref_152
                - additionalProperties: false
      responses:
        '200':
          description: Ok
          content:
            application/json:
              schema: *ref_152
        '400': *ref_15
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"is14aCompliant\":true}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"is14aCompliant\":true}", ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/grid-signals\"\n\n\tpayload := strings.NewReader(\"{\\\"is14aCompliant\\\":true}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"is14aCompliant\":true}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"is14aCompliant\":true}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"is14aCompliant\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "is14aCompliant": true
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"is14aCompliant\":true}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/grid-signals",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({is14aCompliant: true}));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/grid-signals',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {is14aCompliant: true},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "is14aCompliant": true
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"is14aCompliant": @YES };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/grid-signals"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"is14aCompliant\":true}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"is14aCompliant\":true}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/grid-signals');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"is14aCompliant":true}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"is14aCompliant":true}');


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/grid-signals');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"is14aCompliant\":true}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/systems/%7BsystemID%7D/grid-signals",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals"


            payload = {"is14aCompliant": True}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"is14aCompliant\":true}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/systems/%7BsystemID%7D/grid-signals \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"is14aCompliant":true}'
        - lang: Shell + Httpie
          source: |-
            echo '{"is14aCompliant":true}' |  \
              http PATCH https://api.gridx.de/systems/%7BsystemID%7D/grid-signals \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"is14aCompliant":true}' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/grid-signals
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["is14aCompliant": true] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/grid-signals")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/ems-capabilities':
    get:
      summary: Get system EMS capabilities.
      description: >
        __WARN: This API is only for internal usage!__


        Gets information about the system's EMS capabilities. The latest
        reported list of capabilities is returned.


        Empty response means no capabilities were reported by EMS so far. Full
        list of supported capabilities is maintained by gridBox team.
      tags:
        - EMS
      security:
        - BearerAuth: []
      parameters:
        - *ref_74
      responses:
        '200':
          description: Ok
          content:
            application/json:
              schema: &ref_439
                type: object
                description: >
                  Information about the supported EMS capabilities of the
                  system.
                properties:
                  reportedAt:
                    description: >
                      Timestamp of last reported capabilities. If empty, no
                      capabilities were reported by the system.
                    type: string
                    format: date-time
                    readOnly: true
                    example: '2029-11-10T23:20:50Z'
                  capabilities:
                    description: >
                      List of supported capabilities. An empty list means no
                      specific capabilities are supported by the current EMS.
                    type: array
                    readOnly: true
                    items: &ref_438
                      description: >
                        EMS capability of the system. Possible values:

                        * `EMS_CAPABILITY_POWER_EQUALITY_CONSTRAINTS` - The EMS
                        supports accepting and forwarding equality constraints
                        (e.g. ActivePower = 42W).

                        * `EMS_CAPABILITY_POWER_INEQUALITY_CONSTRAINTS` - The
                        EMS supports considering inequality constraints for
                        power limits (e.g. MaxActivePower = 2kW).

                        * `EMS_CAPABILITY_BATTERY_DISCHARGE` - The EMS supports
                        accepting constraints that cause assets to discharge
                        their energy into the grid.
                      type: string
                      readOnly: true
                      enum:
                        - EMS_CAPABILITY_POWER_EQUALITY_CONSTRAINTS
                        - EMS_CAPABILITY_POWER_INEQUALITY_CONSTRAINTS
                        - EMS_CAPABILITY_BATTERY_DISCHARGE
        '403': *ref_11
        '404': *ref_83
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/ems-capabilities",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/systems/%7BsystemID%7D/ems-capabilities",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/ems-capabilities")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/live':
    get:
      summary: Retrieve System's Live Measurement.
      description: Retrieves a system's latest aggregated measurement.
      tags:
        - System
      security:
        - BearerAuth:
            - SystemMeasurementsRead
      parameters:
        - *ref_74
      responses:
        '200':
          description: Successfully returned system's live measurements.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_165
                title: Measurement
                type: object
                properties:
                  measuredAt:
                    type: string
                    format: date-time
                    example: '2018-04-01T00:10:00Z'
                    description: >
                      Date and time at which the data point was observed.

                      For power values the data point is written after the
                      aggregated 

                      time span. For energy values the observation is stored at
                      the 

                      beginning of the aggregated time span.
                  grid:
                    type: number
                    format: double
                    description: >
                      Grid is the measured power/energy at the grid connection
                      point.


                      For power values, Positive values indicate supply,
                      Negative values

                      indicate feed in.
                  gridL1:
                    type: number
                    format: double
                    description: >
                      GridL1 is the power/energy measured at the grid connection
                      point's 

                      first phase.
                  gridL2:
                    type: number
                    format: double
                    description: >
                      GridL2 is the power/energy measured at the grid connection
                      point's 

                      second phase.
                  gridL3:
                    type: number
                    format: double
                    description: >
                      GridL3 is the power/energy measured at the grid connection
                      point's 

                      third phase.
                  gridSupplyLimit:
                    type: number
                    format: double
                    description: >
                      GridSupplyLimit is the restriction of supplied power at
                      the grid

                      connection point.
                  photovoltaic:
                    type: number
                    format: double
                    description: |
                      Photovoltaic is the measured power/energy in front of the
                      photovoltaic systems.
                  photovoltaicExternal:
                    type: number
                    format: double
                    description: >
                      PhotovoltaicExternal is the measured power/energy in front
                      of the

                      external photovoltaic systems.
                  blockTypeThermalPowerStation:
                    type: number
                    format: double
                    description: >
                      BTTPPower is the measured power for the block-type thermal
                      power

                      station.
                  fuelCell:
                    type: number
                    format: double
                    description: >
                      FuelCell is the measured power/energy in front of the fuel
                      cells.
                  production:
                    type: number
                    format: double
                    description: Sum of all energy producing appliances (e.g. PV).
                  battery: &ref_153
                    title: Battery Measurement
                    description: >
                      MeasurementBattery represents the aggregated power or
                      energy the gateway

                      measured from a battery.
                    type: object
                    properties:
                      applianceID:
                        type: string
                        description: >
                          ApplianceID is the battery's appliance ID. It is empty
                          for

                          aggregated batteries.
                        example: a7d56cb5-2dac-48d4-952a-6eb75ee0ce18
                      power:
                        type: number
                        format: double
                        description: >
                          Power is the measured power used to charge/discharge
                          the battery.


                          Unit W, Meaning, Positive values indicate discharging.
                          Negative

                          values indicate charging.
                      remainingCharge:
                        type: number
                        format: double
                        description: RemainingCharge is the amount of energy left.
                      capacity:
                        type: number
                        format: double
                        description: Maximum energy the battery can provide in Wh.
                      nominalCapacity:
                        type: number
                        format: double
                        description: Nominal capacity of the battery in Wh.
                      stateOfCharge:
                        type: number
                        format: double
                        description: >
                          State of Charge indicates how full a battery is. Unit
                          Percentage

                          points 0.0-1.0.
                  batteries:
                    type: array
                    description: Battery measurements for each battery in the system.
                    items: *ref_153
                  heatPump:
                    type: number
                    format: double
                    description: |
                      Aggregated measured power/energy for heat pumps.
                  heatPumpExternal:
                    type: number
                    format: double
                    description: >
                      Aggregated measured power/energy for heat pumps that have
                      their own 

                      heat pump tariff.
                  heatPumps:
                    type: array
                    description: Heat pump measurements for each heat pump in the system.
                    items: &ref_445
                      title: Heat pump measurement
                      type: object
                      properties:
                        applianceID:
                          type: string
                        power:
                          type: number
                          format: double
                  heatMeters:
                    type: array
                    description: Heat meter measurements for each heat meter in the system.
                    items: &ref_159
                      title: Heat Meter Measurement
                      description: |
                        Measurement recorded for a heat meter.
                      type: object
                      properties:
                        applianceID:
                          type: string
                        measuredAt:
                          type: string
                          format: date-time
                          description: Time when the data was measured.
                          example: '2018-04-01T00:00:00Z'
                        flowRate:
                          type: number
                          format: double
                          description: Volumetric flow rate given in m³/s.
                          example: 0.9
                        readingPositive:
                          type: number
                          format: double
                          description: >
                            Energy meter reading that was gained during
                            circulation from 

                            inflow to outflow in Wh.
                          example: 2000
                        readingNegative:
                          type: number
                          format: double
                          description: >
                            Energy meter reading that was consumed during
                            circulation from 

                            inflow to outflow in Wh.
                          example: 1000
                        power:
                          type: number
                          format: double
                          description: Current power in W.
                          example: 671.2
                        inflowTemperature:
                          type: number
                          format: double
                          description: Inflow temperature measured in °C.
                          example: 26.1
                        outflowTemperature:
                          type: number
                          format: double
                          description: Outflow temperature measured in °C.
                          example: 30
                  evChargingStation: &ref_154
                    title: >
                      MeasurementEVStation represents the power or energy the
                      gateway measured

                      from a ev charging station
                    type: object
                    properties:
                      applianceID:
                        type: string
                        description: gridX API internal ID of the appliance.
                        example: a7d56cb5-2dac-48d4-952a-6eb75ee0ce18
                      power:
                        type: number
                        format: double
                        description: >
                          Measured power used to charge/discharge via EV
                          station,

                          positive values indicate charging, negatives
                          discharging.
                      stateOfCharge:
                        type: number
                        format: double
                        description: >
                          Percentage of the EVs battery capacity charged
                          (0.0-1.0).
                      readingTotal:
                        type: number
                        format: double
                        description: The sum of all meter readings in Wh.
                      readingTariff1:
                        type: number
                        format: double
                        description: The meter reading of meter tariff 1 in Wh.
                      readingTariff2:
                        type: number
                        format: double
                        description: The meter reading of meter tariff 2 in Wh.
                      plugState:
                        type: string
                        description: >-
                          Defines whether this EV is currently plugged in the
                          charging station and whether it's charging.
                      currentL1:
                        type: number
                        format: double
                        description: Current of the first phase in Ampere.
                      currentL2:
                        type: number
                        format: double
                        description: Current of the second phase in Ampere.
                      currentL3:
                        type: number
                        format: double
                        description: Current of the third phase in Ampere.
                  evChargingStations:
                    type: array
                    description: >
                      Charging station measurements for all charging stations
                      that are 

                      part of the system.
                    items: *ref_154
                  consumption:
                    type: number
                    format: double
                    description: Adjusted power/energy of the system.
                  totalConsumption:
                    type: number
                    format: double
                    description: |
                      Adjusted power/energy of the system including heatpumps
                      and EV charging stations.
                  selfConsumption:
                    type: number
                    format: double
                    description: >
                      Power/Energy consumed through production and charged into
                      battery.
                  directConsumption:
                    type: number
                    format: double
                    description: |
                      Power/energy consumed through production directly.
                  directConsumptionHousehold:
                    type: number
                    format: double
                    description: >
                      Power/energy consumed by the household through production
                      directly.
                  directConsumptionHeatPump:
                    type: number
                    format: double
                    description: >
                      Power/energy consumed by the heat pump through production
                      directly.
                  directConsumptionEV:
                    type: number
                    format: double
                    description: >
                      Power/energy consumed by the EV through production
                      directly.
                  directConsumptionHeater:
                    type: number
                    format: double
                    description: >
                      Power/energy consumed by the heater through production
                      directly.
                  selfSupply:
                    type: number
                    format: double
                    description: |
                      Power/energy consumed through storage and production.
                  selfSufficiencyRate:
                    type: number
                    format: double
                    description: >
                      Ratio of produced energy vs total consumed energy
                      (0.0-1.0).
                    example: 0.9
                  selfConsumptionRate:
                    type: number
                    format: double
                    description: Ratio of self consumption vs production (0.0-1.0).
                  directConsumptionRate:
                    type: number
                    format: double
                    description: Ratio of direct consumption vs production (0.0-1.0).
                  heating:
                    type: number
                    format: double
                    description: Aggregated power/energy measured for heaters.
                  heatingTemperature:
                    type: number
                    format: double
                    description: Average temperature of the heaters in °C.
                  heaters:
                    type: array
                    description: >
                      Heating measurement for all heaters that are part of the
                      system.
                    items: &ref_155
                      title: Heater Measurement
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: Represents the time when the data was measured.
                        applianceID:
                          type: string
                          description: Unique identifier for referencing a heater.
                        power:
                          type: number
                          format: double
                          description: Power consumed by the heater in W.
                        powerL1:
                          type: number
                          format: int64
                          description: >-
                            Power consumed by the heater on the first phase in
                            W.
                        powerL2:
                          type: number
                          format: int64
                          description: >-
                            Power consumed by the heater on the second phase in
                            W.
                        powerL3:
                          type: number
                          format: int64
                          description: >-
                            Power consumed by the heater on the third phase in
                            W.
                        temperature:
                          type: number
                          format: double
                          description: Temperature measured by this heater in °C.
                        minTemperature:
                          type: number
                          format: double
                          description: Minimum temperature measured by this heater in °C.
                        maxTemperature:
                          type: number
                          format: double
                          description: Maximum temperature measured by this heater in °C.
                  appliancePower:
                    type: number
                    format: double
                    description: >
                      Power of the appliances with misc location, empty for
                      energy.
                  appliances:
                    type: array
                    items: &ref_156
                      title: Additional meter appliances
                      description: >
                        Used in installations that have multiple grid meters,
                        e.g. for 

                        multi family homes which a central PV but multiple
                        meters.
                      type: object
                      properties:
                        applianceID:
                          type: string
                          description: gridX API internal identifier of the meter.
                          example: a7d56cb5-2dac-48d4-952a-6eb75ee0ce18
                        power:
                          type: number
                          format: double
                          description: Power/energy measured for this meter in W.
                        kind:
                          type: string
                          description: Kind of the appliance measurement.
                      required:
                        - applianceID
                  gridMeterReadingPositive:
                    type: number
                    format: double
                    description: >
                      Meter reading for grid in Ws (Imported Energy), empty for
                      energy.
                  gridMeterReadingNegative:
                    type: number
                    format: double
                    description: >
                      Meter reading for grid in Ws (Exported Energy), empty for
                      energy.
                  heatPumpMeterReadingPositive:
                    type: number
                    format: double
                    description: >
                      Meter reading for heatpump in Ws (Imported Energy), empty
                      for 

                      energy.
                  heatPumpMeterReadingNegative:
                    type: number
                    format: double
                    description: >
                      Meter Reading for heatpump in Ws (Exported Energy), empty
                      for 

                      energy.
                  windTurbine:
                    type: number
                    format: double
                  fuelCellMeterReadingPositive:
                    type: number
                    format: double
                    description: Meter reading for FuelCell in Ws (Imported Energy).
                  fuelCellMeterReadingNegative:
                    type: number
                    format: double
                    description: Meter reading for FuelCell in Ws (Exported Energy).
                  l1CurtailmentPower:
                    type: number
                    format: double
                    description: >
                      Potential max. charging power minus the actual setpoint in
                      Ws on 

                      phase 1.
                  l2CurtailmentPower:
                    type: number
                    format: double
                    description: >
                      Potential max. charging power minus the actual setpoint in
                      Ws on 

                      phase 2.
                  l3CurtailmentPower:
                    type: number
                    format: double
                    description: >
                      Potential max. charging power minus the actual setpoint in
                      Ws on 

                      phase 3.
                  fuseProtectionCount:
                    type: integer
                    description: >
                      Number of times the fuse was protected, based on the
                      curtailed power

                      over all phases.
        '403': *ref_11
        '404': &ref_158
          description: Entity Not found.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/live");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/live");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/live\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/live")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/live")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/live",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/systems/%7BsystemID%7D/live");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/live",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/live",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/live',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/live");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/live"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/live" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/live",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/live');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/live');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/systems/%7BsystemID%7D/live", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/systems/%7BsystemID%7D/live"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/systems/%7BsystemID%7D/live")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/systems/%7BsystemID%7D/live \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/systems/%7BsystemID%7D/live \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/systems/%7BsystemID%7D/live
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/live")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/systems/{systemID}/historical':
    get:
      summary: Historical Measurements for Systems
      description: |
        Lists aggregated measurements of a system over a period of time.

        System measurements are the result of incorporating measurements from 
        all appliances that are part of a system. This allows computing e.g. 
        overall consumption adding producers (e.g. PV) and subtracting consumers
        (e.g. EV charging stations). This aggregation is performed in various 
        resolutions to suit different use cases. See the 'resolution' parameter
        for a list of options.

        Depending on the resolution parameter, the response contains either
        power or energy measurements (unless otherwise documented):
        - **power** (unit: W): `15m`, `1h`
        - **energy** (unit: Wh): `1d`, `1w`, `1M`, `1y`

        Measurements are "aligned" differently whether they contain energy or
        power measurements:
        - For power values the data point is written after the aggregated time 
          span. For the interval 2018-04-01T00:00:00Z/2018-04-02T00:00:00Z
          with resolution 15m the first observation will be recorded at 
          2018-04-01T00:15:00Z
        - For energy values the observation is stored at the beginning of 
          the aggregated time span. For the interval 
          2018-04-01T00:00:00Z/2018-04-05T00:00:00Z and resolution 1d the first 
          observation will be recorded at 2018-04-01T00:00:00Z

        The `total` object of the response contains an aggregation of the 
        individual data points over time and therefore is an energy value.
        The `total.measuredAt` field is an interval containing all data points 
        in the requested interval.

        In order to reduce the duration of the endpoint, the gridX API imposes 
        limitations on the interval for a given resolution:

        | Resolution | Limit                   |
        |------------|-------------------------|
        | 15m        | intervals up to 1 day   |
        | 1h         | intervals up to 1 week  |
        | 1d         | intervals up to 1 month |
        | 1w         | intervals up to 1 month |
        | 1M         | intervals up to 5 years |
        | 1y         | no limit                |
      tags:
        - System
      security:
        - BearerAuth:
            - SystemMeasurementsRead
      parameters:
        - *ref_74
        - *ref_119
        - &ref_186
          name: resolution
          description: >
            Requested resolution, formatted in ISO8601 units.


            In this format the resolution is formatted with a single number and
            corresponding

            ISO8601 date or time unit.
          in: query
          example: 1h
          schema:
            type: string
            default: 1h
            enum:
              - 15m
              - 1h
              - 1d
              - 1w
              - 1M
      responses:
        '200':
          description: Successfully returned system's aggregated measurements.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_167
                title: Measurements
                type: object
                properties:
                  total:
                    allOf:
                      - &ref_157
                        title: Extended Measurement
                        type: object
                        properties:
                          measuredAt:
                            type: string
                            description: Time when the data was measured.
                          gridL1:
                            type: number
                            format: double
                            description: >-
                              GridL1 is the part of the grid connection point's
                              first phase.
                          gridL2:
                            type: number
                            format: double
                            description: >-
                              GridL2 is the part of the grid connection point's
                              second phase.
                          gridL3:
                            type: number
                            format: double
                            description: >-
                              GridL3 is the part of the grid connection point's
                              second phase.
                          gridSupplyLimit:
                            type: number
                            format: double
                            description: >
                              GridSupplyLimit is the restriction of supplied
                              power at the grid

                              connection point.
                          photovoltaic:
                            type: number
                            format: double
                            description: >
                              Photovoltaic is the measured power/energy in front
                              of the

                              photovoltaic systems.
                          photovoltaicExternal:
                            type: number
                            format: double
                            description: >
                              PhotovoltaicExternal is the measured power/energy
                              in front of the

                              external photovoltaic systems.
                          blockTypeThermalPowerStation:
                            type: number
                            format: double
                            description: >
                              BTTPPower is the measured power for the block-type
                              thermal power

                              station.
                          fuelCell:
                            type: number
                            format: double
                            description: >-
                              FuelCell is the measured power/energy in front of
                              the fuel cells.
                          production:
                            type: number
                            format: double
                            description: Production is sum of the producers.
                          batteries:
                            type: array
                            items: *ref_153
                          heatPump:
                            type: number
                            format: double
                            description: >-
                              HeatPump is the measured power/energy in front of
                              the heat pumps.
                          heatPumpExternal:
                            type: number
                            format: double
                            description: >
                              HeatPumpExternal is the measured power/energy in
                              front of the heat

                              pump which has its own heat pump tariff.
                          evChargingStations:
                            type: array
                            items: *ref_154
                          consumption:
                            type: number
                            format: double
                            description: >-
                              Consumption is adjusted power/energy of the
                              system.
                          totalConsumption:
                            type: number
                            format: double
                            description: |
                              Adjusted power/energy of the system which
                              includes heatpump and EV.
                          selfConsumption:
                            type: number
                            format: double
                            description: >
                              SelfConsumption is power/energy consumed through
                              production and

                              charged into battery.
                          directConsumption:
                            type: number
                            format: double
                            description: >
                              DirectConsumption is power/energy consumed from
                              production directly.
                          directConsumptionHousehold:
                            type: number
                            format: double
                            description: >
                              DirectConsumptionHousehold is power/energy
                              consumed by the

                              household through production directly.
                          directConsumptionHeatPump:
                            type: number
                            format: double
                            description: >
                              DirectConsumptionHeatPump is power/energy consumed
                              by the heat pump

                              through production directly.
                          directConsumptionEV:
                            type: number
                            format: double
                            description: >
                              DirectConsumptionEV is power/energy consumed by
                              the EV through

                              production directly.
                          directConsumptionHeater:
                            type: number
                            format: double
                            description: >
                              DirectConsumptionHeater is the power/energy
                              consumed by the heater

                              through production directly.
                          selfSupply:
                            type: number
                            format: double
                            description: >-
                              SelfSupply is power/energy consumed through
                              storage and production.
                          selfSufficiencyRate:
                            type: number
                            format: double
                          selfConsumptionRate:
                            type: number
                            format: double
                          directConsumptionRate:
                            type: number
                            format: double
                          heating:
                            type: number
                            format: double
                            description: >-
                              HeatingPower is the aggregated amount of power
                              measured for heaters.
                          heatingTemperature:
                            type: number
                            format: double
                            description: HeatingTemperature is temperature of the heaters.
                          heaters:
                            type: array
                            description: >
                              Heating measurement for all heaters that are part
                              of the system.
                            items: *ref_155
                          appliancePower:
                            type: number
                            format: double
                            description: >-
                              AppliancePower is power of the appliances with
                              misc location.
                          appliances:
                            type: array
                            items: *ref_156
                          gridMeterReadingPositive:
                            type: number
                            format: double
                            description: >
                              GridMeterReadingPositive is the meter Reading for
                              grid in Ws

                              (Imported Energy).
                          gridMeterReadingNegative:
                            type: number
                            format: double
                            description: >
                              GridMeterReadingPositive is the meter Reading for
                              grid in Ws

                              (Exported Energy).
                          heatPumpMeterReadingPositive:
                            type: number
                            format: double
                            description: >
                              HeatPumpMeterReadingPositive is the meter Reading
                              for HeatPump in Ws

                              (Imported Energy).
                          heatPumpMeterReadingNegative:
                            type: number
                            format: double
                            description: >
                              HeatPumpMeterReadingNegative is the meter Reading
                              for HeatPump in Ws

                              (Exported Energy).
                          windTurbine:
                            type: number
                            format: double
                          fuelCellMeterReadingPositive:
                            type: number
                            format: double
                            description: >-
                              Meter reading for FuelCell in Ws (Imported
                              Energy).
                          fuelCellMeterReadingNegative:
                            type: number
                            format: double
                            description: >-
                              Meter reading for FuelCell in Ws (Exported
                              Energy).
                          l1CurtailmentPower:
                            type: number
                            format: double
                            description: >
                              Potential max. charging power minus the actual
                              setpoint in Ws on phase 1.
                          l2CurtailmentPower:
                            type: number
                            format: double
                            description: >
                              Potential max. charging power minus the actual
                              setpoint in Ws on phase 2.
                          l3CurtailmentPower:
                            type: number
                            format: double
                            description: >
                              Potential max. charging power minus the actual
                              setpoint in Ws on phase 3.
                          fuseProtectionCount:
                            type: integer
                            minimum: 0
                            description: >
                              Number of times the fuse was protected, based on
                              the curtailed power over all phases.
                          grid: &ref_442
                            title: Measurement Grid
                            type: object
                            properties:
                              measuredAt:
                                type: string
                                format: date-time
                                description: Time when the data was measured.
                              feedIn:
                                type: number
                                format: double
                              supply:
                                type: number
                                format: double
                              supplyLimit:
                                type: number
                                format: double
                              meterReading: &ref_443
                                title: Measurement Grid Meter Reading
                                type: object
                                properties:
                                  feedIn:
                                    type: number
                                    format: double
                                  supply:
                                    type: number
                                    format: double
                          battery: &ref_440
                            title: Extended Battery Measurement
                            type: object
                            properties:
                              charge:
                                type: number
                                format: double
                                description: Power/energy charged to the battery.
                              discharge:
                                type: number
                                format: double
                                description: Power/energy discharged from the battery.
                              stateOfCharge:
                                type: number
                                format: double
                                description: >
                                  Percentage of battery capacity charged
                                  (0.0-1.0).
                              capacity:
                                type: number
                                format: double
                                description: >
                                  Capacity is the maximum energy the battery can
                                  provide in Wh.
                              nominalCapacity:
                                type: number
                                format: double
                                description: >
                                  NominalCapacity is the nominal capacity of
                                  battery in Wh.
                          evChargingStation: &ref_441
                            title: Extended EV Station Measurement
                            type: object
                            properties:
                              charge:
                                type: number
                                format: double
                                description: The measured charging power of the EV.
                              discharge:
                                type: number
                                format: double
                                description: Power/energy discharged from the EV.
                              stateOfCharge:
                                type: number
                                format: double
                                description: Percentage of EV battery charged (0.0-1.0).
                              currentL1:
                                type: number
                                format: double
                                description: >
                                  Current on the first phase of the EV station
                                  in A (ampere).
                              currentL2:
                                type: number
                                format: double
                                description: >-
                                  Current on the second phase of the EV station
                                  in A.
                              currentL3:
                                type: number
                                format: double
                                description: >-
                                  Current on the third phase of the EV station
                                  in A.
                      - properties:
                          measuredAt:
                            description: >
                              Interval containing all data points in the
                              requested interval formatted in ISO8601.
                            type: string
                            example: '2018-04-01T00:00:00Z/2018-04-05T00:00:00Z'
                        type: object
                  data:
                    type: array
                    items:
                      allOf:
                        - *ref_157
                        - properties:
                            measuredAt:
                              format: date-time
        '403': *ref_11
        '404': *ref_158
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/systems/%7BsystemID%7D/historical',
              qs: {interval: 'SOME_STRING_VALUE', resolution: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/systems/%7BsystemID%7D/historical");


            req.query({
              "interval": "SOME_STRING_VALUE",
              "resolution": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/systems/%7BsystemID%7D/historical');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE',
              'resolution' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/systems/%7BsystemID%7D/historical');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE',
              'resolution' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/systems/%7BsystemID%7D/historical"


            querystring =
            {"interval":"SOME_STRING_VALUE","resolution":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/systems/%7BsystemID%7D/historical?interval=SOME_STRING_VALUE&resolution=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}/measurements/appliance':
    get:
      summary: List Appliance's Raw Measurements
      description: |
        Lists raw measurements of an appliance over a period of time.

        The provided `interval` must not span more than 24 hours.

        The resolution cannot be controlled. The granularity at which we store
        measurements varies from appliance to appliance, firmware and 
        configuration.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - ApplianceMeasurementsRead
      parameters:
        - *ref_75
        - *ref_54
        - *ref_119
      responses:
        '200':
          description: Returned raw measurement.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items:
                  oneOf:
                    - *ref_153
                    - &ref_161
                      title: Inverter's Measurements
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: Time when the data was measured.
                        gridFrequency:
                          type: integer
                          format: int32
                          description: >-
                            The locally measured grid frequency in centi (10^-2)
                            Hz.
                        acCurrent:
                          type: integer
                          format: int32
                          description: AC current in mA.
                        l1ACCurrent:
                          type: integer
                          format: int32
                          description: AC current on phase L1 in mA.
                        l2ACCurrent:
                          type: integer
                          format: int32
                          description: AC current on phase L2 in mA.
                        l3ACCurrent:
                          type: integer
                          format: int32
                          description: AC current on phase L3 in mA.
                        l1ACVoltage:
                          type: integer
                          format: int32
                          description: AC voltage on phase L1 in mV.
                        l2ACVoltage:
                          type: integer
                          format: int32
                          description: AC voltage on phase L2 in mV.
                        l3ACVoltage:
                          type: integer
                          format: int32
                          description: AC voltage on phase L3 mV.
                        acActivePower:
                          type: integer
                          format: int32
                          description: AC active power in mW.
                        acReactivePower:
                          type: integer
                          format: int32
                          description: AC reactive power in VAr.
                        acApparentPower:
                          type: integer
                          format: int32
                          description: AC apparent power VA.
                        dcCurrent:
                          type: integer
                          format: int32
                          description: DC current in mA.
                        dcVoltage:
                          type: integer
                          format: int32
                          description: DC voltage in mV.
                        dcPower:
                          type: integer
                          format: int32
                          description: DC power in mW.
                        kind:
                          type: integer
                          format: int32
                          description: >
                            Inverter kind describes if the inverter is used as
                            PV, battery, or

                            hybrid inverter.
                        totalEnergyYield:
                          type: integer
                          format: int64
                          description: Total amount of transformed energy in Wh.
                        internalEnergyUse:
                          type: integer
                          format: int32
                          description: Energy used by the inverter internally in Wh.
                    - &ref_162
                      title: Meter's Measurement
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: Time when the data was measured.
                        l1ActivePower:
                          type: integer
                          format: int64
                          description: L1 Active Power in mW.
                        l1ActivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: L1 Active Power Reading (Imported Energy) in Ws.
                        l1ActivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: L2 Active Power Reading (Exported Energy) in Ws.
                        l1ReactivePower:
                          type: integer
                          format: int64
                          description: L1 Reactive Power in VAr.
                        l1ReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: L1 Reactive Power Reading (Imported Energy) in VArs.
                        l1ReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: L1 Reactive Power Reading (Exported Energy) in VArs.
                        l1ApparentPower:
                          type: integer
                          format: int64
                          description: L1 Apparent Power in VA.
                        l1ApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          description: L1 Apparent Power Reading (Imported Energy) in VAs.
                        l1ApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          description: L1 Apparent Power Reading (Exported Energy) in VAs.
                        l1Current:
                          type: integer
                          format: int32
                          description: L1 Current in mA.
                        l1Voltage:
                          type: integer
                          format: int32
                          description: L1 Voltage in mV.
                        l1ImportPowerLimit:
                          type: integer
                          format: int64
                          description: L1 maximum imported power in mW.
                        l2ActivePower:
                          type: integer
                          format: int64
                          description: L2 Active Power in mW.
                        l2ActivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: L2 Active Power Reading (Imported Energy) in Ws.
                        l2ActivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: L2 Active Power Reading (Exported Energy) in Ws.
                        l2ReactivePower:
                          type: integer
                          format: int64
                          description: L2 Reactive Power in VAr.
                        l2ReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: L2 Reactive Power Reading (Imported Energy) in VArs.
                        l2ReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: L2 Reactive Power Reading (Exported Energy) in VArs.
                        l2ApparentPower:
                          type: integer
                          format: int64
                          description: L2 Apparent Power in VA.
                        l2ApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          description: L2 Apparent Power Reading (Imported Energy) in VAs.
                        l2ApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          description: L2 Apparent Power Reading (Exported Energy) in VAs.
                        l2Current:
                          type: integer
                          format: int32
                          description: L2 Current in mA.
                        l2Voltage:
                          type: integer
                          format: int32
                          description: L2 Voltage in mV.
                        l2ImportPowerLimit:
                          type: integer
                          format: int64
                          description: L2 maximum imported power in mW.
                        l3ActivePower:
                          type: integer
                          format: int64
                          description: L3 Active Power in mW.
                        l3ActivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: L3 Active Power Reading (Imported Energy) in Ws.
                        l3ActivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: L3 Active Power Reading (Exported Energy) in Ws.
                        l3ReactivePower:
                          type: integer
                          format: int64
                          description: L3 Reactive Power in VAr.
                        l3ReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: L3 Reactive Power Reading (Imported Energy) in VArs.
                        l3ReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: L3 Reactive Power Reading (Exported Energy) in VArs.
                        l3ApparentPower:
                          type: integer
                          format: int64
                          description: L3 Apparent Power in VA.
                        l3ApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          description: L3 Apparent Power Reading (Imported Energy) in VAs.
                        l3ApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          description: L3 Apparent Power Reading (Exported Energy) in VAs.
                        l3Current:
                          type: integer
                          format: int32
                          description: L3 Current in mA.
                        l3Voltage:
                          type: integer
                          format: int32
                          description: L3 Voltage in mV.
                        l3ImportPowerLimit:
                          type: integer
                          format: int64
                          description: L3 maximum imported power in mW.
                        sumActivePower:
                          type: integer
                          format: int64
                          description: Sum Active Power in mW.
                        sumActivePowerReadingPositive:
                          type: integer
                          format: int64
                          description: Sum Active Power Reading (Imported Energy) in Ws.
                        sumActivePowerReadingNegative:
                          type: integer
                          format: int64
                          description: Sum Active Power Reading (Exported Energy) in Ws.
                        sumApparentPower:
                          type: integer
                          format: int64
                          description: Sum Apparent Power in VA.
                        sumApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          description: Sum Apparent Power Reading (Imported Energy) in VAs.
                        sumApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          description: Sum Apparent Power Reading (Exported Energy) in VAs.
                        sumImportPowerLimit:
                          type: integer
                          format: int64
                          description: Sum Maximum imported power in mW.
                        sumPowerFactor:
                          type: integer
                          format: int32
                          description: Power factor in deg.
                    - &ref_163
                      title: EV Charging Station's Measurement
                      type: object
                      properties:
                        measuredTimestamp:
                          type: string
                          format: date-time
                          description: Date and time the data point was collected.
                        l1Voltage:
                          type: integer
                          format: int32
                          description: Voltage for first phase in mW.
                        l2Voltage:
                          type: integer
                          format: int32
                          description: Voltage for second phase in mW.
                        l3Voltage:
                          type: integer
                          format: int32
                          description: Voltage for third phase in mW.
                        l1Current:
                          type: integer
                          format: int32
                          description: Current for first phase in mA.
                        l2Current:
                          type: integer
                          format: int32
                          description: Current for second phase in mA.
                        l3Current:
                          type: integer
                          format: int32
                          description: Current for third phase in mA.
                        realPower:
                          type: integer
                          format: int64
                          description: >
                            Real Power in mW. Positive values mean charging,
                            negative values

                            mean discharging (V2G; currently not done).
                        powerFactor:
                          type: integer
                          format: int32
                          description: Power Factor in 0.1% (cosphi).
                        realPowerL1:
                          type: integer
                          format: int64
                          description: Real Power L1 in mW.
                        realPowerL2:
                          type: integer
                          format: int64
                          description: Real Power L2 in mW.
                        realPowerL3:
                          type: integer
                          format: int64
                          description: Real Power L3 in mW.
                        temperature:
                          type: integer
                          format: int64
                          description: Temperature inside the charging station in °C.
                        capacity:
                          type: integer
                          format: int32
                          description: The total capacity of the EV battery in Wh.
                        stateOfCharge:
                          type: number
                          format: double
                          description: >
                            The current state of charge of the EV battery in
                            percent from 0.0 -

                            100.0%.
                        maxCharge:
                          type: integer
                          format: int32
                          description: Maximum allowed charge power in mW.
                        minCharge:
                          type: integer
                          format: int32
                          description: >
                            Minimum allowed charge power in mW, below this power
                            the EV won't

                            charge.
                        maxDischarge:
                          type: integer
                          format: int32
                          description: Maximum allowed discharge power in mW.
                        stationState:
                          type: string
                          description: >
                            State indicating whether the charging station is
                            charging, ready, in

                            error state, etc.
                        plugState:
                          type: string
                          description: >
                            State indicates whether an EV is plugged into the
                            charging station.
                        pluggedIn:
                          type: boolean
                          description: >
                            PluggedIn true if an electric vehicle is currently
                            plugged into the

                            charging station.
                        tokenId:
                          type: string
                          description: >
                            TokenID is the used authentication token at the
                            charging station.
                    - *ref_159
                    - &ref_160
                      title: Electrolyzer Measurement
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: Time when the data was measured.
                        status:
                          type: integer
                          format: int32
                          description: Status is the local mode of the electrolyzer.
                        statusPurification:
                          type: boolean
                          description: >-
                            StatusPurification is the purification status of the
                            electrolyzer. 0 means no regeneration is in
                            progress.
                        flowSetpoint:
                          type: number
                          format: float
                          description: Flow Setpoint value set by the customer in Nm3/h.
                        hydrogenFlow:
                          type: number
                          format: float
                          description: Hydrogen Flow leaving the electrolyzer in Nm3/h.
                        pressure:
                          type: number
                          format: float
                          description: Pressure in the electrolyzer in barg.
                        rectifierEnergy1:
                          type: number
                          format: float
                          description: Rectifier Energy at 400V in kW.
                        rectifierEnergy2:
                          type: number
                          format: float
                          description: Rectifier Energy at 21KV in kW.
                        bufferPressure:
                          type: number
                          format: float
                          description: Buffer Pressure of the Electrolyzer in barg.
                        productionTime:
                          type: number
                          format: float
                          description: Production Time in hours.
                        timeUntilMaintenance:
                          type: number
                          format: float
                          description: Time until maintenance in hours.
                        pipelinePressure:
                          type: number
                          format: float
                          description: Pipeline pressure in bar.
                        customerHydrogenFlow1:
                          type: number
                          format: float
                          description: Hydrogen flow in Nm3/h provided by the customer.
                        customerHydrogenFlow2:
                          type: number
                          format: float
                          description: >-
                            Hydrogen flow in Nm3/h provided by an additional
                            customer.
                        customerHydrogenFlow3:
                          type: number
                          format: float
                          description: >-
                            Hydrogen flow in Nm3/h provided by an additional
                            customer.
                        customerHydrogenFlow4:
                          type: number
                          format: float
                          description: >-
                            Hydrogen flow in Nm3/h provided by an additional
                            customer.
                        customerHydrogenFlow5:
                          type: number
                          format: float
                          description: >-
                            Hydrogen flow in Nm3/h provided by an additional
                            customer.
                      required:
                        - measuredAt
        '403': *ref_11
        '404': *ref_158
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance',
              qs: {interval: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance"


            querystring = {"interval":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Write Appliance Measurements
      tags:
        - Appliance
      security:
        - BearerAuth:
            - ApplianceMeasurementsWrite
      parameters:
        - *ref_75
        - *ref_54
      requestBody:
        description: >-
          Create appliance raw measurement that can be retrieved via the
          [appliance
          measurements](https://developer.gridx.ai/reference/get_gateways-gatewayid-appliances-applianceid-measurements-appliance-1)
          and influences the [system
          measurements](https://developer.gridx.ai/reference/get_systems-systemid-historical)
          endpoints.
        required: true
        content:
          application/json:
            schema:
              allOf:
                - oneOf:
                    - &ref_446
                      title: A raw measurement produced by an inverter.
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: >-
                            Time when the data was measured in UTC using the
                            RFC3339 format.
                        gridFrequency:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Grid frequency in centi (10^-2) Hz.
                        acCurrent:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC current in mA.
                        l1ACCurrent:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC current for the first phase in mA.
                        l2ACCurrent:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC current for the second phase in mA.
                        l3ACCurrent:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC current for the third phase in mA.
                        l1ACVoltage:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC voltage for the first phase in mV.
                        l2ACVoltage:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC voltage for the second phase in mV.
                        l3ACVoltage:
                          type: integer
                          format: int32
                          minimum: 0
                          description: AC voltage for the third phase in mV.
                        acActivePower:
                          type: integer
                          format: int32
                          description: AC active power in mW.
                        acReactivePower:
                          type: integer
                          format: int32
                          description: AC reactive power in mW.
                        acApparentPower:
                          type: integer
                          format: int32
                          description: AC apparent power in mW.
                        dcCurrent:
                          type: integer
                          format: int32
                          minimum: 0
                          description: DC current in mA.
                        dcVoltage:
                          type: integer
                          format: int32
                          minimum: 0
                          description: DC current in mV.
                        dcPower:
                          type: integer
                          format: int32
                          description: DC current in mW.
                    - &ref_447
                      title: A measurement produced by a battery (inverter).
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: >-
                            Time when the data was measured in UTC using RFC3339
                            format.
                        capacity:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Capacity in Wh.
                        nominalCapacity:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Nominal capacity in Wh.
                        stateOfCharge:
                          type: integer
                          format: int32
                          minimum: 0
                          description: 'Value in range 0-100, state of charge in percent.'
                        stateOfHealth:
                          type: integer
                          format: int32
                          minimum: 0
                          description: >-
                            Value in range 0-100, health of the battery in
                            percent.
                        temperature:
                          type: integer
                          format: int32
                          description: Temperature of the battery in degrees Celsius.
                        presentCharge:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Current charge of the battery in mW.
                        presentDischarge:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Current discharge of the battery in mW.
                    - &ref_448
                      title: A measurement produced by a grid meter.
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: >-
                            Time when the data was measured in UTC using RFC3339
                            format.
                        l1ActivePower:
                          type: integer
                          format: int64
                          description: Active power for the first phase in mW.
                        l1ActivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                          description: >-
                            Active power reading for the first phase in Ws
                            (imported).
                        l1ActivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                          description: >-
                            Active power reading for the first phase in Ws
                            (exported).
                        l1ReactivePower:
                          type: integer
                          format: int64
                          description: Reactive power in VAr for the first phase.
                        l1ReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                          description: >-
                            Reactive power reading (imported energy) in VArs for
                            the first phase .
                        l1ReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                          description: >-
                            Reactive power reading (exported energy) in VArs for
                            the first phase.
                        l1ApparentPower:
                          type: integer
                          format: int64
                          description: Apparent power for the first phase in VA.
                        l1ApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                          description: >-
                            Apparent power reading (imported energy) in VAs for
                            the first phase.
                        l1ApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                          description: >-
                            Apparent power reading (imported energy) in VAs for
                            the second phase.
                        l1Current:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Current for the first phase in mA.
                        l1Voltage:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Voltage at the first phase in mV.
                        l1ImportPowerLimit:
                          type: integer
                          format: int64
                          description: Maximum imported power for the first phase in mW.
                        l2ActivePower:
                          type: integer
                          format: int64
                        l2ActivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        l2ActivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        l2ReactivePower:
                          type: integer
                          format: int64
                        l2ReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        l2ReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        l2ApparentPower:
                          type: integer
                          format: int64
                        l2ApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        l2ApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        l2Current:
                          type: integer
                          format: int64
                          minimum: 0
                        l2Voltage:
                          type: integer
                          format: int64
                          minimum: 0
                        l2ImportPowerLimit:
                          type: integer
                          format: int64
                        l3ActivePower:
                          type: integer
                          format: int64
                        l3ActivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        l3ActivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        l3ReactivePower:
                          type: integer
                          format: int64
                        l3ReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        l3ReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        l3ApparentPower:
                          type: integer
                          format: int64
                        l3ApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        l3ApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        l3Current:
                          type: integer
                          format: int64
                          minimum: 0
                        l3Voltage:
                          type: integer
                          format: int64
                          minimum: 0
                        l3ImportPowerLimit:
                          type: integer
                          format: int64
                        sumActivePower:
                          type: integer
                          format: int64
                        sumActivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        sumActivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        sumReactivePower:
                          type: integer
                          format: int64
                        sumReactivePowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        sumReactivePowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        sumApparentPower:
                          type: integer
                          format: int64
                        sumApparentPowerReadingPositive:
                          type: integer
                          format: int64
                          minimum: 0
                        sumApparentPowerReadingNegative:
                          type: integer
                          format: int64
                          minimum: 0
                        sumImportPowerLimit:
                          type: integer
                          format: int64
                        sumPowerFactor:
                          type: integer
                          format: int64
                          minimum: 0
                    - &ref_449
                      title: A measurement produced by an EV charging station.
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: Time when the data was measured.
                        l1Voltage:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Voltage at the first phase in mV.
                        l2Voltage:
                          type: integer
                          format: int32
                          minimum: 0
                        l3Voltage:
                          type: integer
                          format: int32
                          minimum: 0
                        l1Current:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Current for the first phase in mA.
                        l2Current:
                          type: integer
                          format: int32
                          minimum: 0
                        l3Current:
                          type: integer
                          format: int32
                          minimum: 0
                        realPower:
                          type: integer
                          format: int64
                          description: >-
                            Real power in mW (positive values indicate charging,
                            negative discharging).
                        l1RealPower:
                          type: integer
                          format: int64
                          description: Real power for the first phase in mW.
                        l2RealPower:
                          type: integer
                          format: int64
                        l3RealPower:
                          type: integer
                          format: int64
                        powerFactor:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Power factor in 0.1% (cosphi).
                        stateOfCharge:
                          type: number
                          format: double
                          description: State of charge of the vehicle in percent.
                        capacity:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Capacity of the vehicle in Wh.
                        maxCharge:
                          type: integer
                          format: int32
                          minimum: 0
                          description: Maximum allowed charge power in mW.
                        minCharge:
                          type: number
                          format: double
                          description: Minimum allowed charge power in mW.
                        maxDischarge:
                          type: integer
                          format: int32
                          minimum: 0
                        stationState:
                          type: string
                          default: UNKNOWN
                          enum:
                            - UNKNOWN
                            - NOT_READY
                            - READY
                            - CHARGING
                            - CHARGING_INTERRUPTED
                            - ERROR
                        plugState:
                          type: string
                          default: UNPLUGGED
                          enum:
                            - UNPLUGGED
                            - PLUGGED_ON_STATION
                            - PLUGGED_ON_STATION_AND_PLUGGED_ON_VEHICLE
                        pluggedIn:
                          type: integer
                          format: int64
                          minimum: 0
                        tokenID:
                          type: string
                          description: Used authentication token at the charging station.
                    - &ref_450
                      title: A measurement produced by a heater appliance.
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: >-
                            Time when the data was measured in UTC using RFC3339
                            format.
                        power:
                          type: number
                          format: double
                          description: Power in mW.
                        powerL1:
                          type: integer
                          format: int64
                          minimum: 0
                          description: Power for the first phase in mW.
                        powerL2:
                          type: integer
                          format: int64
                          minimum: 0
                        powerL3:
                          type: integer
                          format: int64
                          minimum: 0
                        temperature:
                          type: number
                          format: double
                          description: Temperature in degrees Celsius.
                        minTemperature:
                          type: number
                          format: double
                        maxTemperature:
                          type: number
                          format: double
                    - &ref_451
                      title: A measurement produced by a heatpump appliance.
                      type: object
                      properties:
                        measuredAt:
                          type: string
                          format: date-time
                          description: >-
                            Time when the data was measured in UTC using RFC3339
                            format.
                        power:
                          type: integer
                          format: int64
                          description: Power of the heatpump in mW.
                        powerL1:
                          type: integer
                          format: int64
                          description: Power for the first phase in mW .
                        powerL2:
                          type: integer
                          format: int64
                        powerL3:
                          type: integer
                          format: int64
                        minPower:
                          type: integer
                          format: int64
                        maxPower:
                          type: integer
                          format: int64
                        readyState:
                          type: string
                          default: UNKNOWN
                          enum:
                            - UNKNOWN
                            - 'OFF'
                            - AUTO
                            - RECOMMEND_ON
                            - 'ON'
                        averageTemperature:
                          type: number
                          format: double
                        controlledTemperature:
                          type: number
                          format: double
                        baseLineTemperature:
                          type: number
                          format: double
                        heatSourceTemperature:
                          type: number
                          format: double
                        outdoorTemperature:
                          type: number
                          format: double
                        operationStatus:
                          type: string
                          default: UNKNOWN
                          enum:
                            - UNKNOWN
                            - HEATING
                            - DRINKING_HOT_WATER
                            - POOL_HEATING
                            - EVU_LOCK
                            - DEFROST
                            - 'OFF'
                            - EXTERNAL_SOURCE
                            - COOLING
                        energyHeating:
                          type: number
                          format: double
                        energyDrinkingHotWater:
                          type: number
                          format: double
                    - *ref_159
                    - *ref_160
                - additionalProperties: false
      responses:
        '200':
          description: Measurement written successfully.
        '400':
          description: The request body did not match the required format.
        '403': *ref_11
        '404': *ref_158
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance\"\n\n\tpayload := strings.NewReader(\"{\\\"measuredAt\\\":\\\"2019-08-24T14:15:22Z\\\",\\\"gridFrequency\\\":0,\\\"acCurrent\\\":0,\\\"l1ACCurrent\\\":0,\\\"l2ACCurrent\\\":0,\\\"l3ACCurrent\\\":0,\\\"l1ACVoltage\\\":0,\\\"l2ACVoltage\\\":0,\\\"l3ACVoltage\\\":0,\\\"acActivePower\\\":0,\\\"acReactivePower\\\":0,\\\"acApparentPower\\\":0,\\\"dcCurrent\\\":0,\\\"dcVoltage\\\":0,\\\"dcPower\\\":0}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "measuredAt": "2019-08-24T14:15:22Z",
              "gridFrequency": 0,
              "acCurrent": 0,
              "l1ACCurrent": 0,
              "l2ACCurrent": 0,
              "l3ACCurrent": 0,
              "l1ACVoltage": 0,
              "l2ACVoltage": 0,
              "l3ACVoltage": 0,
              "acActivePower": 0,
              "acReactivePower": 0,
              "acApparentPower": 0,
              "dcCurrent": 0,
              "dcVoltage": 0,
              "dcPower": 0
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              measuredAt: '2019-08-24T14:15:22Z',
              gridFrequency: 0,
              acCurrent: 0,
              l1ACCurrent: 0,
              l2ACCurrent: 0,
              l3ACCurrent: 0,
              l1ACVoltage: 0,
              l2ACVoltage: 0,
              l3ACVoltage: 0,
              acActivePower: 0,
              acReactivePower: 0,
              acApparentPower: 0,
              dcCurrent: 0,
              dcVoltage: 0,
              dcPower: 0
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                measuredAt: '2019-08-24T14:15:22Z',
                gridFrequency: 0,
                acCurrent: 0,
                l1ACCurrent: 0,
                l2ACCurrent: 0,
                l3ACCurrent: 0,
                l1ACVoltage: 0,
                l2ACVoltage: 0,
                l3ACVoltage: 0,
                acActivePower: 0,
                acReactivePower: 0,
                acApparentPower: 0,
                dcCurrent: 0,
                dcVoltage: 0,
                dcPower: 0
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "measuredAt": "2019-08-24T14:15:22Z",
              "gridFrequency": 0,
              "acCurrent": 0,
              "l1ACCurrent": 0,
              "l2ACCurrent": 0,
              "l3ACCurrent": 0,
              "l1ACVoltage": 0,
              "l2ACVoltage": 0,
              "l3ACVoltage": 0,
              "acActivePower": 0,
              "acReactivePower": 0,
              "acApparentPower": 0,
              "dcCurrent": 0,
              "dcVoltage": 0,
              "dcPower": 0
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"measuredAt":
            @"2019-08-24T14:15:22Z",
                                          @"gridFrequency": @0,
                                          @"acCurrent": @0,
                                          @"l1ACCurrent": @0,
                                          @"l2ACCurrent": @0,
                                          @"l3ACCurrent": @0,
                                          @"l1ACVoltage": @0,
                                          @"l2ACVoltage": @0,
                                          @"l3ACVoltage": @0,
                                          @"acActivePower": @0,
                                          @"acReactivePower": @0,
                                          @"acApparentPower": @0,
                                          @"dcCurrent": @0,
                                          @"dcVoltage": @0,
                                          @"dcPower": @0 };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"measuredAt":"2019-08-24T14:15:22Z","gridFrequency":0,"acCurrent":0,"l1ACCurrent":0,"l2ACCurrent":0,"l3ACCurrent":0,"l1ACVoltage":0,"l2ACVoltage":0,"l3ACVoltage":0,"acActivePower":0,"acReactivePower":0,"acApparentPower":0,"dcCurrent":0,"dcVoltage":0,"dcPower":0}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"measuredAt":"2019-08-24T14:15:22Z","gridFrequency":0,"acCurrent":0,"l1ACCurrent":0,"l2ACCurrent":0,"l3ACCurrent":0,"l1ACVoltage":0,"l2ACVoltage":0,"l3ACVoltage":0,"acActivePower":0,"acReactivePower":0,"acApparentPower":0,"dcCurrent":0,"dcVoltage":0,"dcPower":0}');


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance"


            payload = {
                "measuredAt": "2019-08-24T14:15:22Z",
                "gridFrequency": 0,
                "acCurrent": 0,
                "l1ACCurrent": 0,
                "l2ACCurrent": 0,
                "l3ACCurrent": 0,
                "l1ACVoltage": 0,
                "l2ACVoltage": 0,
                "l3ACVoltage": 0,
                "acActivePower": 0,
                "acReactivePower": 0,
                "acApparentPower": 0,
                "dcCurrent": 0,
                "dcVoltage": 0,
                "dcPower": 0
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"measuredAt\":\"2019-08-24T14:15:22Z\",\"gridFrequency\":0,\"acCurrent\":0,\"l1ACCurrent\":0,\"l2ACCurrent\":0,\"l3ACCurrent\":0,\"l1ACVoltage\":0,\"l2ACVoltage\":0,\"l3ACVoltage\":0,\"acActivePower\":0,\"acReactivePower\":0,\"acApparentPower\":0,\"dcCurrent\":0,\"dcVoltage\":0,\"dcPower\":0}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"measuredAt":"2019-08-24T14:15:22Z","gridFrequency":0,"acCurrent":0,"l1ACCurrent":0,"l2ACCurrent":0,"l3ACCurrent":0,"l1ACVoltage":0,"l2ACVoltage":0,"l3ACVoltage":0,"acActivePower":0,"acReactivePower":0,"acApparentPower":0,"dcCurrent":0,"dcVoltage":0,"dcPower":0}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"measuredAt":"2019-08-24T14:15:22Z","gridFrequency":0,"acCurrent":0,"l1ACCurrent":0,"l2ACCurrent":0,"l3ACCurrent":0,"l1ACVoltage":0,"l2ACVoltage":0,"l3ACVoltage":0,"acActivePower":0,"acReactivePower":0,"acApparentPower":0,"dcCurrent":0,"dcVoltage":0,"dcPower":0}'
            |  \
              http POST https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"measuredAt":"2019-08-24T14:15:22Z","gridFrequency":0,"acCurrent":0,"l1ACCurrent":0,"l2ACCurrent":0,"l3ACCurrent":0,"l1ACVoltage":0,"l2ACVoltage":0,"l3ACVoltage":0,"acActivePower":0,"acReactivePower":0,"acApparentPower":0,"dcCurrent":0,"dcVoltage":0,"dcPower":0}' \
              --output-document \
              - https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "measuredAt": "2019-08-24T14:15:22Z",
              "gridFrequency": 0,
              "acCurrent": 0,
              "l1ACCurrent": 0,
              "l2ACCurrent": 0,
              "l3ACCurrent": 0,
              "l1ACVoltage": 0,
              "l2ACVoltage": 0,
              "l3ACVoltage": 0,
              "acActivePower": 0,
              "acReactivePower": 0,
              "acApparentPower": 0,
              "dcCurrent": 0,
              "dcVoltage": 0,
              "dcPower": 0
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/appliance")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}/measurements':
    get:
      summary: List Appliance's Combined Measurements
      description: >
        Lists combinations of appliance measurements and energy management 

        measurements. 


        This endpoints adds a "convenience" method for fetching raw
        measurements 

        and energy management measurements together, by combining them into a 

        single measurement object. 


        It is usually used to inspect the EMS behavior in correspondence to raw 

        values reported by the appliance. 


        The requested `interval` must not span more than 24 hours.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - ApplianceMeasurementsRead
      parameters:
        - *ref_75
        - *ref_54
        - *ref_119
      responses:
        '200':
          description: Combined measurements have been returned successfully.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_444
                  type: object
                  description: Combined appliance and energy management measurement.
                  allOf:
                    - oneOf:
                        - *ref_153
                        - *ref_161
                        - *ref_162
                        - *ref_163
                        - *ref_159
                    - type: object
                      properties:
                        energyManagement: &ref_164
                          title: Energy Management Measurement
                          type: object
                          properties:
                            measuredAt:
                              type: string
                              format: date-time
                              description: Time when the data was measured.
                            strategyID:
                              type: string
                              description: >
                                True if the PV power is dynamically limited
                                based on the available

                                battery capacity.
                            dynamicFeedInCurtailment:
                              type: boolean
                              description: >
                                True if the PV power is dynamically limited
                                based on the available

                                battery capacity.
                            prognosisBasedBatteryCharging:
                              type: boolean
                              description: >
                                True if a forecast is used to determine the
                                future feed-in into the

                                batteries.
                            activePowerSetpoint:
                              type: integer
                              format: int64
                              description: The setpoint the appliance should follow in mW.
                            activePowerSetpointSystemicError:
                              type: integer
                              format: int64
                              description: >
                                The measured deviation from the setpoint for the
                                active power value

                                in mW.
                            l1CurrentSetpoint:
                              type: integer
                              format: int64
                              description: >-
                                Is the setpoint the appliance should follow in
                                mA on phase 1.
                            l2CurrentSetpoint:
                              type: integer
                              format: int64
                              description: >-
                                Is the setpoint the appliance should follow in
                                mA on phase 2.
                            l3CurrentSetpoint:
                              type: integer
                              format: int64
                              description: >-
                                Is the setpoint the appliance should follow in
                                mA on phase 3.
                            maxStateOfChargeAfterMaxFeedIn:
                              type: integer
                              format: int32
                              description: >
                                MaxStateOfChargeAfterMaxFeedIn is the max state
                                of charge (0-100%) the

                                battery can reach while considering the capacity
                                needed to store the

                                energy above max feed-in. (eBatMax -
                                eBatOverFeedIn) * 100 /

                                eBatMax.
                            predictedEnergyOutput:
                              type: integer
                              format: int64
                              description: >
                                PredictedEnergyOutput is the predicted
                                electrical energy output of

                                this appliance in Wh based on the forecast
                                model, including error

                                adjustments.
                            energyOverFeedInCumulatedDaily:
                              type: integer
                              format: int64
                              description: >
                                EnergyOverFeedInCumulatedDaily is the cumulated
                                energy over the

                                feed-in that is saved this day thanks to the
                                energy management. This

                                value is reported by the grid meter in Wh.
        '403': *ref_11
        '404': *ref_158
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements',
              qs: {interval: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements"


            querystring = {"interval":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/gateways/{gatewayID}/appliances/{applianceID}/measurements/energymanagement':
    get:
      summary: List Appliance's Energy Management Measurements
      description: >
        Lists energy management measurements of an appliance over a period of
        time.

        Data points returned are emitted directly by the Energy Management

        System (EMS), therefore the resolution cannot be controlled. The 

        granularity at which we store measurements depends on the EMS mode and 

        configuration. 

        The provided `interval` must not span more than 24 hours.
      tags:
        - Appliance
      security:
        - BearerAuth:
            - ApplianceMeasurementsRead
      parameters:
        - *ref_75
        - *ref_54
        - *ref_119
      responses:
        '200':
          description: Energy Management Measurement returned.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_164
        '403': *ref_11
        '404': *ref_158
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement',
              qs: {interval: 'SOME_STRING_VALUE'},
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement");


            req.query({
              "interval": "SOME_STRING_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement');

            $request->setMethod(HTTP_METH_GET);


            $request->setQueryData([
              'interval' => 'SOME_STRING_VALUE'
            ]);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement');

            $request->setRequestMethod('GET');

            $request->setQuery(new http\QueryString([
              'interval' => 'SOME_STRING_VALUE'
            ]));


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement"


            querystring = {"interval":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/gateways/%7BgatewayID%7D/appliances/%7BapplianceID%7D/measurements/energymanagement?interval=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/clusters/{clusterID}/live':
    get:
      summary: Retrieve Cluster's Live Measurement.
      description: Retrieves a cluster's latest aggregated measurement.
      tags:
        - Cluster
      security:
        - BearerAuth:
            - SystemMeasurementsRead
      parameters:
        - *ref_64
      responses:
        '200':
          description: Successfully returned cluster's live measurements.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_165
        '401': *ref_166
        '403': *ref_11
        '404': *ref_158
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D/live");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D/live");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D/live\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D/live")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/clusters/%7BclusterID%7D/live")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/live",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/clusters/%7BclusterID%7D/live");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/live",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D/live",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D/live',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/clusters/%7BclusterID%7D/live");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D/live"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D/live" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D/live",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D/live');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D/live');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/clusters/%7BclusterID%7D/live",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/clusters/%7BclusterID%7D/live"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/clusters/%7BclusterID%7D/live")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/clusters/%7BclusterID%7D/live \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/clusters/%7BclusterID%7D/live \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D/live
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D/live")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/clusters/{clusterID}/historical':
    get:
      summary: Historical Measurements for cluster
      description: |
        Lists aggregated measurements of a cluster over a period of time.

        Cluster measurements are the result of incorporating measurements from 
        all appliances that are part of a cluster. This allows computing e.g. 
        overall consumption adding producers (e.g. PV) and subtracting consumers
        (e.g. EV charging stations). This aggregation is performed in various 
        resolutions to suit different use cases. See the 'resolution' parameter
        for a list of options.

        Depending on the resolution parameter, the response contains either
        power or energy measurements (unless otherwise documented):
        - **power** (unit: W): `10m`, `15m`, `1h`
        - **energy** (unit: Wh): `1d`, `1w`, `1M`, `1y`

        **Note**: Fetching historical measurements with 10m resolution works
        only for intervals **before** 2021-06-15T00:00:00Z.

        Measurements are "aligned" differently whether they contain energy or
        power measurements:
        - For power values the data point is written after the aggregated time 
          span. For the interval 2018-04-01T00:00:00Z/2018-04-02T00:00:00Z
          with resolution 15m the first observation will be recorded at 
          2018-04-01T00:15:00Z
        - For energy values the observation is stored at the beginning of 
          the aggregated time span. For the interval 
          2018-04-01T00:00:00Z/2018-04-05T00:00:00Z and resolution 1h the first 
          observation will be recorded at 2018-04-01T00:00:00Z
      tags:
        - Cluster
      security:
        - BearerAuth: []
      parameters:
        - *ref_64
      responses:
        '200':
          description: Successfully returned cluster's aggregated measurements.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_167
        '400': *ref_15
        '403': *ref_11
        '404': *ref_158
        '422': *ref_3
        '500': *ref_4
        '502': *ref_147
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/clusters/%7BclusterID%7D/historical");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/clusters/%7BclusterID%7D/historical");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/clusters/%7BclusterID%7D/historical\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/clusters/%7BclusterID%7D/historical")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/clusters/%7BclusterID%7D/historical")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/historical",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/clusters/%7BclusterID%7D/historical");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/clusters/%7BclusterID%7D/historical",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/clusters/%7BclusterID%7D/historical",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/clusters/%7BclusterID%7D/historical',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/clusters/%7BclusterID%7D/historical");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/clusters/%7BclusterID%7D/historical"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/clusters/%7BclusterID%7D/historical" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/clusters/%7BclusterID%7D/historical",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/clusters/%7BclusterID%7D/historical');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/clusters/%7BclusterID%7D/historical');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/clusters/%7BclusterID%7D/historical",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/clusters/%7BclusterID%7D/historical"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/clusters/%7BclusterID%7D/historical")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/clusters/%7BclusterID%7D/historical \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/clusters/%7BclusterID%7D/historical \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/clusters/%7BclusterID%7D/historical
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/clusters/%7BclusterID%7D/historical")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /policies:
    get:
      summary: List Policy Documents
      description: Lists all ever created policy documents
      tags:
        - Policy
      security:
        - BearerAuth:
            - PoliciesRead
      responses:
        '200': &ref_258
          description: List of policies.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_168
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/policies");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/policies");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/policies")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/policies");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/policies',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/policies");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/policies" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/policies');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/policies');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/policies", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/policies"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/policies")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/policies \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/policies \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/policies
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create Policy Document
      description: Creates a new policy document.
      tags:
        - Policy
      security:
        - BearerAuth:
            - PoliciesWrite
      requestBody: &ref_217
        description: Policy document to be created.
        required: true
        content:
          application/json:
            schema: &ref_171
              allOf:
                - &ref_452
                  title: Policy Document Update
                  type: object
                  allOf:
                    - *ref_169
                    - properties:
                        statements:
                          type: array
                          items: *ref_170
                - additionalProperties: false
      responses:
        '201': &ref_259
          description: Created policy document.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_168
        '400': *ref_15
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/policies");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"Default
            Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/policies");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"Default
            Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"Default Policy\\\",\\\"version\\\":\\\"Default Policy\\\",\\\"statements\\\":[{\\\"id\\\":\\\"97874c1b-d073-4b06-bf01-a1497fbe1146\\\",\\\"name\\\":\\\"string\\\",\\\"action\\\":\\\"groups:Create\\\",\\\"effect\\\":\\\"allow\\\",\\\"fields\\\":\\\"*\\\",\\\"resource\\\":\\\"accounts:*:groups\\\"}]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":\"Default Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/policies")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "Default Policy",
              "version": "Default Policy",
              "statements": [
                {
                  "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                  "name": "string",
                  "action": "groups:Create",
                  "effect": "allow",
                  "fields": "*",
                  "resource": "accounts:*:groups"
                }
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/policies");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'Default Policy',
              version: 'Default Policy',
              statements: [
                {
                  id: '97874c1b-d073-4b06-bf01-a1497fbe1146',
                  name: 'string',
                  action: 'groups:Create',
                  effect: 'allow',
                  fields: '*',
                  resource: 'accounts:*:groups'
                }
              ]
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/policies',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'Default Policy',
                version: 'Default Policy',
                statements: [
                  {
                    id: '97874c1b-d073-4b06-bf01-a1497fbe1146',
                    name: 'string',
                    action: 'groups:Create',
                    effect: 'allow',
                    fields: '*',
                    resource: 'accounts:*:groups'
                  }
                ]
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/policies");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "name": "Default Policy",
              "version": "Default Policy",
              "statements": [
                {
                  "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                  "name": "string",
                  "action": "groups:Create",
                  "effect": "allow",
                  "fields": "*",
                  "resource": "accounts:*:groups"
                }
              ]
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"Default Policy",
                                          @"version": @"Default Policy",
                                          @"statements": @[ @{ @"id": @"97874c1b-d073-4b06-bf01-a1497fbe1146", @"name": @"string", @"action": @"groups:Create", @"effect": @"allow", @"fields": @"*", @"resource": @"accounts:*:groups" } ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/policies" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"Default
            Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/policies');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"Default Policy","version":"Default
            Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"Default Policy","version":"Default
            Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}');


            $request->setRequestUrl('https://api.gridx.de/policies');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"Default Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/policies", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/policies"


            payload = {
                "name": "Default Policy",
                "version": "Default Policy",
                "statements": [
                    {
                        "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                        "name": "string",
                        "action": "groups:Create",
                        "effect": "allow",
                        "fields": "*",
                        "resource": "accounts:*:groups"
                    }
                ]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/policies")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"Default Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/policies \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"Default Policy","version":"Default Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"Default Policy","version":"Default
            Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}'
            |  \
              http POST https://api.gridx.de/policies \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"Default Policy","version":"Default Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}' \
              --output-document \
              - https://api.gridx.de/policies
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "Default Policy",
              "version": "Default Policy",
              "statements": [
                [
                  "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                  "name": "string",
                  "action": "groups:Create",
                  "effect": "allow",
                  "fields": "*",
                  "resource": "accounts:*:groups"
                ]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/policies/{policyID}':
    get:
      summary: Get Policy Document
      description: Gets policy document based on its ID.
      tags:
        - Policy
      security:
        - BearerAuth:
            - PoliciesRead
      parameters:
        - &ref_172
          name: policyID
          description: |
            Unique identifier that can be used to access policy documents.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 97874c1b-d073-4b06-bf01-a1497fbe1146
      responses:
        '200': &ref_260
          description: Policy Document
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_168
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/policies/%7BpolicyID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/policies/%7BpolicyID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies/%7BpolicyID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies/%7BpolicyID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/policies/%7BpolicyID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/policies/%7BpolicyID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies/%7BpolicyID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/policies/%7BpolicyID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/policies/%7BpolicyID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies/%7BpolicyID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/policies/%7BpolicyID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies/%7BpolicyID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/policies/%7BpolicyID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/policies/%7BpolicyID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/policies/%7BpolicyID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/policies/%7BpolicyID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/policies/%7BpolicyID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/policies/%7BpolicyID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/policies/%7BpolicyID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/policies/%7BpolicyID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies/%7BpolicyID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update Policy Document
      description: Updates a policy document.
      tags:
        - Policy
      security:
        - BearerAuth:
            - PoliciesWrite
      requestBody: &ref_218
        description: Policy document to be updated.
        required: true
        content:
          application/json:
            schema: *ref_171
      parameters:
        - *ref_172
      responses:
        '204':
          description: Policy Document Updated
        '400': *ref_15
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/policies/%7BpolicyID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"Default
            Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/policies/%7BpolicyID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"Default
            Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies/%7BpolicyID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"Default Policy\\\",\\\"version\\\":\\\"Default Policy\\\",\\\"statements\\\":[{\\\"id\\\":\\\"97874c1b-d073-4b06-bf01-a1497fbe1146\\\",\\\"name\\\":\\\"string\\\",\\\"action\\\":\\\"groups:Create\\\",\\\"effect\\\":\\\"allow\\\",\\\"fields\\\":\\\"*\\\",\\\"resource\\\":\\\"accounts:*:groups\\\"}]}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":\"Default Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies/%7BpolicyID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/policies/%7BpolicyID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "Default Policy",
              "version": "Default Policy",
              "statements": [
                {
                  "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                  "name": "string",
                  "action": "groups:Create",
                  "effect": "allow",
                  "fields": "*",
                  "resource": "accounts:*:groups"
                }
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/policies/%7BpolicyID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies/%7BpolicyID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'Default Policy',
              version: 'Default Policy',
              statements: [
                {
                  id: '97874c1b-d073-4b06-bf01-a1497fbe1146',
                  name: 'string',
                  action: 'groups:Create',
                  effect: 'allow',
                  fields: '*',
                  resource: 'accounts:*:groups'
                }
              ]
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/policies/%7BpolicyID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'Default Policy',
                version: 'Default Policy',
                statements: [
                  {
                    id: '97874c1b-d073-4b06-bf01-a1497fbe1146',
                    name: 'string',
                    action: 'groups:Create',
                    effect: 'allow',
                    fields: '*',
                    resource: 'accounts:*:groups'
                  }
                ]
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/policies/%7BpolicyID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "Default Policy",
              "version": "Default Policy",
              "statements": [
                {
                  "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                  "name": "string",
                  "action": "groups:Create",
                  "effect": "allow",
                  "fields": "*",
                  "resource": "accounts:*:groups"
                }
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"Default Policy",
                                          @"version": @"Default Policy",
                                          @"statements": @[ @{ @"id": @"97874c1b-d073-4b06-bf01-a1497fbe1146", @"name": @"string", @"action": @"groups:Create", @"effect": @"allow", @"fields": @"*", @"resource": @"accounts:*:groups" } ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies/%7BpolicyID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/policies/%7BpolicyID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"Default
            Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies/%7BpolicyID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"Default Policy\",\"version\":\"Default Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/policies/%7BpolicyID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"Default Policy","version":"Default
            Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"Default Policy","version":"Default
            Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}');


            $request->setRequestUrl('https://api.gridx.de/policies/%7BpolicyID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"Default Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/policies/%7BpolicyID%7D", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/policies/%7BpolicyID%7D"


            payload = {
                "name": "Default Policy",
                "version": "Default Policy",
                "statements": [
                    {
                        "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                        "name": "string",
                        "action": "groups:Create",
                        "effect": "allow",
                        "fields": "*",
                        "resource": "accounts:*:groups"
                    }
                ]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/policies/%7BpolicyID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"Default Policy\",\"version\":\"Default
            Policy\",\"statements\":[{\"id\":\"97874c1b-d073-4b06-bf01-a1497fbe1146\",\"name\":\"string\",\"action\":\"groups:Create\",\"effect\":\"allow\",\"fields\":\"*\",\"resource\":\"accounts:*:groups\"}]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/policies/%7BpolicyID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"Default Policy","version":"Default Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"Default Policy","version":"Default
            Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}'
            |  \
              http PATCH https://api.gridx.de/policies/%7BpolicyID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"Default Policy","version":"Default Policy","statements":[{"id":"97874c1b-d073-4b06-bf01-a1497fbe1146","name":"string","action":"groups:Create","effect":"allow","fields":"*","resource":"accounts:*:groups"}]}' \
              --output-document \
              - https://api.gridx.de/policies/%7BpolicyID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "Default Policy",
              "version": "Default Policy",
              "statements": [
                [
                  "id": "97874c1b-d073-4b06-bf01-a1497fbe1146",
                  "name": "string",
                  "action": "groups:Create",
                  "effect": "allow",
                  "fields": "*",
                  "resource": "accounts:*:groups"
                ]
              ]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies/%7BpolicyID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Policy Document
      description: Deletes a policy document.
      tags:
        - Policy
      security:
        - BearerAuth:
            - PoliciesWrite
      parameters:
        - *ref_172
      responses:
        '204':
          description: Policy Document Deleted
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/policies/%7BpolicyID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/policies/%7BpolicyID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies/%7BpolicyID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies/%7BpolicyID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/policies/%7BpolicyID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE", "https://api.gridx.de/policies/%7BpolicyID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies/%7BpolicyID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/policies/%7BpolicyID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/policies/%7BpolicyID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies/%7BpolicyID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/policies/%7BpolicyID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies/%7BpolicyID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/policies/%7BpolicyID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/policies/%7BpolicyID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("DELETE", "/policies/%7BpolicyID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/policies/%7BpolicyID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/policies/%7BpolicyID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/policies/%7BpolicyID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/policies/%7BpolicyID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/policies/%7BpolicyID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies/%7BpolicyID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/policies/{policyID}/statements/{statementID}':
    delete:
      summary: Unassign Policy Statement from Document
      description: Un-assigns a policy statement from a policy document
      tags:
        - Policy
      security:
        - BearerAuth:
            - PoliciesWrite
      parameters:
        - *ref_172
        - &ref_187
          name: statementID
          description: |
            Unique identifier that can be used to refer to policy statements.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 17874c1b-d073-4b06-bf01-a1497fbe1142
      responses:
        '204':
          description: Policy Statement Unassigned
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies/%7BpolicyID%7D/statements/%7BstatementID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/policies/%7BpolicyID%7D/statements/%7BstatementID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies/%7BpolicyID%7D/statements/%7BstatementID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/policies/{policyID}/groups':
    post:
      summary: Assign Policy Document to Group
      tags:
        - Policy
        - Group
      security:
        - BearerAuth:
            - GroupsWrite
      parameters:
        - *ref_172
      requestBody: &ref_219
        description: Policy document that should be assigned to a group.
        required: true
        content:
          application/json:
            schema: &ref_453
              allOf:
                - *ref_32
                - additionalProperties: false
      responses:
        '204':
          description: Policy Group Assigned
        '400': *ref_15
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/policies/%7BpolicyID%7D/groups");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to accounts\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies/%7BpolicyID%7D/groups\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"group name\\\",\\\"description\\\":\\\"Group provides read-access to accounts\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies/%7BpolicyID%7D/groups")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/policies/%7BpolicyID%7D/groups")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D/groups",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "group name",
              "description": "Group provides read-access to accounts"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D/groups",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies/%7BpolicyID%7D/groups",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({name: 'group name', description: 'Group
            provides read-access to accounts'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/policies/%7BpolicyID%7D/groups',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {name: 'group name', description: 'Group provides read-access to accounts'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "group name",
              "description": "Group provides read-access to accounts"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"group name",
                                          @"description": @"Group provides read-access to accounts" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies/%7BpolicyID%7D/groups"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"group
            name\",\"description\":\"Group provides read-access to accounts\"}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies/%7BpolicyID%7D/groups",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/policies/%7BpolicyID%7D/groups');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"group name","description":"Group
            provides read-access to accounts"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"group name","description":"Group provides
            read-access to accounts"}');


            $request->setRequestUrl('https://api.gridx.de/policies/%7BpolicyID%7D/groups');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"group name\",\"description\":\"Group provides
            read-access to accounts\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/policies/%7BpolicyID%7D/groups", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/policies/%7BpolicyID%7D/groups"


            payload = {
                "name": "group name",
                "description": "Group provides read-access to accounts"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/policies/%7BpolicyID%7D/groups")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"group name\",\"description\":\"Group
            provides read-access to accounts\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/policies/%7BpolicyID%7D/groups \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"group name","description":"Group provides read-access to accounts"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"group name","description":"Group provides read-access
            to accounts"}' |  \
              http POST https://api.gridx.de/policies/%7BpolicyID%7D/groups \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"group name","description":"Group provides read-access to accounts"}' \
              --output-document \
              - https://api.gridx.de/policies/%7BpolicyID%7D/groups
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "group name",
              "description": "Group provides read-access to accounts"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/policies/{policyID}/groups/{groupID}':
    delete:
      summary: Unassign Policy Document from Group
      tags:
        - Policy
        - Group
      security:
        - BearerAuth:
            - GroupsWrite
      parameters:
        - *ref_172
        - *ref_35
      responses:
        '204':
          description: Policy Group Unassigned
        '400': *ref_15
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/policies/%7BpolicyID%7D/groups/%7BgroupID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/policies/%7BpolicyID%7D/groups/%7BgroupID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/policies/%7BpolicyID%7D/groups/%7BgroupID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /product-functionalities:
    post:
      summary: Create Product Functionality
      description: Creates a new product functionality.
      tags:
        - Product Functionality
      security:
        - BearerAuth: []
      requestBody:
        description: Product functionality to be created.
        required: true
        content:
          application/json:
            schema: &ref_455
              allOf:
                - &ref_454
                  type: object
                  allOf:
                    - *ref_173
                    - required:
                        - name
                        - hide
                - additionalProperties: false
      responses:
        '201':
          description: Created product functionality.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_28
        '400': *ref_15
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/product-functionalities");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"EV
            Manager\",\"hide\":true,\"description\":\"string\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/product-functionalities");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"EV
            Manager\",\"hide\":true,\"description\":\"string\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/product-functionalities\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"EV Manager\\\",\\\"hide\\\":true,\\\"description\\\":\\\"string\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"EV
            Manager\",\"hide\":true,\"description\":\"string\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/product-functionalities")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/product-functionalities")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"EV Manager\",\"hide\":true,\"description\":\"string\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"EV Manager\",\"hide\":true,\"description\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "EV Manager",
              "hide": true,
              "description": "string"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/product-functionalities");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"EV Manager\",\"hide\":true,\"description\":\"string\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/product-functionalities",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({name: 'EV Manager', hide: true,
            description: 'string'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/product-functionalities',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {name: 'EV Manager', hide: true, description: 'string'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/product-functionalities");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "EV Manager",
              "hide": true,
              "description": "string"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"EV Manager",
                                          @"hide": @YES,
                                          @"description": @"string" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/product-functionalities"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/product-functionalities" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"EV
            Manager\",\"hide\":true,\"description\":\"string\"}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/product-functionalities",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"EV Manager\",\"hide\":true,\"description\":\"string\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/product-functionalities');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"EV
            Manager","hide":true,"description":"string"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"EV
            Manager","hide":true,"description":"string"}');


            $request->setRequestUrl('https://api.gridx.de/product-functionalities');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"EV
            Manager\",\"hide\":true,\"description\":\"string\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/product-functionalities", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/product-functionalities"


            payload = {
                "name": "EV Manager",
                "hide": True,
                "description": "string"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/product-functionalities")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"EV
            Manager\",\"hide\":true,\"description\":\"string\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/product-functionalities \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"EV Manager","hide":true,"description":"string"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"name":"EV Manager","hide":true,"description":"string"}' |  \
              http POST https://api.gridx.de/product-functionalities \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"EV Manager","hide":true,"description":"string"}' \
              --output-document \
              - https://api.gridx.de/product-functionalities
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "EV Manager",
              "hide": true,
              "description": "string"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/product-functionalities")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    get:
      summary: List Product Functionalities
      description: Lists all product functionalities.
      tags:
        - Product Functionality
      security:
        - BearerAuth: []
      responses:
        '200':
          description: List of product functionalities.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_28
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/product-functionalities");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/product-functionalities");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/product-functionalities\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/product-functionalities")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/product-functionalities")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/product-functionalities");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/product-functionalities",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/product-functionalities',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/product-functionalities");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/product-functionalities"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/product-functionalities" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/product-functionalities",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/product-functionalities');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/product-functionalities');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/product-functionalities", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/product-functionalities"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/product-functionalities")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/product-functionalities \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/product-functionalities \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/product-functionalities
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/product-functionalities")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/product-functionalities/{functionalityID}':
    get:
      summary: Get a Product Functionality
      description: Lists all product functionalities.
      tags:
        - Product Functionality
      security:
        - BearerAuth: []
      parameters:
        - &ref_174
          name: functionalityID
          description: |
            Unique identifier of the product functionality.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 12a2cfc0-f873-11ed-b67e-0242ac120002
      responses:
        '200':
          description: Requested product functionality.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_28
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/product-functionalities/%7BfunctionalityID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/product-functionalities/%7BfunctionalityID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Product Functionality
      description: Delete a product functionality.
      tags:
        - Product Functionality
      security:
        - BearerAuth: []
      parameters:
        - *ref_174
      responses:
        '204':
          description: Product functionality successfully deleted.
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/product-functionalities/%7BfunctionalityID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/product-functionalities/%7BfunctionalityID%7D", headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/product-functionalities/%7BfunctionalityID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/product-options':
    post:
      summary: Create Product Option
      description: Creates a new product option.
      tags:
        - Product Option
      security:
        - BearerAuth: []
      parameters:
        - *ref_1
      requestBody:
        description: Product option to be created.
        required: true
        content:
          application/json:
            schema: &ref_457
              allOf:
                - &ref_456
                  type: object
                  allOf:
                    - *ref_175
                    - properties:
                        isDefault:
                          type: boolean
                          description: >-
                            Indicates whether the product option should be
                            assigned by default to all systems of the owning
                            account.
                        hideFunctionalities:
                          description: >-
                            The default functionalities that a product option
                            restricts access to. Must be of type `hide=true`.
                          type: array
                          items: &ref_176
                            type: object
                            required:
                              - id
                            properties:
                              id:
                                description: >-
                                  Unique identifier of the product
                                  functionality.
                                type: string
                                format: uuid
                                example: 4e3392ce-ed94-4946-8a11-665e0443723e
                        showFunctionalities:
                          description: >-
                            The extra functionalities that a product option
                            grants access to. Must be of type `hide=false`.
                          type: array
                          items: *ref_176
                      required:
                        - name
                        - isDefault
                - additionalProperties: false
      responses:
        '201':
          description: Created product option.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_177
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"Default
            Product
            Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/product-options");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"Default
            Product
            Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/product-options\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"Default Product Option\\\",\\\"description\\\":\\\"string\\\",\\\"isDefault\\\":true,\\\"hideFunctionalities\\\":[{\\\"id\\\":\\\"4e3392ce-ed94-4946-8a11-665e0443723e\\\"}],\\\"showFunctionalities\\\":[{\\\"id\\\":\\\"4e3392ce-ed94-4946-8a11-665e0443723e\\\"}]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/product-options")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/accounts/%7BaccountID%7D/product-options")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"Default Product Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Product Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "Default Product Option",
              "description": "string",
              "isDefault": true,
              "hideFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ],
              "showFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Product Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/product-options",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'Default Product Option',
              description: 'string',
              isDefault: true,
              hideFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}],
              showFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}]
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/product-options',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'Default Product Option',
                description: 'string',
                isDefault: true,
                hideFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}],
                showFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}]
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("POST",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "Default Product Option",
              "description": "string",
              "isDefault": true,
              "hideFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ],
              "showFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"Default Product Option",
                                          @"description": @"string",
                                          @"isDefault": @YES,
                                          @"hideFunctionalities": @[ @{ @"id": @"4e3392ce-ed94-4946-8a11-665e0443723e" } ],
                                          @"showFunctionalities": @[ @{ @"id": @"4e3392ce-ed94-4946-8a11-665e0443723e" } ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/product-options"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"
            in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/product-options",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"name\":\"Default Product Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"Default Product
            Option","description":"string","isDefault":true,"hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"Default Product
            Option","description":"string","isDefault":true,"hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/accounts/%7BaccountID%7D/product-options",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options"


            payload = {
                "name": "Default Product Option",
                "description": "string",
                "isDefault": True,
                "hideFunctionalities": [{"id": "4e3392ce-ed94-4946-8a11-665e0443723e"}],
                "showFunctionalities": [{"id": "4e3392ce-ed94-4946-8a11-665e0443723e"}]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/product-options")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"isDefault\":true,\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/product-options \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"Default Product Option","description":"string","isDefault":true,"hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"Default Product
            Option","description":"string","isDefault":true,"hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}'
            |  \
              http POST https://api.gridx.de/accounts/%7BaccountID%7D/product-options \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"Default Product Option","description":"string","isDefault":true,"hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/product-options
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "Default Product Option",
              "description": "string",
              "isDefault": true,
              "hideFunctionalities": [["id": "4e3392ce-ed94-4946-8a11-665e0443723e"]],
              "showFunctionalities": [["id": "4e3392ce-ed94-4946-8a11-665e0443723e"]]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    get:
      summary: List Product Options
      description: >
        Lists all product options created by the given account and its children.


        Product options returned by this endpoint are not necessarily assignable
        to all systems assigned to the given account. 
      tags:
        - Product Option
      security:
        - BearerAuth: []
      parameters:
        - *ref_1
      responses:
        '200':
          description: List of product options.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_177
        '403': *ref_11
        '404': *ref_55
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/product-options");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/product-options\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/product-options")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/accounts/%7BaccountID%7D/product-options")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/product-options",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/product-options',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/product-options"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/product-options",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/accounts/%7BaccountID%7D/product-options",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/product-options")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/product-options \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/accounts/%7BaccountID%7D/product-options \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/product-options
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/accounts/{accountID}/product-options/{optionID}':
    patch:
      summary: Update a Product Option
      description: Updates a product option.
      tags:
        - Product Option
      security:
        - BearerAuth: []
      parameters:
        - *ref_1
        - &ref_178
          name: optionID
          description: |
            Unique identifier of the product option.
          in: path
          required: true
          schema:
            type: string
            format: uuid
          example: 7e82929c-f87e-11ed-b67e-0242ac120002
      requestBody:
        description: Partially updates a product option.
        required: true
        content:
          application/json:
            schema: &ref_459
              allOf:
                - &ref_458
                  type: object
                  allOf:
                    - *ref_175
                    - properties:
                        hideFunctionalities:
                          description: >-
                            The default functionalities that a product option
                            restricts access to. Must be of type `hide=true`.
                          type: array
                          items: *ref_176
                        showFunctionalities:
                          description: >-
                            The extra functionalities that a product option
                            grants access to. Must be of type `hide=false`.
                          type: array
                          items: *ref_176
                - additionalProperties: false
      responses:
        '200':
          description: Updated product option.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_177
        '400': *ref_15
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"name\":\"Default
            Product
            Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"name\":\"Default
            Product
            Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"name\\\":\\\"Default Product Option\\\",\\\"description\\\":\\\"string\\\",\\\"hideFunctionalities\\\":[{\\\"id\\\":\\\"4e3392ce-ed94-4946-8a11-665e0443723e\\\"}],\\\"showFunctionalities\\\":[{\\\"id\\\":\\\"4e3392ce-ed94-4946-8a11-665e0443723e\\\"}]}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"name\":\"Default Product Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Product Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "name": "Default Product Option",
              "description": "string",
              "hideFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ],
              "showFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ]
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"name\":\"Default Product Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              name: 'Default Product Option',
              description: 'string',
              hideFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}],
              showFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}]
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                name: 'Default Product Option',
                description: 'string',
                hideFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}],
                showFunctionalities: [{id: '4e3392ce-ed94-4946-8a11-665e0443723e'}]
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "name": "Default Product Option",
              "description": "string",
              "hideFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ],
              "showFunctionalities": [
                {
                  "id": "4e3392ce-ed94-4946-8a11-665e0443723e"
                }
              ]
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"name": @"Default Product Option",
                                          @"description": @"string",
                                          @"hideFunctionalities": @[ @{ @"id": @"4e3392ce-ed94-4946-8a11-665e0443723e" } ],
                                          @"showFunctionalities": @[ @{ @"id": @"4e3392ce-ed94-4946-8a11-665e0443723e" } ] };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"name\":\"Default Product Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"name":"Default Product
            Option","description":"string","hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"name":"Default Product
            Option","description":"string","hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}');


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D"


            payload = {
                "name": "Default Product Option",
                "description": "string",
                "hideFunctionalities": [{"id": "4e3392ce-ed94-4946-8a11-665e0443723e"}],
                "showFunctionalities": [{"id": "4e3392ce-ed94-4946-8a11-665e0443723e"}]
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"name\":\"Default Product
            Option\",\"description\":\"string\",\"hideFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}],\"showFunctionalities\":[{\"id\":\"4e3392ce-ed94-4946-8a11-665e0443723e\"}]}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"name":"Default Product Option","description":"string","hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}'
        - lang: Shell + Httpie
          source: >-
            echo '{"name":"Default Product
            Option","description":"string","hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}'
            |  \
              http PATCH https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"name":"Default Product Option","description":"string","hideFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}],"showFunctionalities":[{"id":"4e3392ce-ed94-4946-8a11-665e0443723e"}]}' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "name": "Default Product Option",
              "description": "string",
              "hideFunctionalities": [["id": "4e3392ce-ed94-4946-8a11-665e0443723e"]],
              "showFunctionalities": [["id": "4e3392ce-ed94-4946-8a11-665e0443723e"]]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete Product Option
      description: Delete a product option.
      tags:
        - Product Option
      security:
        - BearerAuth: []
      parameters:
        - *ref_1
        - *ref_178
      responses:
        '204':
          description: Product option successfully deleted.
        '403': *ref_11
        '404': *ref_55
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE",
            "/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D"


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("DELETE", url, headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE
            https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/accounts/%7BaccountID%7D/product-options/%7BoptionID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /spine/devices:
    get:
      summary: List all connected devices
      description: |
        List devices that are accessible to the authenticated account. 
        The response contains devices grouped by their provider.
      tags:
        - Devices
      security:
        - BearerAuth:
            - SPINEDevicesRead
      responses:
        '200': &ref_261
          description: SPINE devices returned.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_462
                type: object
                additionalProperties:
                  type: array
                  items: &ref_463
                    type: object
                    properties:
                      id:
                        description: >-
                          ID for device, must be url encoded. E.g. deviceId as
                          specified by manufacturer.
                        type: string
                        example: 27jslrNMHpUx266
                      url:
                        description: URL of the device.
                        type: string
                      parentURL:
                        description: URL of parent device.
                        type: string
                      deviceAddress:
                        description: SPINE DeviceAddress.
                        type: string
                        pattern: >-
                          d:_(i:[1-9][0-9]*|n:[a-zA-Z0-9-]+)_[^\p{Cc}\p{Cf}\p{Z}]+
                        example: 'd:_n:NaTeYtMjnNGtQqQvbuJT4AoSY-LBq_;:7Jbs,L"Qz.hQg'
                      type:
                        description: Type of the device.
                        type: string
                        example: washer
                      label:
                        description: >-
                          User-defined label via an external app e.g Home
                          Connect.
                        type: string
                        example: My new dishwasher
                      bindings: &ref_468
                        description: List of bindings.
                        type: array
                        items: &ref_469
                          type: object
                          properties:
                            bindingId:
                              description: >-
                                ID of binding entry, must be unique in path. The
                                bindingId is provided by the server and must not
                                specified on client side.
                              type: string
                              readOnly: true
                              example: jaxbv2
                            type:
                              description: >-
                                The resource type for which the binding is
                                created.
                              type: string
                              enum:
                                - powerSequence
                              example: powerSequence
                            url:
                              description: >-
                                Convenience pointer to endpoint for this
                                binding. The validity is provided by the server
                                and must not be specified on client side.
                              type: string
                              readOnly: true
                              example: >-
                                https://api.eebus.org/devices/1041A421/bindings/jaxbv2
                            name:
                              description: User-friendly name of binding partner.
                              type: string
                              example: bindingName
                            validity:
                              description: >-
                                A Binding is valid for 24 hours and will be
                                released if not renewed in time. The validity is
                                provided by the server and must not be specified
                                on client side.
                              type: string
                              format: date-time
                              readOnly: true
                              example: '2021-07-24T23:59:59Z'
                          required:
                            - type
                            - name
                      usecases: &ref_464
                        description: List of supported use-cases for this device.
                        type: array
                        items: &ref_465
                          type: object
                          properties:
                            name:
                              description: Semantic short name of the use-case.
                              type: string
                              enum:
                                - fswg
                              readOnly: true
                              example: fswg
                            actor:
                              description: The actor's role in the current scenario.
                              type: string
                              enum:
                                - server
                                - client
                              readOnly: true
                              example: server
                          required:
                            - name
                            - actor
                      resources: &ref_466
                        description: List of resources available on this device.
                        type: array
                        items: &ref_467
                          description: >-
                            A specific resource describes a capability (e.g.
                            flexible start of white goods).
                          type: object
                          properties:
                            url:
                              description: URL of the resource.
                              type: string
                              example: >-
                                https://api.eebus.org/devices/1041A421/powerSequences
                            type:
                              description: Type of the resource.
                              type: string
                              example: powerSequence
                            specialization:
                              description: Specialization of the resource.
                              type: string
                              example: flexibleStart
                            supportsBinding:
                              description: >-
                                Explicit definition whether the resource
                                supports exclusive binding.
                              type: boolean
                              example: true
                            data:
                              type: array
                              items:
                                oneOf:
                                  - &ref_179
                                    type: object
                                    properties:
                                      sequenceId:
                                        description: >-
                                          Identifier of power sequence, must be
                                          unique in path.
                                        type: integer
                                        readOnly: true
                                        example: 1
                                      state:
                                        description: >-
                                          EEBUS FSWG-025. See section
                                          3.2.1.2.2.1.1.4
                                        type: string
                                        enum:
                                          - inactive
                                          - scheduled
                                          - running
                                          - paused
                                          - completed
                                          - invalid
                                        readOnly: true
                                        example: scheduled
                                      activeSlotNumber:
                                        description: >-
                                          The currently active powerTimeSlot, if
                                          state is inactive, schedule, completed
                                          or invalid, activeSlotNumber is 0.
                                        type: integer
                                        readOnly: true
                                      sequenceRemoteControllable:
                                        type: boolean
                                        readOnly: true
                                      startTime:
                                        description: See EEBUS FSWG-04.
                                        type: string
                                        format: date-time
                                        example: '2021-06-24T12:00:00Z'
                                      endTime:
                                        description: >-
                                          Must be greater than "alternatives.
                                          powerSequence. schedule. startTime"
                                        type: string
                                        format: date-time
                                        example: '2021-06-24T13:40:00Z'
                                      earliestStartTime:
                                        description: See EEBUS FSWG-022.
                                        type: string
                                        format: date-time
                                        readOnly: false
                                        example: '2021-06-24T06:20:00Z'
                                      latestEndTime:
                                        description: See EEBUS FSWG-023.
                                        type: string
                                        format: date-time
                                        example: '2021-06-24T19:00:00Z'
                                      isPausable:
                                        description: >
                                          If the sequence can be paused by the
                                          CEM, this element SHALL be present and
                                          set to true. Otherwise it SHALL be
                                          omitted or set to false (default value).

                                          For more details, see EEBUS FSWG-026S.
                                        type: boolean
                                        readOnly: true
                                        default: false
                                      isStoppable:
                                        description: >
                                          If the sequence can be stopped by the
                                          CEM, this element SHALL be present and
                                          set to true. Otherwise it SHALL be
                                          omitted or set to false (default value).

                                          For more details, see EEBUS FSWG-027.
                                        type: boolean
                                        readOnly: true
                                        default: false
                                      valueSource:
                                        description: >-
                                          If not set, the source of forecasted
                                          values is undefined.
                                        type: string
                                        enum:
                                          - empiricalValue
                                          - calculatedValue
                                          - measuredValue
                                        readOnly: true
                                      taskIdentifier:
                                        description: Identifier of the task.
                                        type: integer
                                        readOnly: true
                                      powerTimeSlots: &ref_470
                                        description: >-
                                          List of power time slots for a power
                                          sequence. See EEBUS FSWG-060.
                                        type: array
                                        items: &ref_471
                                          type: object
                                          properties:
                                            slotId:
                                              description: >-
                                                A SUB IDENTIFIER within powerSequence.
                                                The slot IDs within one power sequence
                                                shall be assigned according to the
                                                chronological order of the slots.
                                              type: integer
                                              readOnly: true
                                              example: 1
                                            defaultDuration:
                                              description: See EEBUS FSWG-063.
                                              type: string
                                              format: partial-time
                                              readOnly: true
                                              example: '00:23:00'
                                            powerMin:
                                              description: See EEBUS FSWG-062.
                                              type: number
                                              format: float
                                              readOnly: true
                                              example: 100
                                            powerExpectedValue:
                                              description: See EEBUS FSWG-062.
                                              type: number
                                              readOnly: true
                                              example: 200
                                            powerMax:
                                              description: See EEBUS FSWG-062.
                                              type: number
                                              format: float
                                              readOnly: true
                                              example: 1000
                                    required:
                                      - earliestStartTime
                                      - latestEndTime
                                      - powerTimeSlots
                          required:
                            - url
                            - type
                            - supportsBinding
                            - data
                    required:
                      - id
                      - url
                      - type
                      - bindings
                      - usecases
                      - resources
                example:
                  homeconnect:
                    - id: 27jslrNMHpUx266
                      url: homeconnect-device-url
                      parentURL: string
                      deviceAddress: 'd:_n:NaTeYtMjnNGtQqQvbuJT4AoSY-LBq_;:7Jbs,L"Qz.hQg'
                      type: washer
                      label: My New Dishwasher
                      bindings:
                        - bindingId: jaxbv2
                          type: powerSequence
                          url: >-
                            https://api.eebus.org/devices/1041A421/bindings/jaxbv2
                          name: bindingName
                          validity: '2021-07-24T23:59:59Z'
                      usecases:
                        - name: fswg
                          actor: server
                      resources:
                        - url: >-
                            https://api.eebus.org/devices/1041A421/powerSequences
                          type: powerSequence
                          specialization: flexibleStart
                          supportsBinding: true
                          data:
                            - sequenceId: 1
                              state: scheduled
                              activeSlotNumber: 0
                              sequenceRemoteControllable: true
                              startTime: '2021-06-24T12:00:00Z'
                              endTime: '2021-06-24T13:40:00Z'
                              earliestStartTime: '2021-06-24T06:20:00Z'
                              latestEndTime: '2021-06-24T19:00:00Z'
                              isPausable: false
                              isStoppable: false
                              valueSource: empiricalValue
                              taskIdentifier: 0
                              powerTimeSlots:
                                - slotId: 1
                                  defaultDuration: '00:23:00'
                                  powerMin: 100
                                  powerExpectedValue: 200
                                  powerMax: 1000
        '403': *ref_11
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/spine/devices");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/spine/devices");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/spine/devices\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/spine/devices")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/spine/devices")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/spine/devices",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/spine/devices");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/spine/devices",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/spine/devices",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/spine/devices',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/spine/devices");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/spine/devices"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/spine/devices" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/spine/devices",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/spine/devices');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/spine/devices');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/spine/devices", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/spine/devices"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/spine/devices")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/spine/devices \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/spine/devices \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/spine/devices
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/spine/devices")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/spine/devices/{deviceID}/powersequences/{sequenceID}':
    patch:
      summary: Change a specific power sequence for a specific device.
      description: >
        A PATCH may be performed on startTime and endTime of an existing power
        sequence. 

        If only one parameter is specified, the other is calculated from the
        accumulated duration of all power time slots for this sequence.

        A device binding is needed before changing the power sequence. If a
        binding doesn't exist, it is first created and then the power sequence
        is updated.
      tags:
        - Power Sequence
      security:
        - BearerAuth:
            - SPINEDevicesWrite
      parameters:
        - &ref_188
          name: deviceID
          description: 'ID of the SPINE device, specified by the manufacturer.'
          in: path
          required: true
          schema:
            type: string
          example: deviceID
        - &ref_189
          name: sequenceID
          description: Identifier of power sequence.
          in: path
          required: true
          schema:
            type: integer
          example: 1
      requestBody: &ref_220
        description: Update a power sequence for the given device.
        content:
          application/json:
            schema: &ref_461
              allOf:
                - &ref_460
                  type: object
                  properties:
                    earliestStartTime:
                      type: string
                      example: '2021-06-24T06:20:00'
                - additionalProperties: false
            examples:
              scheduleStart: &ref_487
                summary: Start a power sequence at a scheduled time.
                value:
                  startTime: '2021-06-24T12:00:00'
      responses:
        '201':
          description: A complete representation of the updated power sequence.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_179
              examples:
                earliestStart: &ref_488
                  summary: Running power sequence
                  value:
                    sequenceId: 1
                    state: running
                    activeSlotNumber: 1
                    sequenceRemoteControllable: true
                    startTime: '2021-06-24T12:00:00Z'
                    endTime: '2021-06-24T13:40:00Z'
                    earliestStartTime: '2021-06-24T06:20:00Z'
                    latestEndTime: '2021-06-24T19:00:00Z'
                    isPausable: false
                    isStoppable: false
                    powerTimeSlots:
                      - slotId: 1
                        defaultDuration: '00:23:00'
                        powerMin: 100
                        powerExpectedValue: 200
                        powerMax: 2000
                      - slotId: 2
                        defaultDuration: '01:17:00'
                        powerMin: 90
                        powerExpectedValue: 180
                        powerMax: 1800
                scheduleStart: &ref_489
                  summary: Scheduled power sequence
                  value:
                    sequenceId: 1
                    state: scheduled
                    activeSlotNumber: 0
                    sequenceRemoteControllable: true
                    startTime: '2021-06-24T12:00:00Z'
                    endTime: '2021-06-24T13:40:00Z'
                    earliestStartTime: '2021-06-24T06:20:00Z'
                    latestEndTime: '2021-06-24T19:00:00Z'
                    isPausable: false
                    isStoppable: false
                    powerTimeSlots:
                      - slotId: 1
                        defaultDuration: '00:23:00'
                        powerMin: 100
                        powerExpectedValue: 200
                        powerMax: 2000
                      - slotId: 2
                        defaultDuration: '01:17:00'
                        powerMin: 90
                        powerExpectedValue: 180
                        powerMax: 1800
        '400': *ref_15
        '403': *ref_11
        '404': &ref_262
          description: Device Not found
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_6
        '422': *ref_3
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"earliestStartTime\\\":\\\"2021-06-24T06:20:00\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"earliestStartTime\":\"2021-06-24T06:20:00\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "earliestStartTime": "2021-06-24T06:20:00"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({earliestStartTime:
            '2021-06-24T06:20:00'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {earliestStartTime: '2021-06-24T06:20:00'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "earliestStartTime": "2021-06-24T06:20:00"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"earliestStartTime":
            @"2021-06-24T06:20:00" };


            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D"
            in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"earliestStartTime":"2021-06-24T06:20:00"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"earliestStartTime":"2021-06-24T06:20:00"}');


            $request->setRequestUrl('https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH",
            "/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url =
            "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D"


            payload = {"earliestStartTime": "2021-06-24T06:20:00"}

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"earliestStartTime\":\"2021-06-24T06:20:00\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"earliestStartTime":"2021-06-24T06:20:00"}'
        - lang: Shell + Httpie
          source: |-
            echo '{"earliestStartTime":"2021-06-24T06:20:00"}' |  \
              http PATCH https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"earliestStartTime":"2021-06-24T06:20:00"}' \
              --output-document \
              - https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = ["earliestStartTime": "2021-06-24T06:20:00"] as
            [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/spine/devices/%7BdeviceID%7D/powersequences/%7BsequenceID%7D")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user:
    get:
      summary: Retrieve the authenticated User
      description: Retrieves the details of the authenticated user.
      tags:
        - User
      security:
        - BearerAuth:
            - ReadUser
      responses:
        '200':
          description: The currently authenticated user representation.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_29
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/user");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/user");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/user");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL URLWithString:@"https://api.gridx.de/user"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update the authenticated User
      description: >
        Updates the authenticated user by setting the values of the body
        parameters.

        Any parameters not provided will be left unchanged.
      tags:
        - User
      requestBody:
        description: User fields to update.
        required: true
        content:
          application/json:
            schema: *ref_180
      security:
        - BearerAuth:
            - WriteUser
      responses:
        '200':
          description: >-
            The full representation of the user after the partial update on
            success.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_29
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL, "https://api.gridx.de/user");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/user");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user\"\n\n\tpayload := strings.NewReader(\"{\\\"newPassword\\\":\\\"string\\\",\\\"mfaReset\\\":true,\\\"fullName\\\":\\\"John Doe\\\",\\\"email\\\":\\\"john@doe.com\\\",\\\"groups\\\":[{\\\"name\\\":\\\"group name\\\",\\\"description\\\":\\\"Group provides read-access to accounts\\\"}],\\\"mainAddress\\\":{\\\"city\\\":\\\"Aachen\\\",\\\"country\\\":\\\"Germany\\\",\\\"addressLine1\\\":\\\"Oppenhoffallee 143\\\",\\\"addressLine2\\\":\\\"string\\\",\\\"addressLine3\\\":\\\"string\\\",\\\"addressLine4\\\":\\\"string\\\",\\\"postalcode\\\":\\\"52062\\\",\\\"region\\\":\\\"string\\\",\\\"telephone\\\":\\\"string\\\"},\\\"language\\\":{\\\"tag\\\":\\\"de_DE\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/user")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "newPassword": "string",
              "mfaReset": true,
              "fullName": "John Doe",
              "email": "john@doe.com",
              "groups": [
                {
                  "name": "group name",
                  "description": "Group provides read-access to accounts"
                }
              ],
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              },
              "language": {
                "tag": "de_DE"
              }
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/user");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              newPassword: 'string',
              mfaReset: true,
              fullName: 'John Doe',
              email: 'john@doe.com',
              groups: [{name: 'group name', description: 'Group provides read-access to accounts'}],
              mainAddress: {
                city: 'Aachen',
                country: 'Germany',
                addressLine1: 'Oppenhoffallee 143',
                addressLine2: 'string',
                addressLine3: 'string',
                addressLine4: 'string',
                postalcode: '52062',
                region: 'string',
                telephone: 'string'
              },
              language: {tag: 'de_DE'}
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/user',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                newPassword: 'string',
                mfaReset: true,
                fullName: 'John Doe',
                email: 'john@doe.com',
                groups: [{name: 'group name', description: 'Group provides read-access to accounts'}],
                mainAddress: {
                  city: 'Aachen',
                  country: 'Germany',
                  addressLine1: 'Oppenhoffallee 143',
                  addressLine2: 'string',
                  addressLine3: 'string',
                  addressLine4: 'string',
                  postalcode: '52062',
                  region: 'string',
                  telephone: 'string'
                },
                language: {tag: 'de_DE'}
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("PATCH", "https://api.gridx.de/user");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "newPassword": "string",
              "mfaReset": true,
              "fullName": "John Doe",
              "email": "john@doe.com",
              "groups": [
                {
                  "name": "group name",
                  "description": "Group provides read-access to accounts"
                }
              ],
              "mainAddress": {
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              },
              "language": {
                "tag": "de_DE"
              }
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"newPassword": @"string",
                                          @"mfaReset": @YES,
                                          @"fullName": @"John Doe",
                                          @"email": @"john@doe.com",
                                          @"groups": @[ @{ @"name": @"group name", @"description": @"Group provides read-access to accounts" } ],
                                          @"mainAddress": @{ @"city": @"Aachen", @"country": @"Germany", @"addressLine1": @"Oppenhoffallee 143", @"addressLine2": @"string", @"addressLine3": @"string", @"addressLine4": @"string", @"postalcode": @"52062", @"region": @"string", @"telephone": @"string" },
                                          @"language": @{ @"tag": @"de_DE" } };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL URLWithString:@"https://api.gridx.de/user"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group name\",\"description\":\"Group provides read-access to accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee 143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}');


            $request->setRequestUrl('https://api.gridx.de/user');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/user", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/user"


            payload = {
                "newPassword": "string",
                "mfaReset": True,
                "fullName": "John Doe",
                "email": "john@doe.com",
                "groups": [
                    {
                        "name": "group name",
                        "description": "Group provides read-access to accounts"
                    }
                ],
                "mainAddress": {
                    "city": "Aachen",
                    "country": "Germany",
                    "addressLine1": "Oppenhoffallee 143",
                    "addressLine2": "string",
                    "addressLine3": "string",
                    "addressLine4": "string",
                    "postalcode": "52062",
                    "region": "string",
                    "telephone": "string"
                },
                "language": {"tag": "de_DE"}
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/user")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"newPassword\":\"string\",\"mfaReset\":true,\"fullName\":\"John
            Doe\",\"email\":\"john@doe.com\",\"groups\":[{\"name\":\"group
            name\",\"description\":\"Group provides read-access to
            accounts\"}],\"mainAddress\":{\"city\":\"Aachen\",\"country\":\"Germany\",\"addressLine1\":\"Oppenhoffallee
            143\",\"addressLine2\":\"string\",\"addressLine3\":\"string\",\"addressLine4\":\"string\",\"postalcode\":\"52062\",\"region\":\"string\",\"telephone\":\"string\"},\"language\":{\"tag\":\"de_DE\"}}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/user \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"newPassword":"string","mfaReset":true,"fullName":"John Doe","email":"john@doe.com","groups":[{"name":"group name","description":"Group provides read-access to accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}'
        - lang: Shell + Httpie
          source: >-
            echo '{"newPassword":"string","mfaReset":true,"fullName":"John
            Doe","email":"john@doe.com","groups":[{"name":"group
            name","description":"Group provides read-access to
            accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee
            143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}'
            |  \
              http PATCH https://api.gridx.de/user \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"newPassword":"string","mfaReset":true,"fullName":"John Doe","email":"john@doe.com","groups":[{"name":"group name","description":"Group provides read-access to accounts"}],"mainAddress":{"city":"Aachen","country":"Germany","addressLine1":"Oppenhoffallee 143","addressLine2":"string","addressLine3":"string","addressLine4":"string","postalcode":"52062","region":"string","telephone":"string"},"language":{"tag":"de_DE"}}' \
              --output-document \
              - https://api.gridx.de/user
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "newPassword": "string",
              "mfaReset": true,
              "fullName": "John Doe",
              "email": "john@doe.com",
              "groups": [
                [
                  "name": "group name",
                  "description": "Group provides read-access to accounts"
                ]
              ],
              "mainAddress": [
                "city": "Aachen",
                "country": "Germany",
                "addressLine1": "Oppenhoffallee 143",
                "addressLine2": "string",
                "addressLine3": "string",
                "addressLine4": "string",
                "postalcode": "52062",
                "region": "string",
                "telephone": "string"
              ],
              "language": ["tag": "de_DE"]
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/logins:
    get:
      summary: Retrieve the authenticated user's login history
      description: Retrieves the history of the last user logins.
      tags:
        - User
      security:
        - BearerAuth:
            - ListLogins
      responses:
        '200':
          description: Login history of the currently authenticated user.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_472
                  description: >-
                    Represents a user login event that can occur either on login
                    success or failure.
                  type: object
                  properties:
                    createdAt:
                      description: Time when the event occurred in UTC.
                      type: string
                      format: date-time
                      example: '2020-11-10T13:13:00Z'
                      readOnly: true
                    type:
                      description: The type of the login event.
                      type: string
                      example: LOGIN_SUCCESS
                      readOnly: true
                    ip:
                      description: The IP address that caused the login event.
                      type: string
                      format: ipv4
                      example: 8.8.8.8
                      readOnly: true
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/logins");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/user/logins");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/logins\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/logins")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/logins")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/logins",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user/logins");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/logins",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/logins",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/logins',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/user/logins");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/logins"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user/logins" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/logins",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/logins');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/logins');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user/logins", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/logins"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/logins")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/logins \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user/logins \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/logins
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/logins")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/policies:
    get:
      summary: List Policy Documents attached to the authenticated User
      tags:
        - User
      security:
        - BearerAuth:
            - PoliciesRead
      responses:
        '200': &ref_263
          description: The user's policies.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_168
        '500': *ref_4
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/policies");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/user/policies");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/policies\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/policies")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/policies")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/policies",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user/policies");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/policies",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/policies",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/policies',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/user/policies");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/policies"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user/policies" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/policies",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/policies');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/policies');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user/policies", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/policies"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/policies")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/policies \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user/policies \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/policies
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/policies")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/stars/systems:
    get:
      summary: List all starred Systems
      description: List starred systems of the authenticated user.
      tags:
        - Star
      security:
        - BearerAuth:
            - ListStarredSystems
      responses:
        '200':
          description: Starred systems of the authenticated user.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_473
                  description: >
                    Represents a starred system which holds an additional
                    starredAt timestamp.


                    A System represents the logical view of one gateway and its
                    appliances.

                    For example, a household can be represented as a system with
                    a gateway such as a 

                    gridBox, and its connected appliances.
                  allOf:
                    - *ref_72
                    - type: object
                      properties:
                        starredAt:
                          description: Date when the system was starred in RFC3339 format.
                          type: string
                          format: date-time
                          example: '2020-11-10T13:13:00Z'
                          readOnly: true
                      required:
                        - name
                        - createdAt
                        - updatedAt
                        - starredAt
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/stars/systems");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/stars/systems");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/stars/systems\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/stars/systems")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/stars/systems")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/systems",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user/stars/systems");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/systems",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/stars/systems",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/stars/systems',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/user/stars/systems");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/stars/systems"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user/stars/systems" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/stars/systems",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/stars/systems');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/stars/systems');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user/stars/systems", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/stars/systems"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/stars/systems")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/stars/systems \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user/stars/systems \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/stars/systems
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/stars/systems")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/user/stars/systems/{systemID}':
    put:
      summary: Star a System
      description: Marks a system as favorite by starring it.
      tags:
        - Star
      parameters:
        - name: systemID
          in: path
          description: Identifier of the system to be starred.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      security:
        - BearerAuth:
            - StarSystem
      responses:
        '204':
          description: Successfully starred system.
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: System not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/stars/systems/%7BsystemID%7D");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/stars/systems/%7BsystemID%7D\"\n\n\treq, _ := http.NewRequest(\"PUT\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/stars/systems/%7BsystemID%7D")
              .put(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/user/stars/systems/%7BsystemID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/systems/%7BsystemID%7D",
              "method": "PUT",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/systems/%7BsystemID%7D",
              "method": "PUT",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/stars/systems/%7BsystemID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/user/stars/systems/%7BsystemID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/stars/systems/%7BsystemID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/stars/systems/%7BsystemID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/stars/systems/%7BsystemID%7D');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/stars/systems/%7BsystemID%7D');

            $request->setRequestMethod('PUT');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("PUT", "/user/stars/systems/%7BsystemID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/stars/systems/%7BsystemID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("PUT", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/stars/systems/%7BsystemID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Put.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/user/stars/systems/%7BsystemID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http PUT https://api.gridx.de/user/stars/systems/%7BsystemID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/stars/systems/%7BsystemID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Unstar a System
      description: Removes a system from favorites by unstarring it.
      tags:
        - Star
      parameters:
        - name: systemID
          in: path
          description: Identifier of the system to be unstarred.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      security:
        - BearerAuth:
            - UnstarSystem
      responses:
        '204':
          description: Successfully unstarred system.
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/stars/systems/%7BsystemID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/stars/systems/%7BsystemID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/stars/systems/%7BsystemID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/user/stars/systems/%7BsystemID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/systems/%7BsystemID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/systems/%7BsystemID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/stars/systems/%7BsystemID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/user/stars/systems/%7BsystemID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/stars/systems/%7BsystemID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/stars/systems/%7BsystemID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/stars/systems/%7BsystemID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/stars/systems/%7BsystemID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE", "/user/stars/systems/%7BsystemID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/stars/systems/%7BsystemID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/stars/systems/%7BsystemID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/user/stars/systems/%7BsystemID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/user/stars/systems/%7BsystemID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/stars/systems/%7BsystemID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/stars/systems/%7BsystemID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/stars/accounts:
    get:
      summary: List all starred Accounts
      description: Lists all starred accounts for the authenticated user.
      tags:
        - Star
      security:
        - BearerAuth:
            - ListAccounts
      responses:
        '200':
          description: Starred accounts of the currently authenticated user.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_474
                  description: >
                    Represents a starred account which holds an additional
                    starredAt timestamp.
                  allOf:
                    - *ref_10
                    - type: object
                      properties:
                        starredAt:
                          description: >-
                            Time when the account was starred in UTC (RFC 3339
                            format).
                          type: string
                          format: date-time
                          example: '2020-11-10T13:13:00Z'
                          readOnly: true
                      required:
                        - starredAt
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/stars/accounts");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/stars/accounts");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/stars/accounts\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/stars/accounts")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/stars/accounts")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/accounts",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user/stars/accounts");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/accounts",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/stars/accounts",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/stars/accounts',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/user/stars/accounts");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/stars/accounts"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user/stars/accounts"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/stars/accounts",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/stars/accounts');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/stars/accounts');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user/stars/accounts", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/stars/accounts"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/stars/accounts")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/stars/accounts \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user/stars/accounts \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/stars/accounts
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/stars/accounts")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/user/stars/accounts/{accountID}':
    put:
      summary: Star an Account
      description: Marks an account as favorite by starring it.
      tags:
        - Star
      parameters:
        - name: accountID
          in: path
          description: Identifier of the account to be starred.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      security:
        - BearerAuth:
            - StarAccount
      responses:
        '204':
          description: Account starred successfully.
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: Account not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PUT");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");

            var request = new RestRequest(Method.PUT);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/stars/accounts/%7BaccountID%7D\"\n\n\treq, _ := http.NewRequest(\"PUT\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")
              .put(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.put("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D",
              "method": "PUT",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PUT",
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D",
              "method": "PUT",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PUT",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/stars/accounts/%7BaccountID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PUT',
              url: 'https://api.gridx.de/user/stars/accounts/%7BaccountID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PUT",
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/stars/accounts/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PUT"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `PUT uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PUT",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/stars/accounts/%7BaccountID%7D');

            $request->setMethod(HTTP_METH_PUT);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/stars/accounts/%7BaccountID%7D');

            $request->setRequestMethod('PUT');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("PUT", "/user/stars/accounts/%7BaccountID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("PUT", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Put.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PUT \
              --url https://api.gridx.de/user/stars/accounts/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http PUT https://api.gridx.de/user/stars/accounts/%7BaccountID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PUT \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/stars/accounts/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PUT"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Unstar an Account
      description: Removes a given account from favorites by unstarring it.
      tags:
        - Star
      parameters:
        - name: accountID
          in: path
          description: Identifier of the account to be starred.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      security:
        - BearerAuth:
            - UnstarAccount
      responses:
        '204':
          description: Account unstarred successfully.
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/stars/accounts/%7BaccountID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/stars/accounts/%7BaccountID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/user/stars/accounts/%7BaccountID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/stars/accounts/%7BaccountID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/stars/accounts/%7BaccountID%7D');

            $request->setMethod(HTTP_METH_DELETE);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/stars/accounts/%7BaccountID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE", "/user/stars/accounts/%7BaccountID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Delete.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/user/stars/accounts/%7BaccountID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http DELETE https://api.gridx.de/user/stars/accounts/%7BaccountID%7D
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/stars/accounts/%7BaccountID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/stars/accounts/%7BaccountID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/accounts:
    get:
      summary: Get user accounts
      description: Returns a list of accounts the authenticated user can switch to.
      tags:
        - Account
        - User
      security:
        - BearerAuth:
            - ListAccounts
      responses:
        '200': &ref_264
          description: List of the accounts the user can access.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: &ref_475
                  description: >
                    An account describes an organizational unit to manage access
                    to systems for one or multiple users.
                  allOf:
                    - *ref_7
                    - properties:
                        id:
                          type: string
                          format: uuid
                          example: 49a4f165-8233-426b-a1a4-e569665a25dd
                          description: Uniquely identifies the account.
                        parentID:
                          type: string
                          format: uuid
                          example: 19a4f165-8233-426b-a1a4-e569665a25dd
                          description: >-
                            Parent of the account for a tree-like account
                            structure. Only the root account does not have a
                            parent ID.
                        kind: *ref_8
                        createdAt:
                          type: string
                          format: date-time
                          description: Specifies when the account was created.
                        updatedAt:
                          type: string
                          format: date-time
                          description: Specifies when the account was updated.
                      required:
                        - id
                        - createdAt
                        - updatedAt
                        - kind
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: Account not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/accounts");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: |-
            var client = new RestClient("https://api.gridx.de/user/accounts");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/accounts\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/accounts")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/accounts")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/accounts",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user/accounts");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/accounts",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/accounts",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/accounts',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/user/accounts");

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/accounts"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user/accounts" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/accounts",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/accounts');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/accounts');
            $request->setRequestMethod('GET');
            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user/accounts", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/accounts"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/accounts")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/accounts \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user/accounts \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/accounts
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/accounts")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/notifications:
    get:
      summary: List Notifications
      description: Lists dashboard notifications the authenticated user.
      tags:
        - Notification
      security:
        - BearerAuth:
            - ListNotifications
      parameters:
        - *ref_18
        - *ref_17
        - name: unread
          description: List only unread notifications.
          in: query
          schema:
            type: boolean
      responses:
        '200':
          description: Dashboard notifications.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_37
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/notifications',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                unread: 'SOME_BOOLEAN_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/user/notifications");


            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "unread": "SOME_BOOLEAN_VALUE"
            });


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/notifications');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'unread' => 'SOME_BOOLEAN_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/notifications');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'unread' => 'SOME_BOOLEAN_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/user/notifications"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","unread":"SOME_BOOLEAN_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/notifications?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&unread=SOME_BOOLEAN_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/user/notifications/{notificationID}':
    get:
      summary: Retrieve a Notification
      description: Retrieves specific dashboard notification of the authenticated user.
      parameters:
        - *ref_38
      tags:
        - Notification
      security:
        - BearerAuth:
            - GetNotification
      responses:
        '200':
          description: Dashboard notification.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_37
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: Dashboard notification not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/notifications/%7BnotificationID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/notifications/%7BnotificationID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/notifications/%7BnotificationID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/notifications/%7BnotificationID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/notifications/%7BnotificationID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/notifications/%7BnotificationID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/notifications/%7BnotificationID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/notifications/%7BnotificationID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/notifications/%7BnotificationID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/notifications/%7BnotificationID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/notifications/%7BnotificationID%7D');

            $request->setMethod(HTTP_METH_GET);


            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/notifications/%7BnotificationID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET", "/user/notifications/%7BnotificationID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/notifications/%7BnotificationID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/user/notifications/%7BnotificationID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/notifications/%7BnotificationID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            https://api.gridx.de/user/notifications/%7BnotificationID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/notifications/%7BnotificationID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update a Notification
      description: Updates a dashboard notification of the authenticated user.
      parameters:
        - *ref_38
      tags:
        - Notification
      security:
        - BearerAuth: []
      requestBody:
        description: Modified Notification
        required: true
        content:
          application/json:
            schema: &ref_477
              allOf:
                - &ref_476
                  allOf:
                    - *ref_181
                - additionalProperties: false
      responses:
        '200':
          description: Dashboard notification.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_181
        '400': *ref_3
        '403': *ref_11
        '404': *ref_55
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS,
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/notifications/%7BnotificationID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json",
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/notifications/%7BnotificationID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"eventType\\\":\\\"string\\\",\\\"systemID\\\":\\\"49a4f165-8233-426b-a1a4-e569665a25dd\\\",\\\"content\\\":\\\"string\\\",\\\"read\\\":true,\\\"timestamp\\\":\\\"2019-08-24T14:15:22Z\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/notifications/%7BnotificationID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/user/notifications/%7BnotificationID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/notifications/%7BnotificationID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH",
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/notifications/%7BnotificationID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/notifications/%7BnotificationID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              eventType: 'string',
              systemID: '49a4f165-8233-426b-a1a4-e569665a25dd',
              content: 'string',
              read: true,
              timestamp: '2019-08-24T14:15:22Z'
            }));
            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/user/notifications/%7BnotificationID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {
                eventType: 'string',
                systemID: '49a4f165-8233-426b-a1a4-e569665a25dd',
                content: 'string',
                read: true,
                timestamp: '2019-08-24T14:15:22Z'
              },
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"eventType": @"string",
                                          @"systemID": @"49a4f165-8233-426b-a1a4-e569665a25dd",
                                          @"content": @"string",
                                          @"read": @YES,
                                          @"timestamp": @"2019-08-24T14:15:22Z" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/notifications/%7BnotificationID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"
            in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/notifications/%7BnotificationID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/notifications/%7BnotificationID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}');


            $request->setRequestUrl('https://api.gridx.de/user/notifications/%7BnotificationID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload =
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/user/notifications/%7BnotificationID%7D",
            payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/user/notifications/%7BnotificationID%7D"


            payload = {
                "eventType": "string",
                "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
                "content": "string",
                "read": True,
                "timestamp": "2019-08-24T14:15:22Z"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/user/notifications/%7BnotificationID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body =
            "{\"eventType\":\"string\",\"systemID\":\"49a4f165-8233-426b-a1a4-e569665a25dd\",\"content\":\"string\",\"read\":true,\"timestamp\":\"2019-08-24T14:15:22Z\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/user/notifications/%7BnotificationID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}'
        - lang: Shell + Httpie
          source: >-
            echo
            '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}'
            |  \
              http PATCH https://api.gridx.de/user/notifications/%7BnotificationID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"eventType":"string","systemID":"49a4f165-8233-426b-a1a4-e569665a25dd","content":"string","read":true,"timestamp":"2019-08-24T14:15:22Z"}' \
              --output-document \
              - https://api.gridx.de/user/notifications/%7BnotificationID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "eventType": "string",
              "systemID": "49a4f165-8233-426b-a1a4-e569665a25dd",
              "content": "string",
              "read": true,
              "timestamp": "2019-08-24T14:15:22Z"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/notifications/%7BnotificationID%7D")! as
            URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  /user/tokens:
    get:
      summary: List all Tokens
      description: Lists all the API tokens for the authenticated user.
      tags:
        - Token
      security:
        - BearerAuth:
            - GetAPITokens
      parameters:
        - *ref_18
        - *ref_17
        - *ref_67
        - *ref_70
      responses:
        '200':
          description: API tokens of the current user.
          content:
            application/vnd.gridx.v2+json:
              schema:
                type: array
                items: *ref_182
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET",
            "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/tokens',
              qs: {
                page: 'SOME_INTEGER_VALUE',
                per_page: 'SOME_INTEGER_VALUE',
                sort: 'SOME_STRING_VALUE',
                order: 'SOME_STRING_VALUE'
              },
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("GET", "https://api.gridx.de/user/tokens");

            req.query({
              "page": "SOME_INTEGER_VALUE",
              "per_page": "SOME_INTEGER_VALUE",
              "sort": "SOME_STRING_VALUE",
              "order": "SOME_STRING_VALUE"
            });

            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE"
            in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/tokens');
            $request->setMethod(HTTP_METH_GET);

            $request->setQueryData([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE',
              'order' => 'SOME_STRING_VALUE'
            ]);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: |-
            <?php

            $client = new http\Client;
            $request = new http\Client\Request;

            $request->setRequestUrl('https://api.gridx.de/user/tokens');
            $request->setRequestMethod('GET');
            $request->setQuery(new http\QueryString([
              'page' => 'SOME_INTEGER_VALUE',
              'per_page' => 'SOME_INTEGER_VALUE',
              'sort' => 'SOME_STRING_VALUE',
              'order' => 'SOME_STRING_VALUE'
            ]));

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            $client->enqueue($request)->send();
            $response = $client->getResponse();

            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("GET",
            "/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/user/tokens"


            querystring =
            {"page":"SOME_INTEGER_VALUE","per_page":"SOME_INTEGER_VALUE","sort":"SOME_STRING_VALUE","order":"SOME_STRING_VALUE"}


            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}


            response = requests.request("GET", url, headers=headers,
            params=querystring)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url =
            URI("https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Get.new(url)

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url 'https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: >-
            http GET
            'https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE'
            \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - 'https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE'
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/tokens?page=SOME_INTEGER_VALUE&per_page=SOME_INTEGER_VALUE&sort=SOME_STRING_VALUE&order=SOME_STRING_VALUE")!
            as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    post:
      summary: Create a Token
      tags:
        - Token
      security:
        - BearerAuth:
            - APITokenWrite
      requestBody:
        required: true
        content:
          application/json:
            schema: &ref_478
              allOf:
                - *ref_13
                - additionalProperties: false
      responses:
        '201':
          description: API token created.
          content:
            application/vnd.gridx.v2+json:
              schema: &ref_479
                title: PersonalAPITokenWithSecret
                allOf:
                  - *ref_182
                  - properties:
                      token:
                        type: string
                        description: >
                          This token can be used for authenticating further
                          requests as an alternative to Bearer Authentication.


                          Example: Set the header field `Authorization` to
                          `Token gxp_SUDJmIoABC1337JiAuKBZuauC0ff331HNPR0`. 

                          The permissions of this tokens are the same as the
                          user that created it.


                          **ATTENTION** - Please keep the token secret and treat
                          it like a password! The token is only available
                          immediately after creation and can not be retrieved
                          again afterwards.
                        example: gxp_SUDJmIoABC1337JiAuKBZuauC0ff331HNPR0
                    required:
                      - token
        '400':
          description: Bad Request
        '403':
          description: Forbidden (missing authorization)
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "POST");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/tokens");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new RestClient("https://api.gridx.de/user/tokens");

            var request = new RestRequest(Method.POST);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/tokens\"\n\n\tpayload := strings.NewReader(\"{\\\"description\\\":\\\"My api token\\\",\\\"expiresAt\\\":\\\"2021-11-10T23:00:00Z\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/tokens")
              .post(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.post("https://api.gridx.de/user/tokens")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("POST", "https://api.gridx.de/user/tokens");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens",
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "POST",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/tokens",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({description: 'My api token', expiresAt:
            '2021-11-10T23:00:00Z'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'POST',
              url: 'https://api.gridx.de/user/tokens',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {description: 'My api token', expiresAt: '2021-11-10T23:00:00Z'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: |
            const unirest = require("unirest");

            const req = unirest("POST", "https://api.gridx.de/user/tokens");

            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });

            req.type("json");
            req.send({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z"
            });

            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"description": @"My api token",
                                          @"expiresAt": @"2021-11-10T23:00:00Z" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/tokens"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"POST"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string "https://api.gridx.de/user/tokens" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}" in


            Client.call ~headers ~body `POST uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/tokens",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "POST",
              CURLOPT_POSTFIELDS => "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/tokens');

            $request->setMethod(HTTP_METH_POST);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z"}');


            $request->setRequestUrl('https://api.gridx.de/user/tokens');

            $request->setRequestMethod('POST');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("POST", "/user/tokens", payload, headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/user/tokens"


            payload = {
                "description": "My api token",
                "expiresAt": "2021-11-10T23:00:00Z"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("POST", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/user/tokens")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Post.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request POST \
              --url https://api.gridx.de/user/tokens \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z"}' |  \
              http POST https://api.gridx.de/user/tokens \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method POST \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z"}' \
              --output-document \
              - https://api.gridx.de/user/tokens
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/tokens")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "POST"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
  '/user/tokens/{tokenID}':
    get:
      summary: Retrieve a Token
      description: Retrieves the given API token for the authenticated user.
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      tags:
        - Token
      security:
        - BearerAuth:
            - GetAPIToken
      responses:
        '200':
          description: API token of the current user.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_182
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "GET");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/tokens/%7BtokenID%7D");

            var request = new RestRequest(Method.GET);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/tokens/%7BtokenID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/tokens/%7BtokenID%7D")
              .get()
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.get("https://api.gridx.de/user/tokens/%7BtokenID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("GET", "https://api.gridx.de/user/tokens/%7BtokenID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              "method": "GET",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "GET",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/tokens/%7BtokenID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'GET',
              url: 'https://api.gridx.de/user/tokens/%7BtokenID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("GET",
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/tokens/%7BtokenID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"GET"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/tokens/%7BtokenID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `GET uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "GET",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/tokens/%7BtokenID%7D');
            $request->setMethod(HTTP_METH_GET);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/tokens/%7BtokenID%7D');

            $request->setRequestMethod('GET');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: |-
            import http.client

            conn = http.client.HTTPSConnection("api.gridx.de")

            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }

            conn.request("GET", "/user/tokens/%7BtokenID%7D", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/tokens/%7BtokenID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("GET", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/tokens/%7BtokenID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Get.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request GET \
              --url https://api.gridx.de/user/tokens/%7BtokenID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http GET https://api.gridx.de/user/tokens/%7BtokenID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method GET \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/tokens/%7BtokenID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/tokens/%7BtokenID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "GET"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    patch:
      summary: Update a Token
      description: |
        Updates the specific token by setting the values of the body parameters.
        Any parameters not provided will be left unchanged. 
      tags:
        - Token
      security:
        - BearerAuth:
            - UpdateAPIToken
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token to be updated.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      requestBody:
        description: Update Token
        required: true
        content:
          application/json:
            schema: &ref_481
              allOf:
                - &ref_480
                  allOf:
                    - *ref_13
                - additionalProperties: false
      responses:
        '200':
          description: >-
            The full representation of the token after the partial update on
            success.
          content:
            application/vnd.gridx.v2+json:
              schema: *ref_182
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "PATCH");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "content-type:
            application/json");

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}");


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/tokens/%7BtokenID%7D");

            var request = new RestRequest(Method.PATCH);

            request.AddHeader("content-type", "application/json");

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            request.AddParameter("application/json", "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}",
            ParameterType.RequestBody);

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/tokens/%7BtokenID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"description\\\":\\\"My api token\\\",\\\"expiresAt\\\":\\\"2021-11-10T23:00:00Z\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: >-
            OkHttpClient client = new OkHttpClient();


            MediaType mediaType = MediaType.parse("application/json");

            RequestBody body = RequestBody.create(mediaType,
            "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}");

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/tokens/%7BtokenID%7D")
              .patch(body)
              .addHeader("content-type", "application/json")
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.patch("https://api.gridx.de/user/tokens/%7BtokenID%7D")
              .header("content-type", "application/json")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .body("{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = JSON.stringify({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z"
            });


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("PATCH", "https://api.gridx.de/user/tokens/%7BtokenID%7D");

            xhr.setRequestHeader("content-type", "application/json");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              "method": "PATCH",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              },
              "processData": false,
              "data": "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: >-
            const http = require("https");


            const options = {
              "method": "PATCH",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/tokens/%7BtokenID%7D",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };


            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });


            req.write(JSON.stringify({description: 'My api token', expiresAt:
            '2021-11-10T23:00:00Z'}));

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'PATCH',
              url: 'https://api.gridx.de/user/tokens/%7BtokenID%7D',
              headers: {
                'content-type': 'application/json',
                Authorization: 'Bearer REPLACE_BEARER_TOKEN'
              },
              body: {description: 'My api token', expiresAt: '2021-11-10T23:00:00Z'},
              json: true
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("PATCH",
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");


            req.headers({
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.type("json");

            req.send({
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"content-type": @"application/json",
                                       @"Authorization": @"Bearer REPLACE_BEARER_TOKEN" };
            NSDictionary *parameters = @{ @"description": @"My api token",
                                          @"expiresAt": @"2021-11-10T23:00:00Z" };

            NSData *postData = [NSJSONSerialization
            dataWithJSONObject:parameters options:0 error:nil];


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/tokens/%7BtokenID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"PATCH"];

            [request setAllHTTPHeaderFields:headers];

            [request setHTTPBody:postData];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/tokens/%7BtokenID%7D" in

            let headers = Header.add_list (Header.init ()) [
              ("content-type", "application/json");
              ("Authorization", "Bearer REPLACE_BEARER_TOKEN");
            ] in

            let body = Cohttp_lwt_body.of_string "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}" in


            Client.call ~headers ~body `PATCH uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "PATCH",
              CURLOPT_POSTFIELDS => "{\"description\":\"My api token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN",
                "content-type: application/json"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: >-
            <?php


            HttpRequest::methodRegister('PATCH');

            $request = new HttpRequest();

            $request->setUrl('https://api.gridx.de/user/tokens/%7BtokenID%7D');

            $request->setMethod(HttpRequest::HTTP_METH_PATCH);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $request->setBody('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z"}');


            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $body = new http\Message\Body;

            $body->append('{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z"}');


            $request->setRequestUrl('https://api.gridx.de/user/tokens/%7BtokenID%7D');

            $request->setRequestMethod('PATCH');

            $request->setBody($body);


            $request->setHeaders([
              'content-type' => 'application/json',
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            payload = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"


            headers = {
                'content-type': "application/json",
                'Authorization': "Bearer REPLACE_BEARER_TOKEN"
                }

            conn.request("PATCH", "/user/tokens/%7BtokenID%7D", payload,
            headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: >-
            import requests


            url = "https://api.gridx.de/user/tokens/%7BtokenID%7D"


            payload = {
                "description": "My api token",
                "expiresAt": "2021-11-10T23:00:00Z"
            }

            headers = {
                "content-type": "application/json",
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            }


            response = requests.request("PATCH", url, json=payload,
            headers=headers)


            print(response.text)
        - lang: Ruby + Native
          source: >-
            require 'uri'

            require 'net/http'

            require 'openssl'


            url = URI("https://api.gridx.de/user/tokens/%7BtokenID%7D")


            http = Net::HTTP.new(url.host, url.port)

            http.use_ssl = true

            http.verify_mode = OpenSSL::SSL::VERIFY_NONE


            request = Net::HTTP::Patch.new(url)

            request["content-type"] = 'application/json'

            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            request.body = "{\"description\":\"My api
            token\",\"expiresAt\":\"2021-11-10T23:00:00Z\"}"


            response = http.request(request)

            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request PATCH \
              --url https://api.gridx.de/user/tokens/%7BtokenID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --header 'content-type: application/json' \
              --data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z"}'
        - lang: Shell + Httpie
          source: >-
            echo '{"description":"My api
            token","expiresAt":"2021-11-10T23:00:00Z"}' |  \
              http PATCH https://api.gridx.de/user/tokens/%7BtokenID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN' \
              content-type:application/json
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method PATCH \
              --header 'content-type: application/json' \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --body-data '{"description":"My api token","expiresAt":"2021-11-10T23:00:00Z"}' \
              --output-document \
              - https://api.gridx.de/user/tokens/%7BtokenID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = [
              "content-type": "application/json",
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            ]

            let parameters = [
              "description": "My api token",
              "expiresAt": "2021-11-10T23:00:00Z"
            ] as [String : Any]


            let postData = JSONSerialization.data(withJSONObject: parameters,
            options: [])


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/tokens/%7BtokenID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "PATCH"

            request.allHTTPHeaderFields = headers

            request.httpBody = postData as Data


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
    delete:
      summary: Delete a Token
      description: Removes a given token from the authenticated user.
      tags:
        - Token
      parameters:
        - name: tokenID
          in: path
          description: Identifier of the token.
          required: true
          example: 218e8795-2442-42d7-901b-1588373e527f
          schema:
            type: string
            format: uuid
      security:
        - BearerAuth:
            - DeleteAPIToken
      responses:
        '204':
          description: API token deleted successfully.
        '403':
          description: Forbidden (missing authorization)
        '404':
          description: API token not found.
        '500':
          description: Internal Server Error
      x-codeSamples:
        - lang: C + Libcurl
          source: >-
            CURL *hnd = curl_easy_init();


            curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "DELETE");

            curl_easy_setopt(hnd, CURLOPT_URL,
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");


            struct curl_slist *headers = NULL;

            headers = curl_slist_append(headers, "Authorization: Bearer
            REPLACE_BEARER_TOKEN");

            curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);


            CURLcode ret = curl_easy_perform(hnd);
        - lang: Csharp + Restsharp
          source: >-
            var client = new
            RestClient("https://api.gridx.de/user/tokens/%7BtokenID%7D");

            var request = new RestRequest(Method.DELETE);

            request.AddHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN");

            IRestResponse response = client.Execute(request);
        - lang: Go + Native
          source: "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://api.gridx.de/user/tokens/%7BtokenID%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"Authorization\", \"Bearer REPLACE_BEARER_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}"
        - lang: Java + Okhttp
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("https://api.gridx.de/user/tokens/%7BtokenID%7D")
              .delete(null)
              .addHeader("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .build();

            Response response = client.newCall(request).execute();
        - lang: Java + Unirest
          source: >-
            HttpResponse<String> response =
            Unirest.delete("https://api.gridx.de/user/tokens/%7BtokenID%7D")
              .header("Authorization", "Bearer REPLACE_BEARER_TOKEN")
              .asString();
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Javascript + Xhr
          source: >-
            const data = null;


            const xhr = new XMLHttpRequest();

            xhr.withCredentials = true;


            xhr.addEventListener("readystatechange", function () {
              if (this.readyState === this.DONE) {
                console.log(this.responseText);
              }
            });


            xhr.open("DELETE",
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");

            xhr.setRequestHeader("Authorization", "Bearer
            REPLACE_BEARER_TOKEN");


            xhr.send(data);
        - lang: Javascript + Jquery
          source: |-
            const settings = {
              "async": true,
              "crossDomain": true,
              "url": "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            $.ajax(settings).done(function (response) {
              console.log(response);
            });
        - lang: Node + Native
          source: |-
            const http = require("https");

            const options = {
              "method": "DELETE",
              "hostname": "api.gridx.de",
              "port": null,
              "path": "/user/tokens/%7BtokenID%7D",
              "headers": {
                "Authorization": "Bearer REPLACE_BEARER_TOKEN"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Node + Request
          source: |
            const request = require('request');

            const options = {
              method: 'DELETE',
              url: 'https://api.gridx.de/user/tokens/%7BtokenID%7D',
              headers: {Authorization: 'Bearer REPLACE_BEARER_TOKEN'}
            };

            request(options, function (error, response, body) {
              if (error) throw new Error(error);

              console.log(body);
            });
        - lang: Node + Unirest
          source: >
            const unirest = require("unirest");


            const req = unirest("DELETE",
            "https://api.gridx.de/user/tokens/%7BtokenID%7D");


            req.headers({
              "Authorization": "Bearer REPLACE_BEARER_TOKEN"
            });


            req.end(function (res) {
              if (res.error) throw new Error(res.error);

              console.log(res.body);
            });
        - lang: Objc + Nsurlsession
          source: >-
            #import <Foundation/Foundation.h>


            NSDictionary *headers = @{ @"Authorization": @"Bearer
            REPLACE_BEARER_TOKEN" };


            NSMutableURLRequest *request = [NSMutableURLRequest
            requestWithURL:[NSURL
            URLWithString:@"https://api.gridx.de/user/tokens/%7BtokenID%7D"]
                                                                   cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                               timeoutInterval:10.0];
            [request setHTTPMethod:@"DELETE"];

            [request setAllHTTPHeaderFields:headers];


            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionDataTask *dataTask = [session
            dataTaskWithRequest:request
                                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                            if (error) {
                                                                NSLog(@"%@", error);
                                                            } else {
                                                                NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                                NSLog(@"%@", httpResponse);
                                                            }
                                                        }];
            [dataTask resume];
        - lang: Ocaml + Cohttp
          source: >-
            open Cohttp_lwt_unix

            open Cohttp

            open Lwt


            let uri = Uri.of_string
            "https://api.gridx.de/user/tokens/%7BtokenID%7D" in

            let headers = Header.add (Header.init ()) "Authorization" "Bearer
            REPLACE_BEARER_TOKEN" in


            Client.call ~headers `DELETE uri

            >>= fun (res, body_stream) ->
              (* Do stuff with the result *)
        - lang: Php + Curl
          source: |-
            <?php

            $curl = curl_init();

            curl_setopt_array($curl, [
              CURLOPT_URL => "https://api.gridx.de/user/tokens/%7BtokenID%7D",
              CURLOPT_RETURNTRANSFER => true,
              CURLOPT_ENCODING => "",
              CURLOPT_MAXREDIRS => 10,
              CURLOPT_TIMEOUT => 30,
              CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
              CURLOPT_CUSTOMREQUEST => "DELETE",
              CURLOPT_HTTPHEADER => [
                "Authorization: Bearer REPLACE_BEARER_TOKEN"
              ],
            ]);

            $response = curl_exec($curl);
            $err = curl_error($curl);

            curl_close($curl);

            if ($err) {
              echo "cURL Error #:" . $err;
            } else {
              echo $response;
            }
        - lang: Php + Http1
          source: |-
            <?php

            $request = new HttpRequest();
            $request->setUrl('https://api.gridx.de/user/tokens/%7BtokenID%7D');
            $request->setMethod(HTTP_METH_DELETE);

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);

            try {
              $response = $request->send();

              echo $response->getBody();
            } catch (HttpException $ex) {
              echo $ex;
            }
        - lang: Php + Http2
          source: >-
            <?php


            $client = new http\Client;

            $request = new http\Client\Request;


            $request->setRequestUrl('https://api.gridx.de/user/tokens/%7BtokenID%7D');

            $request->setRequestMethod('DELETE');

            $request->setHeaders([
              'Authorization' => 'Bearer REPLACE_BEARER_TOKEN'
            ]);


            $client->enqueue($request)->send();

            $response = $client->getResponse();


            echo $response->getBody();
        - lang: Python + Python3
          source: >-
            import http.client


            conn = http.client.HTTPSConnection("api.gridx.de")


            headers = { 'Authorization': "Bearer REPLACE_BEARER_TOKEN" }


            conn.request("DELETE", "/user/tokens/%7BtokenID%7D",
            headers=headers)


            res = conn.getresponse()

            data = res.read()


            print(data.decode("utf-8"))
        - lang: Python + Requests
          source: |-
            import requests

            url = "https://api.gridx.de/user/tokens/%7BtokenID%7D"

            headers = {"Authorization": "Bearer REPLACE_BEARER_TOKEN"}

            response = requests.request("DELETE", url, headers=headers)

            print(response.text)
        - lang: Ruby + Native
          source: |-
            require 'uri'
            require 'net/http'
            require 'openssl'

            url = URI("https://api.gridx.de/user/tokens/%7BtokenID%7D")

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_NONE

            request = Net::HTTP::Delete.new(url)
            request["Authorization"] = 'Bearer REPLACE_BEARER_TOKEN'

            response = http.request(request)
            puts response.read_body
        - lang: Shell + Curl
          source: |-
            curl --request DELETE \
              --url https://api.gridx.de/user/tokens/%7BtokenID%7D \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Httpie
          source: |-
            http DELETE https://api.gridx.de/user/tokens/%7BtokenID%7D \
              Authorization:'Bearer REPLACE_BEARER_TOKEN'
        - lang: Shell + Wget
          source: |-
            wget --quiet \
              --method DELETE \
              --header 'Authorization: Bearer REPLACE_BEARER_TOKEN' \
              --output-document \
              - https://api.gridx.de/user/tokens/%7BtokenID%7D
        - lang: Swift + Nsurlsession
          source: >-
            import Foundation


            let headers = ["Authorization": "Bearer REPLACE_BEARER_TOKEN"]


            let request = NSMutableURLRequest(url: NSURL(string:
            "https://api.gridx.de/user/tokens/%7BtokenID%7D")! as URL,
                                                    cachePolicy: .useProtocolCachePolicy,
                                                timeoutInterval: 10.0)
            request.httpMethod = "DELETE"

            request.allHTTPHeaderFields = headers


            let session = URLSession.shared

            let dataTask = session.dataTask(with: request as URLRequest,
            completionHandler: { (data, response, error) -> Void in
              if (error != nil) {
                print(error)
              } else {
                let httpResponse = response as? HTTPURLResponse
                print(httpResponse)
              }
            })


            dataTask.resume()
components:
  parameters:
    tariffID: *ref_59
    documentKey: *ref_30
    ruleID: *ref_43
    planID: *ref_46
    tagID: *ref_47
    kind: *ref_22
    prefix: *ref_183
    accountID: *ref_1
    page: *ref_18
    perPage: *ref_17
    sort: *ref_67
    embed: *ref_78
    groupID: *ref_35
    userID: *ref_36
    deleteAuth0: *ref_69
    notificationID: *ref_38
    applianceID: *ref_54
    memberID: *ref_66
    clusterID: *ref_64
    customerID: *ref_71
    order: *ref_70
    systemID: *ref_74
    gatewayID: *ref_75
    listAll: *ref_184
    evProfileID: *ref_128
    jobIDOrType: *ref_90
    ToUForecastsTimeInterval: *ref_150
    interval: *ref_119
    scheduleID: *ref_131
    saving: *ref_185
    resolution: *ref_186
    policyID: *ref_172
    statementID: *ref_187
    functionalityID: *ref_174
    optionID: *ref_178
    deviceID: *ref_188
    sequenceID: *ref_189
  requestBodies:
    CreateScanConfigRequestBody: *ref_190
    UpdateScanConfigRequestBody: *ref_191
    AssignPolicyDocumentToAccountRequestBody: *ref_192
    CreatePolicyGroupRequestBody: *ref_193
    UpdateNotificationRuleRequestBody: *ref_194
    CreateNotificationRuleRequestBody: *ref_195
    CreateUserNotificationsRequestBody: *ref_196
    UpdateUserNotificationsRequestBody: *ref_197
    CreateRFIDTagRequestBody:
      description: Creates RFID tag.
      required: true
      content:
        application/json:
          schema: *ref_198
    UpdateRFIDTagRequestBody: *ref_199
    AccountUpdateRequestBody: *ref_20
    AccountCreateRequestBody: *ref_200
    MoveAccountRequestBody: *ref_201
    AssignSystemToAccount: *ref_73
    UnassignSystemToAccount: *ref_202
    CreateAssetRequestBody:
      description: Creates an asset.
      required: true
      content:
        application/json:
          schema:
            properties:
              id:
                type: string
                format: uuid
              name:
                type: string
                example: Some Human-Readable Asset Name
              applicationId:
                type: string
                format: uuid
              system:
                description: >-
                  Minimal information about the System in which the Asset is
                  being created.
                type: object
                properties:
                  id:
                    type: string
                    format: uuid
                required:
                  - id
              manufacturer:
                type: string
                example: TQ-Systems
              model:
                type: string
                example: B-control Energy Manager 300
              serialNumber:
                type: string
                example: 3cdae5c3c30c53b9
              priority:
                type: boolean
                default: false
              lastHeartbeatReceivedAt:
                type: string
                format: date-time
                description: At what time the last heartbeat was received.
              driverVersion:
                type: string
                example: v1.0.1
              type:
                type: string
                enum:
                  - CONTAINER
                  - EVSTATION
                  - HEAT_PUMP
                  - HEATER
                  - INVERTER
                  - IO_DEVICE
                  - METER
                  - UNKNOWN
              kind:
                type: string
                enum:
                  - BATTERY
                  - BTTP
                  - CLUSTER
                  - CONTAINER
                  - EVSTATION
                  - FUEL_CELL
                  - GRID
                  - HEAT_PUMP
                  - HEAT_PUMP_EXTERNAL
                  - HEATER
                  - HEATING
                  - HYBRID
                  - IO_DEVICE
                  - MISC
                  - PV
                  - PV_EXTERNAL
                  - UNKNOWN
                  - WIND_TURBINE
              metadata:
                type: string
                format: json
                example: >-
                  "{"reverse_flow": false, "aux_meter_type":
                  "SIMULATION_AUX_METER_TYPE"}"
              networkSettings: &ref_203
                description: >-
                  Provides information about how to connect to the asset. The
                  data varies depending on the driver.
                type: object
                properties:
                  address:
                    type: string
                    example: 'wss://SMA3009885376.local:4712/ship/'
                  port:
                    type: integer
                    example: 1234
                    minimum: 0
                    maximum: 65535
            required:
              - type
              - system
    UpdateAssetRequestBody:
      description: Updates an asset.
      required: true
      content:
        application/json:
          schema:
            type: object
            description: A request to (partially) update an asset
            properties:
              name:
                type: string
                example: Some Human-Readable Asset Name
              system:
                description: >
                  Minimal information needed to check asset permission. Note:
                  This property is for verification purposes only and it will
                  not update or patch system ID.
                type: object
                properties:
                  id:
                    type: string
                    format: uuid
                required:
                  - id
              manufacturer:
                type: string
                example: TQ-Systems
              model:
                type: string
                example: B-control Energy Manager 300
              serialNumber:
                type: string
                example: 3cdae5c3c30c53b9
              priority:
                type: boolean
                nullable: true
              lastHeartbeatReceivedAt:
                type: string
                format: date-time
                description: At what time the last heartbeat was received.
              driverVersion:
                type: string
                example: v1.0.1
              type:
                type: string
                enum:
                  - CONTAINER
                  - EVSTATION
                  - HEAT_PUMP
                  - HEATER
                  - INVERTER
                  - IO_DEVICE
                  - METER
                  - UNKNOWN
              kind:
                type: string
                enum:
                  - BATTERY
                  - BTTP
                  - CLUSTER
                  - CONTAINER
                  - EVSTATION
                  - FUEL_CELL
                  - GRID
                  - HEAT_PUMP
                  - HEAT_PUMP_EXTERNAL
                  - HEATER
                  - HEATING
                  - HYBRID
                  - IO_DEVICE
                  - MISC
                  - PV
                  - PV_EXTERNAL
                  - UNKNOWN
                  - WIND_TURBINE
              metadata:
                type: string
                format: json
                example: >-
                  "{"reverse_flow": false, "aux_meter_type":
                  "SIMULATION_AUX_METER_TYPE"}"
              networkSettings: *ref_203
            required:
              - system
    CustomerAccountUpdateRequestBody: *ref_204
    ImpersonationRequestBody: *ref_205
    SetImportPowerLimitRequestBody: *ref_206
    SetUserLimitRequestBody: *ref_135
    SetRecommendedLimitRequestBody: *ref_207
    SetPeakPowerRequestBody: *ref_208
    SystemCreationRequestBody: *ref_209
    SystemUpdateRequestBody: *ref_210
    GatewayCreation: *ref_211
    ApplianceCreateRequestBody: *ref_212
    ApplianceUpdateRequestBody: *ref_213
    TimeOfUseSettingsPut: *ref_214
    TimeOfUseSettingsPatch: *ref_215
    SystemGridSignalsUpdateRequestBody: *ref_216
    CreatePolicyDocumentRequestBody: *ref_217
    UpdatePolicyDocumentRequestBody: *ref_218
    AssignPolicyDocumentToGroupRequestBody: *ref_219
    UpdatePowerSequenceRequestBody: *ref_220
  responses:
    GetScanConfigResponse: *ref_221
    CreateScanConfigResponse: *ref_222
    UpdateScanConfigResponse: *ref_223
    AccountNotFoundResponse: *ref_12
    ScanConfigurationNotFoundResponse: *ref_224
    TariffNotFoundResponse: *ref_60
    GetAccountResponse: *ref_19
    UpdateAccountResponse: *ref_21
    GetAccountsResponse: *ref_23
    CreateAccountResponse: *ref_225
    GetAccountDocumentsResponse: *ref_226
    GetAccountDocumentResponse: *ref_227
    CreateAccountDocumentResponse: *ref_228
    GetPolicyDocumentsInGroup: *ref_229
    GetSystemsResponse: *ref_230
    GetGroupsByAccountResponse: *ref_231
    CreatePolicyGroupResponse: *ref_232
    GetPolicyGroupResponse: *ref_233
    UpdatePolicyGroupResponse: *ref_234
    AssignSystemToAccountResponse: *ref_235
    UnassignSystemToAccountResponse: *ref_236
    MoveAccountResponse: *ref_237
    GetNotificationsResponse: *ref_238
    GetNotificationResponse: *ref_40
    NotificationNotFoundResponse: *ref_239
    CreateUserNotificationsResponse: *ref_240
    GetNotificationRuleResponse: *ref_42
    GetNotificationRulesResponse: *ref_241
    GetChargePlansResponse: *ref_242
    AssignChargePlanResponse: *ref_243
    ListRFIDTagsResponse:
      description: RFID tags returned.
      content:
        application/vnd.gridx.v2+json:
          schema:
            type: array
            items: *ref_48
    GetRFIDTagResponse: *ref_244
    CreateRFIDTagResponse:
      description: RFID tag created.
      content:
        application/vnd.gridx.v2+json:
          schema: *ref_48
    UpdateRFIDTagResponse: *ref_245
    ListAppliancesByRFIDTagsResponse: *ref_246
    GetEnergyMarketPricesResponse: *ref_247
    GetAccountParentsResponse: *ref_248
    BadGatewayExceptionResponse: *ref_147
    InvalidExceptionResponse: *ref_3
    InternalExceptionResponse: *ref_4
    ForbiddenExceptionResponse: *ref_11
    BadRequestExceptionResponse: *ref_15
    EntityNotFoundResponse: *ref_55
    CustomerNotFoundResponse:
      description: Customer Not found
      content:
        application/vnd.gridx.v2+json:
          schema: *ref_6
    UnauthorizedException: *ref_166
    ImpersonatedResp: *ref_249
    GetImportPowerLimitResponse: *ref_250
    SetImportPowerLimitResponse: *ref_251
    ImportPowerLimitNotFoundResponse: *ref_252
    HistoricalPowerLimitsResponse: *ref_253
    HistoricalPowerLimitsNotFoundResponse: *ref_254
    NotFoundErrorResponse: *ref_127
    JobNotFoundResponse: *ref_92
    GatewayNotFoundResponse: *ref_85
    SystemNotFoundResponse: *ref_83
    CapacityTariffResponse: *ref_134
    DeleteCapacityTariffRecommendationResponse: *ref_255
    DeletePeakPowerResponse: *ref_256
    SystemCreated: *ref_257
    ConflictExceptionResponse: *ref_143
    TimeOfUseSettingsResp: *ref_149
    NotFoundExceptionResponse: *ref_158
    ListPoliciesResponse: *ref_258
    CreatePolicyDocumentResponse: *ref_259
    PolicyDocumentResponse: *ref_260
    GetDevicesResponse: *ref_261
    DeviceNotFoundResponse: *ref_262
    GetUserPolicyDocumentsResponse: *ref_263
    UserAccounts: *ref_264
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
    BearerAuthentication:
      type: http
      scheme: bearer
  schemas:
    PlatformMapping: *ref_265
    ScanConfigurationSet: *ref_5
    ScanConfiguration: *ref_2
    ChargePlan: *ref_45
    RFIDTag: *ref_48
    RFIDTagStrict: *ref_198
    NotificationsRule: *ref_41
    NotificationsRuleStrict: *ref_44
    Filter: *ref_266
    NotificationType: *ref_267
    File: *ref_31
    FileCreate: *ref_268
    EnergyTariff: *ref_58
    EnergyTariffStrict: *ref_269
    EnergyTariffPeriod: *ref_270
    EnergyMarketData: *ref_271
    GeneralException: *ref_0
    NotFoundException: *ref_6
    InvalidException: *ref_272
    InternalException: *ref_273
    AccountSolution: *ref_274
    AbstractAccount: *ref_7
    AccountKind: *ref_8
    AbstractLocation: *ref_24
    Address: *ref_9
    Account: *ref_10
    ForbiddenException: *ref_275
    AccountUpdate: *ref_276
    AccountUpdateStrict: *ref_277
    BadRequestException: *ref_278
    BadGateway: *ref_279
    AbstractAPIToken: *ref_13
    APIToken: *ref_182
    AbstractPolicyGroup: *ref_33
    PolicyGroup: *ref_32
    Language: *ref_280
    UserWithoutAuth: *ref_34
    User: *ref_29
    OrganizationalAPIToken: *ref_14
    APITokenCreation: *ref_281
    OrganizationalAPITokenCreation: *ref_282
    OrganizationalAPITokenCreationStrict: *ref_283
    OrganizationalAPITokenWithSecret: *ref_16
    OrganizationalAPITokenStrict: *ref_284
    AccountKindWithDefault: *ref_285
    AccountCreate: *ref_286
    AccountCreateStrict: *ref_287
    MoveAccount: *ref_288
    MoveAccountStrict: *ref_289
    SystemSolution: *ref_290
    SystemCurtailmentStrategy: *ref_291
    Location: *ref_292
    MetadataWizard: *ref_293
    DateTime: *ref_25
    SyncEntitySettings: *ref_26
    DerAPISettings: *ref_294
    MetadataEMS: *ref_295
    MetadataEnergy: *ref_296
    MetadataEnergySupplier: *ref_297
    MetadataSmartMeter: *ref_298
    MetadataElectricVehicle: *ref_27
    MetadataElectricVehicleProfile: *ref_299
    SavingKind: *ref_137
    SystemMetadata: *ref_300
    AbstractSystem: *ref_82
    PositivePower:
      title: Positive Power in Watt.
      type: integer
      format: int64
      minimum: 0
      example: 501
    AbstractEVChargingSchedule: *ref_130
    EVChargingSchedule: *ref_129
    AbstractGateway: *ref_86
    GatewayType: *ref_87
    ConnectionStatus: *ref_301
    AdditionalIdentifier: *ref_302
    ScannerName: *ref_88
    Gateway: *ref_84
    SystemWithoutProductOption: *ref_80
    EmbeddedAccounts: *ref_81
    AbstractProductOption: *ref_175
    AbstractProductFunctionality: *ref_173
    ProductFunctionality: *ref_28
    ProductOption: *ref_177
    System: *ref_72
    SystemWithUsers: *ref_79
    SystemAccountAssignment: *ref_303
    SystemAccountAssignmentStrict: *ref_304
    SystemAccountUnAssignment: *ref_305
    PolicyDocumentAssign: *ref_306
    PolicyDocumentAssignStrict: *ref_307
    PolicyGroupCreate: *ref_308
    PolicyGroupCreateStrict: *ref_309
    AbstractCustomer: *ref_310
    CustomerWithoutAuth: *ref_311
    PolicyGroupWithCustomers: *ref_312
    PolicyGroupUpdate: *ref_313
    PolicyGroupUpdateStrict: *ref_314
    AbstractPolicyDocument: *ref_169
    AbstractPolicyStatement: *ref_170
    PolicyStatement: *ref_315
    PolicyDocument: *ref_168
    AbstractNotification: *ref_181
    Notification: *ref_37
    NotificationStrict: *ref_39
    ApplianceConnectionStatus: *ref_316
    ApplianceStatus: *ref_317
    ApplianceType: *ref_95
    ApplianceInactive: *ref_93
    ApplianceName: *ref_94
    ApplianceReverseFlow: *ref_114
    ApplianceRoom: *ref_115
    ApplianceSerialNumber: *ref_101
    Network: *ref_96
    ApplianceParent: *ref_100
    LoadSettings: *ref_97
    AbstractSensorSettings: *ref_98
    SensorSettings: *ref_318
    Source: *ref_319
    CommissioningKind: *ref_320
    ApplianceState: *ref_118
    StateTransition: *ref_321
    AbstractState: *ref_99
    State: *ref_322
    AbstractEnergyManagementSettings: *ref_103
    EnergyManagementSettings: *ref_323
    AbstractCryptoSetting: *ref_102
    CryptoSetting: *ref_324
    BaseAppliance: *ref_51
    InverterKind: *ref_325
    AbstractBatteryInformation: *ref_50
    AbstractInverter: *ref_104
    HardwareStatus: *ref_120
    BatteryInformation: *ref_326
    Inverter: *ref_327
    AbstractMeter: *ref_106
    MeterKind: *ref_328
    Meter: *ref_329
    AbstractHeatPumpInformation: *ref_52
    AbstractHeatPump: *ref_108
    HeatPumpInformation: *ref_330
    HeatPump: *ref_331
    EVSEID: *ref_117
    EVLoadManagementParameters: *ref_116
    AbstractEVStation: *ref_107
    EVStation: *ref_332
    AbstractHeatMeter: *ref_109
    HeatMeter: *ref_333
    AbstractElectrolyzer: *ref_110
    Electrolyzer: *ref_334
    IODeviceInputAction: *ref_335
    IODeviceInputChannel: *ref_336
    IODeviceOutputActionSGReady: *ref_337
    IODeviceOutputAction: *ref_338
    IODeviceOutputChannel: *ref_339
    AbstractIODeviceInformation: *ref_53
    AbstractIODevice: *ref_111
    IODeviceInformation: *ref_340
    IODevice: *ref_341
    AbstractHeater: *ref_112
    Heater: *ref_342
    AbstractContainer: *ref_113
    Container: *ref_343
    Appliance: *ref_62
    AbstractBiddingZone: *ref_56
    BiddingZone: *ref_57
    BiddingZoneSet: *ref_344
    BiddingZoneSetStrict: *ref_345
    Assets:
      description: A List of Assets and metadata about the list.
      type: object
      properties:
        assets:
          type: array
          items: &ref_346
            description: An Asset as its defined for the gridX Platform.
            type: object
            properties:
              id:
                type: string
                format: uuid
                readOnly: true
              name:
                type: string
                example: Some Human-Readable Asset Name
              applicationId:
                type: string
                format: uuid
                readOnly: true
              system: &ref_347
                description: >-
                  Minimal information about the System that the Asset belongs
                  to.
                type: object
                readOnly: true
                properties:
                  id:
                    type: string
                    format: uuid
                    readOnly: true
                  name:
                    type: string
                    example: GridBox at Office
                    readOnly: true
                required:
                  - id
              status:
                type: string
                enum:
                  - AVAILABLE
                  - UNAVAILABLE
                  - UNKNOWN
                description: >
                  An asset is considered as `AVAILABLE` if it sent a heartbeat
                  in the past 5 minutes. Respectively, if there 

                  hasn't been a heartbeat in the past 5 minutes, the asset is
                  considered as `UNAVAILABLE`. In case there isn't

                  a heartbeat (e.g. in case of a new Asset), the status will be
                  `UNKNOWN`.
                default: UNKNOWN
              manufacturer:
                type: string
                example: TQ-Systems
                readOnly: true
              model:
                type: string
                example: B-control Energy Manager 300
                readOnly: true
              serialNumber:
                type: string
                example: 3cdae5c3c30c53b9
                readOnly: true
              priority:
                type: boolean
                nullable: true
              lastHeartbeatReceivedAt:
                type: string
                format: date-time
                readOnly: true
                description: At what time the last heartbeat was received.
                nullable: true
              driverVersion:
                type: string
                example: v1.0.1
                readOnly: true
              type:
                type: string
                enum:
                  - CONTAINER
                  - EVSTATION
                  - HEAT_PUMP
                  - HEATER
                  - INVERTER
                  - IO_DEVICE
                  - METER
                  - UNKNOWN
              kind:
                type: string
                enum:
                  - BATTERY
                  - BTTP
                  - CLUSTER
                  - CONTAINER
                  - EVSTATION
                  - FUEL_CELL
                  - GRID
                  - HEAT_PUMP
                  - HEAT_PUMP_EXTERNAL
                  - HEATER
                  - HEATING
                  - HYBRID
                  - IO_DEVICE
                  - MISC
                  - PV
                  - PV_EXTERNAL
                  - UNKNOWN
                  - WIND_TURBINE
              metadata:
                example: >-
                  "{"reverse_flow": false, "aux_meter_type":
                  "SIMULATION_AUX_METER_TYPE"}"
              networkSettings: *ref_203
              createdAt:
                type: string
                format: date-time
                readOnly: true
              updatedAt:
                type: string
                format: date-time
                readOnly: true
            required:
              - applicationId
              - system
              - type
        metadata: &ref_348
          type: object
          readOnly: true
          description: >-
            Provides information about the returned object, such as length of
            the list and distinct values.
          properties:
            counts:
              type: object
              description: >
                This will only be available if the response is a list or
                contains multiple items. It provides multiple 

                "counts" of the list that is being returned.
              properties:
                total:
                  readOnly: true
                  description: >
                    The total number of objects in the list, regardless of any
                    query parameters such as filtering or 

                    pagination.
                  type: integer
                  example: 321
                filtered:
                  readOnly: true
                  description: >
                    The number of objects in the list after the filters have
                    been applied. This ignores pagination and will 

                    show how many objects are available with the given filters.
                    This number will always be less than or 

                    equal to the `total` count.
                  type: integer
                  example: 123
      required:
        - assets
    Asset: *ref_346
    AssetSystem: *ref_347
    NetworkSettings: *ref_203
    AssetsMetadata: *ref_348
    AbstractCluster: *ref_63
    AbstractClusterStrict: *ref_349
    Cluster: *ref_61
    ClusterSet: *ref_350
    ClusterSetStrict: *ref_65
    Message:
      title: Message
      description: Message represents a string.
      type: object
      properties:
        message:
          type: string
      required:
        - message
    AuthEvent: *ref_351
    CustomerAccount: *ref_68
    UnauthorizedException: *ref_352
    CustomerAccountStrict: *ref_353
    CustomerAccountUpdate: *ref_354
    CustomerAccountUpdateStrict: *ref_355
    UserStrict: *ref_180
    ImpersonationStrict: *ref_356
    AbstractImportPowerLimit: *ref_76
    ImportPowerLimit: *ref_77
    ImportPowerLimitSet: *ref_76
    ImportPowerLimitSetStrict: *ref_357
    PowerLimitDynamic: *ref_358
    HistoricalPowerLimits: *ref_359
    UserLimitSet: *ref_360
    UserLimitSetStrict: *ref_361
    RecommendedLimitSet: *ref_362
    RecommendedLimitSetStrict: *ref_363
    PeakPowerSet: *ref_364
    PeakPowerSetStrict: *ref_365
    BatteryControlSettings: *ref_123
    BatteryControlSettingsStrict: *ref_124
    CapacityTariff: *ref_136
    GridConnectionPointForecasts: *ref_366
    GridConnectionPointPeriod: *ref_367
    StatusHistory: *ref_368
    RunStatuses: *ref_369
    RunStatus: *ref_151
    StatusValue: *ref_370
    SystemCreate: *ref_371
    SystemCreateStrict: *ref_372
    SystemUpdate: *ref_373
    SystemUpdateStrict: *ref_374
    GatewayWithSystem: *ref_375
    GatewayUpdate: *ref_376
    GatewayUpdateStrict: *ref_377
    GatewayCreate: *ref_378
    GatewayCreateStrict: *ref_379
    Scanner: *ref_380
    Scan: *ref_381
    JobType: *ref_382
    JobState: *ref_383
    AbstractJob: *ref_91
    JobExecution: *ref_384
    JobWithExecutions: *ref_89
    JobCreation: *ref_385
    BaseApplianceCreate: *ref_105
    InverterCreate: *ref_386
    MeterCreate: *ref_387
    EVStationCreate: *ref_388
    HeatPumpCreate: *ref_389
    HeatMeterCreate: *ref_390
    ElectrolyzerCreate: *ref_391
    IODeviceCreate: *ref_392
    HeaterCreate: *ref_393
    ContainerCreate: *ref_394
    ApplianceCreate: *ref_395
    ApplianceCreateStrict: *ref_396
    ApplianceUpdate: *ref_397
    ApplianceUpdateStrict: *ref_398
    HardwareStatusData: *ref_399
    AbstractEVChargingStationConfiguration: *ref_121
    EVChargingStationConfiguration: *ref_122
    EVChargingStationConfigurationCreation: *ref_400
    EVChargingStationConfigurationCreationStrict: *ref_401
    EVChargingStationConfigurationUpdate: *ref_402
    AbstractElectricVehicleProfile: *ref_125
    ElectricVehicleProfile: *ref_126
    ElectricVehicleProfileCreate: *ref_403
    ElectricVehicleProfileUpdate: *ref_404
    EVChargingScheduleCreation: *ref_405
    EVChargingScheduleCreationStrict: *ref_406
    EVChargingScheduleUpdate: *ref_407
    EVChargingScheduleUpdateStrict: *ref_408
    AbstractPowerLimitSchedule: *ref_132
    PowerLimitSchedule: *ref_133
    PowerLimitScheduleCreate: *ref_409
    PowerLimitScheduleCreateStrict: *ref_410
    PowerLimitScheduleUpdate: *ref_411
    PowerLimitScheduleUpdateStrict: *ref_412
    PowerLimitIntervals: *ref_413
    ConflictException: *ref_414
    Money: *ref_415
    Saving: *ref_416
    TariffV2StaticPeriodTime: *ref_138
    TariffV2StaticPeriod: *ref_417
    AbstractMarketDataSettings: *ref_139
    AbstractTariffV2: *ref_140
    MarketDataSettings: *ref_141
    TariffV2: *ref_142
    TariffV2Creation: *ref_418
    TariffV2CreationStrict: *ref_419
    TariffV2Update: *ref_420
    TariffV2UpdateStrict: *ref_421
    AbstractEndpriceTariffV2Period: *ref_144
    AbstractEndpriceTariffV2: *ref_145
    EndpriceTariffV2Period: *ref_422
    EndpriceTariffV2: *ref_146
    EndPriceTariffV2Set: *ref_423
    EndPriceTariffV2SetStrict: *ref_424
    DecisionInsight: *ref_425
    Decision: *ref_426
    DecisionMetrics: *ref_427
    Decisions: *ref_428
    TimeOfUseSettings: *ref_148
    TimeOfUseSettingsPut: *ref_429
    TimeOfUseSettingsPutStrict: *ref_430
    TimeOfUseSettingsPatchStrict: *ref_431
    ToUErrorCode: *ref_432
    ToUWarnings: *ref_433
    ToUReadinessReason: *ref_434
    ToUReadiness: *ref_435
    SystemGridSignals: *ref_152
    SystemGridSignalsUpdate: *ref_436
    SystemGridSignalsUpdateStrict: *ref_437
    SystemEMSCapability: *ref_438
    SystemEMSCapabilities: *ref_439
    Measurement: *ref_165
    Measurements: *ref_167
    MeasurementExtended: *ref_157
    MeasurementBatteryExtended: *ref_440
    MeasurementEVStationExtended: *ref_441
    MeasurementGrid: *ref_442
    MeasurementGridMeterReading: *ref_443
    CombinedMeasurement: *ref_444
    InverterMeasurement: *ref_161
    HeatMeterMeasurement: *ref_159
    ElectrolyzerMeasurement: *ref_160
    AUXMeterMeasurement: *ref_162
    EnergyManagementMeasurement: *ref_164
    EVStationMeasurement: *ref_154
    EVChargingStationMeasurement: *ref_163
    BatteryMeasurement: *ref_153
    HeatPumpMeasurement: *ref_445
    MeasurementHeating: *ref_155
    MeasurementAppliance: *ref_156
    RawInverterMeasurement: *ref_446
    RawBatteryMeasurement: *ref_447
    RawMeterMeasurement: *ref_448
    RawEVChargingStationMeasurement: *ref_449
    RawHeaterMeasurement: *ref_450
    RawHeatpumpMeasurement: *ref_451
    PolicyDocumentUpdate: *ref_452
    PolicyDocumentUpdateStrict: *ref_171
    PolicyGroupStrict: *ref_453
    ProductFunctionalityCreation: *ref_454
    ProductFunctionalityCreationStrict: *ref_455
    ProductFunctionalityAssignment: *ref_176
    ProductOptionCreation: *ref_456
    ProductOptionCreationStrict: *ref_457
    ProductOptionUpdate: *ref_458
    ProductOptionUpdateStrict: *ref_459
    PowerSequenceUpdate: *ref_460
    PowerSequenceUpdateStrict: *ref_461
    devices: *ref_462
    device: *ref_463
    usecases: *ref_464
    usecase: *ref_465
    resources: *ref_466
    resource: *ref_467
    bindings: *ref_468
    binding: *ref_469
    powerSequence: *ref_179
    powerTimeSlots: *ref_470
    powerTimeSlot: *ref_471
    LoginEvent: *ref_472
    StarredSystem: *ref_473
    StarredAccount: *ref_474
    UserAccount: *ref_475
    NotificationUpdate: *ref_476
    NotificationUpdateStrict: *ref_477
    APITokenCreationStrict: *ref_478
    PersonalAPITokenWithSecret: *ref_479
    APITokenUpdate: *ref_480
    APITokenUpdateStrict: *ref_481
  examples:
    powerLimitScheduleDaily: *ref_482
    powerLimitScheduleWeekends: *ref_483
    systemPatch: *ref_484
    enableDerApi: *ref_485
    enableDerApiWithoutFlexibilitiesSync: *ref_486
    scheduledStartPowerSequence: *ref_487
    runningPowerSequence: *ref_488
    scheduledPowerSequence: *ref_489
